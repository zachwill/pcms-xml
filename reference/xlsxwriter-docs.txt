================================================================
Directory Structure
================================================================
dev/
  docs/
    source/
      alternatives.rst
      author.rst
      bugs.rst
      changes.rst
      chart_examples.rst
      chart.rst
      chartsheet.rst
      color.rst
      contents.rst
      example_array_formula.rst
      example_autofilter.rst
      example_autofit_manually.rst
      example_autofit.rst
      example_background.rst
      example_chart_area.rst
      example_chart_bar.rst
      example_chart_clustered.rst
      example_chart_column.rst
      example_chart_combined.rst
      example_chart_data_labels.rst
      example_chart_data_table.rst
      example_chart_data_tools.rst
      example_chart_date_axis.rst
      example_chart_doughnut.rst
      example_chart_gauge.rst
      example_chart_gradient.rst
      example_chart_line.rst
      example_chart_pareto.rst
      example_chart_pattern.rst
      example_chart_pie.rst
      example_chart_radar.rst
      example_chart_scatter.rst
      example_chart_secondary_axis.rst
      example_chart_simple.rst
      example_chart_stock.rst
      example_chart_styles.rst
      example_chartsheet.rst
      example_check_close.rst
      example_checkbox.rst
      example_comments1.rst
      example_comments2.rst
      example_conditional_format.rst
      example_data_validate.rst
      example_datetimes.rst
      example_defined_name.rst
      example_demo.rst
      example_diagonal_border.rst
      example_django_simple.rst
      example_doc_properties.rst
      example_dynamic_arrays.rst
      example_embedded_images.rst
      example_headers_footers.rst
      example_hello_world.rst
      example_hide_row_col.rst
      example_hide_sheet.rst
      example_http_server.rst
      example_hyperlink.rst
      example_ignore_errors.rst
      example_images_bytesio.rst
      example_images.rst
      example_inheritance1.rst
      example_inheritance2.rst
      example_lambda.rst
      example_macros.rst
      example_merge_rich.rst
      example_merge1.rst
      example_outline1.rst
      example_outline2.rst
      example_pandas_autofilter.rst
      example_pandas_chart_columns.rst
      example_pandas_chart_line.rst
      example_pandas_chart.rst
      example_pandas_column_formats.rst
      example_pandas_conditional.rst
      example_pandas_datetime.rst
      example_pandas_header_format.rst
      example_pandas_multiple.rst
      example_pandas_percentage.rst
      example_pandas_positioning.rst
      example_pandas_simple.rst
      example_pandas_table.rst
      example_panes.rst
      example_polars_chart.rst
      example_polars_checkbox.rst
      example_polars_conditional.rst
      example_polars_format_custom.rst
      example_polars_format_default.rst
      example_polars_multiple.rst
      example_polars_positioning.rst
      example_polars_simple.rst
      example_polars_sparklines.rst
      example_polars_xlsxwriter.rst
      example_protection.rst
      example_rich_strings.rst
      example_right_to_left.rst
      example_sensitivity_label.rst
      example_sparklines1.rst
      example_sparklines2.rst
      example_tab_colors.rst
      example_tables.rst
      example_textbox.rst
      example_unicode_polish_utf8.rst
      example_unicode_shift_jis.rst
      example_unicode.rst
      example_user_types1.rst
      example_user_types2.rst
      example_user_types3.rst
      example_watermark.rst
      examples.rst
      exceptions.rst
      faq.rst
      format.rst
      getting_started.rst
      index.rst
      introduction.rst
      license.rst
      page_setup.rst
      pandas_examples.rst
      polars_examples.rst
      third_party.rst
      tutorial01.rst
      tutorial02.rst
      tutorial03.rst
      utility.rst
      workbook.rst
      working_with_autofilters.rst
      working_with_cell_comments.rst
      working_with_cell_notation.rst
      working_with_charts.rst
      working_with_colors.rst
      working_with_conditional_formats.rst
      working_with_data_validation.rst
      working_with_data.rst
      working_with_dates_and_time.rst
      working_with_formulas.rst
      working_with_macros.rst
      working_with_memory.rst
      working_with_object_positioning.rst
      working_with_outlines.rst
      working_with_pandas.rst
      working_with_polars.rst
      working_with_sparklines.rst
      working_with_tables.rst
      working_with_textboxes.rst
      worksheet.rst

================================================================
Files
================================================================

================
File: dev/docs/source/alternatives.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _alternatives:

Alternative modules for handling Excel files
============================================

The following are some Python alternatives to XlsxWriter.


OpenPyXL
--------

From the `openpyxl <https://openpyxl.readthedocs.io/en/stable/>`_ documentation:

    openpyxl is a Python library to read/write Excel 2010 xlsx/xlsm/xltx/xltm
    files.

Xlwings
-------

From the `xlwings <https://www.xlwings.org/>`_ webpage:

   Leverage Python's scientific stack for interactive data analysis using
   Jupyter Notebooks, NumPy, Pandas, scikit-learn etc. As such, xlwings is a
   free alternative to tools like Power BI or Tableau (Windows & Mac).

XLWT
----

From the `xlwt <https://xlwt.readthedocs.io/en/latest/>`_ documentation:

   xlwt is a library for writing data and formatting information to older
   Excel files (ie: .xls)

XLRD
----

From the `xlrd <https://xlrd.readthedocs.io/en/latest/>`_ documentation:

  xlrd is a library for reading data and formatting information from Excel
  files in the historical `.xls` format.

================
File: dev/docs/source/author.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _author:

Author
======

XlsxWriter was written by John McNamara.

* `GitHub <https://github.com/jmcnamara>`_
* Mastodon: @jmcnamara@hackyderm.io


Asking questions
----------------

If you have questions about XlsxWriter here are some ways to deal with them:

* **Bug Reports**:

  See the :ref:`reporting_bugs` section of the docs.

* **Feature Requests**:

  Open a Feature Request issue on
  `Github issues <https://github.com/jmcnamara/XlsxWriter/issues>`_.

* **Pull Requests**:

  See the `Contributing Guide
  <https://github.com/jmcnamara/XlsxWriter/blob/main/CONTRIBUTING.md>`_.
  Note, all Pull Requests must start with an Issue Tracker.

* **General Questions**:

  General questions about how to use the module should be asked on
  `StackOverflow  <https://stackoverflow.com/questions/tagged/xlsxwriter>`_.
  Add the ``xlsxwriter`` tag to the question.

  Questions on StackOverflow have the advantage of (usually) getting several
  answers and it also leaves a searchable question for someone else.

* **Email**:

  If none of the above apply you can contact me at jmcnamara@cpan.org.


Sponsorship and Donations
-------------------------

I write and maintain a series of open source libraries for creating Excel
files. The most commonly used are XlsxWriter in Python, Libxlsxwriter in C and
Excel::Writer::XLSX and Spreadsheet::WriteExcel in Perl.

My aim is to write well documented and well tested code that does what the
user needs and doesn't get in their way.  You can help make this continue, or
show your appreciation for work to date, by making a donation via
`PayPal <https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=RRZCPSL65X858>`_.

.. raw:: html

   <center>
   <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
   <input type="hidden" name="cmd" value="_s-xclick">
   <input type="hidden" name="hosted_button_id" value="RRZCPSL65X858">
   <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal">
   <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
   </form>
   </center>

================
File: dev/docs/source/bugs.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _bugs:

Known Issues and Bugs
=====================

This section lists known issues and bugs and gives some information on how to
submit bug reports.

"Content is Unreadable. Open and Repair"
----------------------------------------

You may occasionally see an Excel warning when opening an XlsxWriter file
like:

   Excel could not open file.xlsx because some content is unreadable. Do you
   want to open and repair this workbook.

This ominous sounding message is Excel's default warning for any validation
error in the XML used for the components of the XLSX file.

The error message and the actual file aren't helpful in debugging issues like
this. If you do encounter this warning you should open an issue on GitHub with
a program to replicate it (see :ref:`reporting_bugs`).


"Exception caught in workbook destructor. Explicit close() may be required"
---------------------------------------------------------------------------

The following exception, or similar, can occur if the :func:`close` method
isn't used at the end of the program::

    Exception Exception: Exception('Exception caught in workbook destructor.
    Explicit close() may be required for workbook.',)
    in <bound method Workbook.__del__ of <xlsxwriter.workbook.Workbookobject
    at 0x103297d50>>

Note, it is possible that this exception will also be raised as part of
another exception that occurs during workbook destruction. In either case
ensure that there is an explicit ``workbook.close()`` in the program.


Formulas displayed as ``#NAME?`` until edited
---------------------------------------------

There are a few reasons why a formula written by XlsxWriter would generate a
``#NAME?`` error in Excel:

* Invalid formula syntax.
* Non-English function names.
* Semi-colon separators instead of commas.
* Use of Excel 2010 and later functions without a prefix.

See :ref:`working_with_formulas` and :ref:`formula_errors` for a more details
and a explanation of how to debug the issue.


Formula results displaying as zero in non-Excel applications
------------------------------------------------------------

Due to wide range of possible formulas and interdependencies between them
XlsxWriter doesn't, and realistically cannot, calculate the result of a
formula when it is written to an XLSX file. Instead, it stores the value 0 as
the formula result. It then sets a global flag in the XLSX file to say that
all formulas and functions should be recalculated when the file is opened.

This is the method recommended in the Excel documentation and in general it
works fine with spreadsheet applications. However, applications that donâ€™t
have a facility to calculate formulas, such as Excel Viewer, or several mobile
applications, will only display the 0 results.

See :ref:`formula_result` for more details and a workaround.


Images not displayed correctly in Excel 2001 for Mac and non-Excel applications
-------------------------------------------------------------------------------

Images inserted into worksheets via :func:`insert_image` may not display
correctly in Excel 2011 for Mac and non-Excel applications such as OpenOffice
and LibreOffice. Specifically the images may looked stretched or squashed.

This is not specifically an XlsxWriter issue. It also occurs with files created
in Excel 2007 and Excel 2010.


Charts series created from Worksheet Tables cannot have user defined names
--------------------------------------------------------------------------

In Excel, charts created from :ref:`Worksheet Tables <tables>` have a
limitation where the data series name, if specified, must refer to a cell
within the table.

To workaround this Excel limitation you can specify a user defined name in the
table and refer to that from the chart. See :ref:`charts_from_tables`.


.. _reporting_bugs:

Reporting Bugs
==============

Here are some tips on reporting bugs in XlsxWriter.


Upgrade to the latest version of the module
-------------------------------------------

The bug you are reporting may already be fixed in the latest version of the
module. You can check which version of XlsxWriter that you are using as
follows::

    python -c "import xlsxwriter; print(xlsxwriter.__version__)"

Check the :ref:`changes` section to see what has changed in the latest versions.


Read the documentation
----------------------

Read or search the XlsxWriter documentation to see if the issue you are
encountering is already explained.

Look at the example programs
----------------------------

There are many :ref:`main_examples` in the distribution. Try to identify an
example program that corresponds to your query and adapt it to use as a bug
report.

Use the official XlsxWriter Issue tracker on GitHub
---------------------------------------------------

The official XlsxWriter
`Issue tracker is on GitHub <https://github.com/jmcnamara/XlsxWriter/issues>`_.


Pointers for submitting a bug report
------------------------------------

#. Describe the problem as clearly and as concisely as possible.

#. Include a sample program. This is probably the most important step. It is
   generally easier to describe a problem in code than in written prose.

#. The sample program should be as small as possible to demonstrate the
   problem. Don't copy and paste large non-relevant sections of your program.

A sample bug report is shown below. This format helps to analyze and respond to
the bug report more quickly.

   **Issue with SOMETHING**

   I am using XlsxWriter to do SOMETHING but it appears to do SOMETHING ELSE.

   I am using Python version X.Y.Z and XlsxWriter x.y.z.

   Here is some code that demonstrates the problem::

       import xlsxwriter

       workbook = xlsxwriter.Workbook('hello.xlsx')
       worksheet = workbook.add_worksheet()

       worksheet.write('A1', 'Hello world')

       workbook.close()

================
File: dev/docs/source/changes.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

:tocdepth: 1

.. _changes:

Changes in XlsxWriter
=====================

This section shows changes and bug fixes in the XlsxWriter module.

.. include:: ../../../Changes

================
File: dev/docs/source/chart_examples.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _chart_examples:

Chart Examples
==============

The following are some of the examples included in the
`examples <https://github.com/jmcnamara/XlsxWriter/tree/main/examples>`_
directory of the XlsxWriter distribution.

.. toctree::
   :maxdepth: 1

   example_chart_simple.rst
   example_chart_area.rst
   example_chart_bar.rst
   example_chart_column.rst
   example_chart_line.rst
   example_chart_pie.rst
   example_chart_doughnut.rst
   example_chart_scatter.rst
   example_chart_radar.rst
   example_chart_stock.rst
   example_chart_styles.rst
   example_chart_pattern.rst
   example_chart_gradient.rst
   example_chart_secondary_axis.rst
   example_chart_combined.rst
   example_chart_pareto.rst
   example_chart_gauge.rst
   example_chart_clustered.rst
   example_chart_date_axis.rst
   example_chart_data_table.rst
   example_chart_data_tools.rst
   example_chart_data_labels.rst
   example_chartsheet.rst

================
File: dev/docs/source/chart.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _chart_class:

The Chart Class
===============

The ``Chart`` module is a base class for modules that implement charts in
XlsxWriter. The information in this section is applicable to all of the
available chart subclasses, such as Area, Bar, Column, Doughnut, Line, Pie,
Scatter, Stock and Radar.

A chart object is created via the Workbook :func:`add_chart()` method where the
chart type is specified::

    chart = workbook.add_chart({'type': 'column'})

It is then inserted into a worksheet as an embedded chart using the
:func:`insert_chart` Worksheet method::

    worksheet.insert_chart('A7', chart)

Or it can be set in a chartsheet using the :func:`set_chart` Chartsheet method::

    chartsheet = workbook.add_chartsheet()
    # ...
    chartsheet.set_chart(chart)


The following is a small working example or adding an embedded chart::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('chart.xlsx')
    worksheet = workbook.add_worksheet()

    # Create a new Chart object.
    chart = workbook.add_chart({'type': 'column'})

    # Write some data to add to plot on the chart.
    data = [
        [1, 2, 3, 4, 5],
        [2, 4, 6, 8, 10],
        [3, 6, 9, 12, 15],
    ]

    worksheet.write_column('A1', data[0])
    worksheet.write_column('B1', data[1])
    worksheet.write_column('C1', data[2])

    # Configure the chart. In simplest case we add one or more data series.
    chart.add_series({'values': '=Sheet1!$A$1:$A$5'})
    chart.add_series({'values': '=Sheet1!$B$1:$B$5'})
    chart.add_series({'values': '=Sheet1!$C$1:$C$5'})

    # Insert the chart into the worksheet.
    worksheet.insert_chart('A7', chart)

    workbook.close()

.. image:: _images/chart_simple.png
   :scale: 75 %


The supported chart types are:

* ``area``: Creates an Area (filled line) style chart.

* ``bar``: Creates a Bar style (transposed histogram) chart.

* ``column``: Creates a column style (histogram) chart.

* ``line``: Creates a Line style chart.

* ``pie``: Creates a Pie style chart.

* ``doughnut``: Creates a Doughnut style chart.

* ``scatter``: Creates a Scatter style chart.

* ``stock``: Creates a Stock style chart.

* ``radar``: Creates a Radar style chart.


Chart subtypes are also supported for some chart types::

    workbook.add_chart({'type': 'bar', 'subtype': 'stacked'})

The available subtypes are::

    area
        stacked
        percent_stacked

    bar
        stacked
        percent_stacked

    column
        stacked
        percent_stacked

    scatter
        straight_with_markers
        straight
        smooth_with_markers
        smooth

    line
        stacked
        percent_stacked

    radar
        with_markers
        filled


Methods that are common to all chart types are documented below. See
:ref:`working_with_charts` for chart specific information.


chart.add_series()
------------------

.. py:function:: add_series(options)

   Add a data series to a chart.

   :param dict options: A dictionary of chart series options.

In Excel a chart **series** is a collection of information that defines which
data is plotted such as values, axis labels and formatting.

For an XlsxWriter chart object the ``add_series()`` method is used to set the
properties for a series::

    chart.add_series({
        'categories': '=Sheet1!$A$1:$A$5',
        'values':     '=Sheet1!$B$1:$B$5',
        'line':       {'color': 'red'},
    })

    # Or using a list of values instead of category/value formulas:
    #     [sheetname, first_row, first_col, last_row, last_col]
    chart.add_series({
        'categories': ['Sheet1', 0, 0, 4, 0],
        'values':     ['Sheet1', 0, 1, 4, 1],
        'line':       {'color': 'red'},
    })

As shown above the ``categories`` and ``values`` can take either a range
formula such as ``=Sheet1!$A$2:$A$7`` or, more usefully when generating the
range programmatically, a list with zero indexed row/column values.

The series options that can be set are:

* ``values``: This is the most important property of a series and is the only
  mandatory option for every chart object. This option links the chart with
  the worksheet data that it displays. The data range can be set using a
  formula as shown in the first example above or using a list of values as
  shown in the second example.

* ``categories``: This sets the chart category labels. The category is more
  or less the same as the X axis. In most chart types the ``categories``
  property is optional and the chart will just assume a sequential series from
  ``1..n``.

* ``name``: Set the name for the series. The name is displayed in the formula
  bar. For non-Pie/Doughnut charts it is also displayed in the legend. The
  name property is optional and if it isn't supplied it will default to
  ``Series 1..n``. The name can also be a formula such as ``=Sheet1!$A$1`` or
  a list with a sheetname, row and column such as ``['Sheet1', 0, 0]``.

* ``line``: Set the properties of the series line type such as color and
  width. See :ref:`chart_formatting_line`.

* ``border``: Set the border properties of the series such as color and
  style. See :ref:`chart_formatting_border`.

* ``fill``: Set the solid fill properties of the series such as color. See
  :ref:`chart_formatting_fill`.

* ``pattern``: Set the pattern fill properties of the series. See
  :ref:`chart_formatting_pattern`.

* ``gradient``: Set the gradient fill properties of the series. See
  :ref:`chart_formatting_gradient`.

* ``marker``: Set the properties of the series marker such as style and
  color. See :ref:`chart_series_option_marker`.

* ``trendline``: Set the properties of the series trendline such as linear,
  polynomial and moving average types. See
  :ref:`chart_series_option_trendline`.

* ``smooth``: Set the smooth property of a line series.

* ``y_error_bars``: Set vertical error bounds for a chart series. See
  :ref:`chart_series_option_error_bars`.

* ``x_error_bars``: Set horizontal error bounds for a chart series. See
  :ref:`chart_series_option_error_bars`.

* ``data_labels``: Set data labels for the series. See
  :ref:`chart_series_option_data_labels`.

* ``points``: Set properties for individual points in a series. See
  :ref:`chart_series_option_points`.

* ``invert_if_negative``: Invert the fill color for negative values. Usually
  only applicable to column and bar charts.

* ``overlap``: Set the overlap between series in a Bar/Column chart. The
  range is +/- 100. The default is 0::

    chart.add_series({
        'categories': '=Sheet1!$A$1:$A$5',
        'values':     '=Sheet1!$B$1:$B$5',
        'overlap':    10,
    })

  Note, it is only necessary to apply the ``overlap`` property to one series
  in the chart.

* ``gap``: Set the gap between series in a Bar/Column chart. The range is 0
  to 500. The default is 150::

    chart.add_series({
        'categories': '=Sheet1!$A$1:$A$5',
        'values':     '=Sheet1!$B$1:$B$5',
        'gap':        200,
    })

  Note, it is only necessary to apply the ``gap`` property to one series in
  the chart.


More than one series can be added to a chart. In fact, some chart types such as
``stock`` require it. The series numbering and order in the Excel chart will
be the same as the order in which they are added in XlsxWriter.

It is also possible to specify non-contiguous ranges::

    chart.add_series({
        'categories': '=(Sheet1!$A$1:$A$9,Sheet1!$A$14:$A$25)',
        'values':     '=(Sheet1!$B$1:$B$9,Sheet1!$B$14:$B$25)',
    })


chart.set_x_axis()
------------------

.. py:function:: set_x_axis(options)

   Set the chart X axis options.

   :param dict options: A dictionary of axis options.

The ``set_x_axis()`` method is used to set properties of the X axis::

    chart.set_x_axis({
        'name': 'Earnings per Quarter',
        'name_font': {'size': 14, 'bold': True},
        'num_font':  {'italic': True },
    })

.. image:: _images/chart_x_axis.png
   :scale: 75 %

The options that can be set are::

    name
    name_layout
    name_font
    name_line
    name_fill
    name_pattern
    name_gradient
    line
    fill
    pattern
    gradient
    num_format
    num_font
    min
    max
    minor_unit
    major_unit
    interval_unit
    interval_tick
    crossing
    position_axis
    reverse
    log_base
    label_position
    label_align
    major_gridlines
    minor_gridlines
    visible
    date_axis
    text_axis
    minor_unit_type
    major_unit_type
    minor_tick_mark
    major_tick_mark
    display_units
    display_units_visible

These options are explained below. Some properties are only applicable to
**value**, **category** or **date** axes (this is noted in each case). See
:ref:`chart_val_cat_axes` for an explanation of Excel's distinction between
the axis types.

* ``name``: Set the name (also known as title or caption) for the axis. The
  name is displayed below the X axis. (Applicable to category, date and value
  axes.)::

    chart.set_x_axis({'name': 'Earnings per Quarter'})

  This property is optional. The default is to have no axis name.

  The name can also be a formula such as ``=Sheet1!$A$1`` or a list with a
  sheetname, row and column such as ``['Sheet1', 0, 0]``.

* ``name_font``: Set the font properties for the axis name. (Applicable to
  category, date and value axes.)::

    chart.set_x_axis({'name_font': {'bold': True, 'italic': True}})

  See the :ref:`chart_fonts` section for more details on font properties.

* ``name_line``: Set the properties of the axis title/name border type such as
  color and width. See :ref:`chart_formatting_line`.

* ``name_fill``: Set the solid fill properties of the axis title/name. See
  :ref:`chart_formatting_fill`.

* ``name_pattern``: Set the pattern fill properties of the axis title/name. See
  :ref:`chart_formatting_pattern`.

* ``name_gradient``: Set the gradient fill properties of the axis title/name. See
  :ref:`chart_formatting_gradient`.


* ``name_layout``: Set the ``(x, y)`` position of the axis caption in chart
  relative units. (Applicable to category, date and value axes.)::

    chart.set_x_axis({
        'name': 'X axis',
        'name_layout': {
            'x': 0.34,
            'y': 0.85,
        }
    })

  See the :ref:`chart_layout` section for more details.

* ``num_font``: Set the font properties for the axis numbers. (Applicable to
  category, date and value axes.)::

    chart.set_x_axis({'name_font': {'bold': True, 'italic': True}})

  See the :ref:`chart_fonts` section for more details on font properties.

* ``num_format``: Set the number format for the axis. (Applicable to
  category, date and value axes.)::

    chart.set_x_axis({'num_format': '#,##0.00'})
    chart.set_y_axis({'num_format': '0.00%'})

  The number format is similar to the Worksheet Cell Format ``num_format``
  apart from the fact that a format index cannot be used. An explicit format
  string must be used as shown above. See :func:`set_num_format()` for more
  information.

* ``line``: Set the properties of the axis line type such as color and
  width. See :ref:`chart_formatting_line`::

    chart.set_x_axis({'line': {'none': True}})

* ``fill``: Set the solid fill properties of the axis. See
  :ref:`chart_formatting_fill`.  Note, in Excel the axis fill is applied to
  the area of the numbers of the axis and not to the area of the axis bounding
  box. That background is set from the chartarea fill.

* ``pattern``: Set the pattern fill properties of the axis. See
  :ref:`chart_formatting_pattern`.

* ``gradient``: Set the gradient fill properties of the axis. See
  :ref:`chart_formatting_gradient`.

* ``min``: Set the minimum value for the axis range. (Applicable to value and
  date axes only.)::

    chart.set_x_axis({'min': 3, 'max': 6})

  .. image:: _images/chart_max_min.png
     :scale: 75 %

* ``max``: Set the maximum value for the axis range. (Applicable to value and
  date axes only.)

* ``minor_unit``: Set the increment of the minor units in the axis range.
  (Applicable to value and date axes only.)::

    chart.set_x_axis({'minor_unit': 0.4, 'major_unit': 2})

* ``major_unit``: Set the increment of the major units in the axis range.
  (Applicable to value and date axes only.)

* ``interval_unit``: Set the interval unit for a category axis. Should be an
  integer value. (Applicable to category axes only.)::

    chart.set_x_axis({'interval_unit': 5})

* ``interval_tick``: Set the tick interval for a category axis. Should be an
  integer value. (Applicable to category axes only.)::

    chart.set_x_axis({'interval_tick': 2})

* ``crossing``: Set the position where the y axis will cross the x axis.
  (Applicable to all axes.)

  The ``crossing`` value can be a numeric value or the strings ``'max'`` or
  ``'min'`` to set the crossing at the maximum/minimum axis::

    chart.set_x_axis({'crossing': 3})
    chart.set_y_axis({'crossing': 'max'})

  **For category axes the numeric value must be an integer** to represent the
  category number that the axis crosses at. For value and date axes it can
  have any value associated with the axis. See also :ref:`chart_val_cat_axes`.

  If crossing is omitted (the default) the crossing will be set automatically
  by Excel based on the chart data.

* ``position_axis``: Position the axis on or between the axis tick marks.
  (Applicable to category axes only.)

  There are two allowable values ``on_tick`` and ``between``::

    chart.set_x_axis({'position_axis': 'on_tick'})
    chart.set_x_axis({'position_axis': 'between'})

* ``reverse``: Reverse the order of the axis categories or values.
  (Applicable to category, date and value axes.)::

    chart.set_x_axis({'reverse': True})

  .. image:: _images/chart_reverse.png
     :scale: 75 %

* ``log_base``: Set the log base of the axis range. (Applicable to value axes
  only.)::

    chart.set_y_axis({'log_base': 10})

* ``label_position``: Set the "Axis labels" position for the axis. The
  following positions are available::

    next_to (the default)
    high
    low
    none

  For example::

    chart.set_x_axis({'label_position': 'high'})
    chart.set_y_axis({'label_position': 'low'})

* ``label_align``: Align the "Axis labels" the axis. (Applicable to category
  axes only.)

  The following Excel alignments are available::

    center (the default)
    right
    left

  For example::

    chart.set_x_axis({'label_align': 'left'})

* ``major_gridlines``: Configure the major gridlines for the axis. The
  available properties are::

    visible
    line

  For example::

    chart.set_x_axis({
        'major_gridlines': {
            'visible': True,
            'line': {'width': 1.25, 'dash_type': 'dash'}
        },
    })

  .. image:: _images/chart_gridlines.png
     :scale: 75 %

  The ``visible`` property is usually on for the X axis but it depends on the
  type of chart.

  The ``line`` property sets the gridline properties such as color and
  width. See :ref:`chart_formatting`.

* ``minor_gridlines``: This takes the same options as ``major_gridlines``
  above.

  The minor gridline ``visible`` property is off by default for all chart
  types.

* ``visible``: Configure the visibility of the axis::

    chart.set_y_axis({'visible': False})

  Axes are visible by default.

* ``date_axis``: This option is used to treat a category axis with date or
  time data as a Date Axis. (Applicable to date category axes only.)::

    chart.set_x_axis({'date_axis': True})

  This option also allows you to set ``max`` and ``min`` values for a
  category axis which isn't allowed by Excel for non-date category axes.

  See :ref:`date_category_axes` for more details.

* ``text_axis``: This option is used to treat a category axis explicitly
  as a Text Axis. (Applicable to category axes only.)::

    chart.set_x_axis({'text_axis': True})

* ``minor_unit_type``: For ``date_axis`` axes, see above, this option is used
  to set the type of the minor units. (Applicable to date category axes
  only.)::

    chart.set_x_axis({
        'date_axis': True,
        'minor_unit': 4,
        'minor_unit_type': 'months',
    })

* ``major_unit_type``: Same as ``minor_unit_type``, see above, but for major
  axes unit types.

* ``minor_tick_mark``: Set the axis minor tick mark type/position to one of
  the following values::

      none
      inside
      outside
      cross   (inside and outside)

  For example::

      chart.set_x_axis({'major_tick_mark': 'none',
                        'minor_tick_mark': 'inside'})

* ``major_tick_mark``: Same as ``minor_tick_mark``, see above, but for major
  axes ticks.

* ``display_units``: Set the display units for the axis. This can be useful if
  the axis numbers are very large but you don't want to represent them in
  scientific notation. The available display units are::

    hundreds
    thousands
    ten_thousands
    hundred_thousands
    millions
    ten_millions
    hundred_millions
    billions
    trillions

  Applicable to value axes only.::

    chart.set_x_axis({'display_units': 'thousands'})
    chart.set_y_axis({'display_units': 'millions'})

  .. image:: _images/chart_display_units.png
     :scale: 75 %


* ``display_units_visible``: Control the visibility of the display units
  turned on by the previous option. This option is on by default. (Applicable
  to value axes only.)::

    chart.set_x_axis({'display_units': 'hundreds',
                      'display_units_visible': False})


chart.set_y_axis()
------------------

.. py:function:: set_y_axis(options)

   Set the chart Y axis options.

   :param dict options: A dictionary of axis options.

The ``set_y_axis()`` method is used to set properties of the Y axis.

The properties that can be set are the same as for ``set_x_axis``, see above.


chart.set_x2_axis()
-------------------

.. py:function:: set_x2_axis(options)

   Set the chart secondary X axis options.

   :param dict options: A dictionary of axis options.

The ``set_x2_axis()`` method is used to set properties of the secondary X axis,
see :func:`chart_secondary_axes`.

The properties that can be set are the same as for ``set_x_axis``, see above.

The default properties for this axis are::

    'label_position': 'none',
    'crossing':       'max',
    'visible':        False,


chart.set_y2_axis()
-------------------

.. py:function:: set_y2_axis(options)

   Set the chart secondary Y axis options.

   :param dict options: A dictionary of axis options.

The ``set_y2_axis()`` method is used to set properties of the secondary Y axis,
see :func:`chart_secondary_axes`.

The properties that can be set are the same as for ``set_x_axis``, see above.

The default properties for this axis are::

    'major_gridlines': {'visible': True}


chart.combine()
---------------

.. py:function:: combine(chart)

   Combine two charts of different types.

   :param chart: A chart object created with :func:`add_chart()`.

The chart ``combine()`` method is used to combine two charts of different
types, for example a column and line chart::

    # Create a primary chart.
    column_chart = workbook.add_chart({'type': 'column'})
    column_chart.add_series({...})

    # Create a secondary chart.
    line_chart = workbook.add_chart({'type': 'line'})
    line_chart.add_series({...})

    # Combine the charts.
    column_chart.combine(line_chart)

.. image:: _images/chart_combined1.png
   :scale: 75 %


See the :ref:`chart_combined_charts` section for more details.


chart.set_size()
----------------

.. :noindex: py:function:: set_size(options)

   Set the size or scale of the chart.

   :param dict options: A dictionary of chart size options.

The ``set_size()`` method is used to set the dimensions of the chart. The size
properties that can be set are::

     width
     height
     x_scale
     y_scale
     x_offset
     y_offset

The ``width`` and ``height`` are in pixels. The default chart width x height is
480 x 288 pixels. The size of the chart can be modified by setting the
``width`` and ``height`` or by setting the ``x_scale`` and ``y_scale``::

    chart.set_size({'width': 720, 'height': 576})
    # Same as:
    chart.set_size({'x_scale': 1.5, 'y_scale': 2})

The ``x_offset`` and ``y_offset`` position the top left corner of the chart in
the cell that it is inserted into.

Note: the ``x_offset`` and ``y_offset`` parameters can also be set via the
:func:`insert_chart()` method::

    worksheet.insert_chart('E2', chart, {'x_offset': 25, 'y_offset': 10})


chart.set_title()
-----------------

.. py:function:: set_title(options)

   Set the chart title options.

   :param dict options: A dictionary of chart size options.

The ``set_title()`` method is used to set properties of the chart title::

    chart.set_title({'name': 'Year End Results'})

.. image:: _images/chart_title.png
   :scale: 75 %

The properties that can be set are:

* ``name``: Set the name (title) for the chart. The name is displayed above
  the chart. The name can also be a formula such as ``=Sheet1!$A$1`` or a list
  with a sheetname, row and column such as ``['Sheet1', 0, 0]``. The name
  property is optional. The default is to have no chart title.

* ``font``: Set the font properties for the chart title. See
  :ref:`chart_fonts`.

* ``border``: Set the border properties of the legend such as color and
  style. See :ref:`chart_formatting_border`.

* ``fill``: Set the solid fill properties of the legend such as color. See
  :ref:`chart_formatting_fill`.

* ``pattern``: Set the pattern fill properties of the legend. See
  :ref:`chart_formatting_pattern`.

* ``gradient``: Set the gradient fill properties of the legend. See
  :ref:`chart_formatting_gradient`.

* ``overlay``: Allow the title to be overlaid on the chart. Generally used
  with the layout property below.

* ``layout``: Set the ``(x, y)`` position of the title in chart relative
  units::

     chart.set_title({
         'name': 'Title',
         'overlay': True,
         'layout': {
             'x': 0.42,
             'y': 0.14,
         }
     })

  See the :ref:`chart_layout` section for more details.

* ``none``: By default Excel adds an automatic chart title to charts with a
  single series and a user defined series name. The ``none`` option turns this
  default title off. It also turns off all other ``set_title()`` options::

   chart.set_title({'none': True})

chart.set_legend()
------------------

.. py:function:: set_legend(options)

   Set the chart legend options.

   :param dict options: A dictionary of chart legend options.

The ``set_legend()`` method is used to set properties of the chart legend. For
example it can be used to turn off the default chart legend::

    chart.set_legend({'none': True})

.. image:: _images/chart_legend_none.png
   :scale: 75 %

The options that can be set are::

    none
    position
    font
    border
    fill
    pattern
    gradient
    delete_series
    layout

* ``none``: In Excel chart legends are on by default. The ``none`` option
  turns off the chart legend::

      chart.set_legend({'none': True})

  For backward compatibility, it is also possible to turn off the legend via
  the ``position`` property::

    chart.set_legend({'position': 'none'})

* ``position``: Set the position of the chart legend::

    chart.set_legend({'position': 'bottom'})

  .. image:: _images/chart_legend_bottom.png
     :scale: 75 %

  The default legend position is ``right``. The available positions are::

    top
    bottom
    left
    right
    overlay_left
    overlay_right
    none


* ``font``: Set the font properties of the chart legend::

    chart.set_legend({'font': {'size': 9, 'bold': True}})

  See the :ref:`chart_fonts` section for more details on font properties.

* ``border``: Set the border properties of the legend such as color and
  style. See :ref:`chart_formatting_border`.

* ``fill``: Set the solid fill properties of the legend such as color. See
  :ref:`chart_formatting_fill`.

* ``pattern``: Set the pattern fill properties of the legend. See
  :ref:`chart_formatting_pattern`.

* ``gradient``: Set the gradient fill properties of the legend. See
  :ref:`chart_formatting_gradient`.

* ``delete_series``: This allows you to remove one or more series from the
  legend (the series will still display on the chart). This property takes
  a list as an argument and the series are zero indexed::

    # Delete/hide series index 0 and 2 from the legend.
    chart.set_legend({'delete_series': [0, 2]})

  .. image:: _images/chart_legend_delete.png
     :scale: 75 %

* ``layout``: Set the ``(x, y)`` position of the legend in chart relative
  units::

     chart.set_legend({
         'layout': {
             'x':      0.80,
             'y':      0.37,
             'width':  0.12,
             'height': 0.25,
         }
     })

  See the :ref:`chart_layout` section for more details.


chart.set_chartarea()
---------------------

.. py:function:: set_chartarea(options)

   Set the chart area options.

   :param dict options: A dictionary of chart area options.

The ``set_chartarea()`` method is used to set the properties of the chart area.
In Excel the chart area is the background area behind the chart::

    chart.set_chartarea({
        'border': {'none': True},
        'fill':   {'color': 'red'}
    })

.. image:: _images/chart_chartarea.png
   :scale: 75 %

The properties that can be set are:

* ``border``: Set the border properties of the chartarea such as color and
  style. See :ref:`chart_formatting_border`.

* ``fill``: Set the solid fill properties of the chartarea such as color. See
  :ref:`chart_formatting_fill`.

* ``pattern``: Set the pattern fill properties of the chartarea. See
  :ref:`chart_formatting_pattern`.

* ``gradient``: Set the gradient fill properties of the chartarea. See
  :ref:`chart_formatting_gradient`.



chart.set_plotarea()
--------------------

.. py:function:: set_plotarea(options)

   Set the plot area options.

   :param dict options: A dictionary of plot area options.

The ``set_plotarea()`` method is used to set properties of the plot area of a
chart. In Excel the plot area is the area between the axes on which the chart
series are plotted::

    chart.set_plotarea({
        'border': {'color': 'red', 'width': 2, 'dash_type': 'dash'},
        'fill':   {'color': '#FFFFC2'}
    })

.. image:: _images/chart_plotarea.png
   :scale: 75 %

The properties that can be set are:

* ``border``: Set the border properties of the plotarea such as color and
  style. See :ref:`chart_formatting_border`.

* ``fill``: Set the solid fill properties of the plotarea such as color. See
  :ref:`chart_formatting_fill`.

* ``pattern``: Set the pattern fill properties of the plotarea. See
  :ref:`chart_formatting_pattern`.

* ``gradient``: Set the gradient fill properties of the plotarea. See
  :ref:`chart_formatting_gradient`.

* ``layout``: Set the ``(x, y)`` position of the plotarea in chart relative
  units::

     chart.set_plotarea({
         'layout': {
             'x':      0.13,
             'y':      0.26,
             'width':  0.73,
             'height': 0.57,
         }
     })

  See the :ref:`chart_layout` section for more details.


chart.set_style()
-----------------

.. py:function:: set_style(style_id)

   Set the chart style type.

   :param int style_id: An index representing the chart style.

The ``set_style()`` method is used to set the style of the chart to one of the
48 built-in styles available on the 'Design' tab in Excel::

    chart.set_style(37)

.. image:: _images/chart_style.png
   :scale: 75 %

The style index number is counted from 1 on the top left. The default style is
2.

.. Note::

   In Excel 2013 the Styles section of the 'Design' tab in Excel shows what
   were referred to as 'Layouts' in previous versions of Excel. These layouts
   are not defined in the file format. They are a collection of modifications
   to the base chart type. They can be replicated using the XlsxWriter Chart
   API but they cannot be defined by the ``set_style()`` method.


chart.set_table()
-----------------

.. py:function:: set_table(options)

   Set properties for an axis data table.

   :param dict options: A dictionary of axis table options.

The ``set_table()`` method adds a data table below the horizontal axis with the
data used to plot the chart::

    chart.set_table()

.. image:: _images/chart_table.png
   :scale: 75 %

The available options, with default values are::

    'horizontal': True   # Display vertical lines in the table.
    'vertical':   True   # Display horizontal lines in the table.
    'outline':    True   # Display an outline in the table.
    'show_keys':  False  # Show the legend keys with the table data.
    'font':       {}     # Standard chart font properties.

For example::

    chart.set_table({'show_keys': True})

The data table can only be shown with Bar, Column, Line, Area and stock
charts.  See the :ref:`chart_fonts` section for more details on font
properties.


chart.set_up_down_bars()
------------------------

.. py:function:: set_up_down_bars(options)

   Set properties for the chart up-down bars.

   :param dict options: A dictionary of options.

The ``set_up_down_bars()`` method adds Up-Down bars to Line charts to indicate
the difference between the first and last data series::

    chart.set_up_down_bars()

It is possible to format the up and down bars to add ``fill``, ``pattern`` or
``gradient`` and ``border`` properties if required. See
:ref:`chart_formatting`::

    chart.set_up_down_bars({
        'up': {
            'fill':   {'color': '#00B050'},
            'border': {'color': 'black'}
        },
        'down': {
            'fill':   {'color': 'red'},
            'border': {'color': 'black'},
        },
    })

.. image:: _images/chart_up_down_bars.png
   :scale: 75 %

Up-down bars can only be applied to Line charts and to Stock charts (by
default).


chart.set_drop_lines()
----------------------

.. py:function:: set_drop_lines(options)

   Set properties for the chart drop lines.

   :param dict options: A dictionary of options.

The ``set_drop_lines()`` method adds Drop Lines to charts to show the Category
value of points in the data::

    chart.set_drop_lines()

.. image:: _images/chart_drop_lines.png
   :scale: 75 %

It is possible to format the Drop Line ``line`` properties if required. See
:ref:`chart_formatting`::

    chart.set_drop_lines({'line': {'color': 'red',
                                   'dash_type': 'square_dot'}})

Drop Lines are only available in Line, Area and Stock charts.


chart.set_high_low_lines()
--------------------------

.. py:function:: set_high_low_lines(options)

   Set properties for the chart high-low lines.

   :param dict options: A dictionary of options.

The ``set_high_low_lines()`` method adds High-Low lines to charts to show the
maximum and minimum values of points in a Category::

    chart.set_high_low_lines()

.. image:: _images/chart_high_low_lines.png
   :scale: 75 %

It is possible to format the High-Low Line ``line`` properties if required. See
:ref:`chart_formatting`::

    chart.set_high_low_lines({
        'line': {
            'color': 'red',
            'dash_type': 'square_dot'
        }
    })

High-Low Lines are only available in Line and Stock charts.


chart.show_blanks_as()
----------------------

.. py:function:: show_blanks_as(option)

   Set the option for displaying blank/empty data cells in a chart.

   :param string option: A string representing the display option.

The ``show_blanks_as()`` method controls how blank/empty data is displayed in a
chart::

    chart.show_blanks_as('span')

The available options are::

    'gap'   # Blank data is shown as a gap. The default.
    'zero'  # Blank data is displayed as zero.
    'span'  # Blank data is connected with a line.


chart.show_na_as_empty_cell()
-----------------------------

.. py:function:: show_na_as_empty_cell()

   Display ``#N/A`` on charts as blank/empty cells.


Display ``#N/A`` values on a chart as blank/empty cells.::

    chart.show_na_as_empty_cell()


chart.show_hidden_data()
------------------------

.. py:function:: show_hidden_data()

   Display data on charts from hidden rows or columns.


Display data in hidden rows or columns on the chart::

    chart.show_hidden_data()


chart.set_rotation()
--------------------

.. py:function:: set_rotation(rotation)
   :noindex:

   Set the Pie/Doughnut chart rotation.

   :param int rotation: The angle of rotation.

The ``set_rotation()`` method is used to set the rotation of the first segment
of a Pie/Doughnut chart. This has the effect of rotating the entire chart::

    chart->set_rotation(90)

The angle of rotation must be in the range ``0 <= rotation <= 360``.

This option is only available for Pie/Doughnut charts.



chart.set_hole_size()
---------------------

.. py:function:: set_hole_size(size)

   Set the Doughnut chart hole size.

   :param int size: The hole size as a percentage.

The ``set_hole_size()`` method is used to set the hole size of a Doughnut
chart::

    chart->set_hole_size(33)

The value of the hole size must be in the range ``10 <= size <= 90``.

This option is only available for Doughnut charts.


See also :ref:`working_with_charts` and :ref:`chart_examples`.

================
File: dev/docs/source/chartsheet.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _chartsheet:

The Chartsheet Class
====================

In Excel a chartsheet is a worksheet that only contains a chart.

.. image:: _images/chartsheet.png

The **Chartsheet** class has some of the functionality of data
:ref:`Worksheets <Worksheet>` such as tab selection, headers, footers, margins
and print properties but its primary purpose is to display a single chart.
This makes it different from ordinary data worksheets which can have one or
more *embedded* charts.

Like a data worksheet a chartsheet object isn't instantiated directly. Instead
a new chartsheet is created by calling the :func:`add_chartsheet()` method
from a :ref:`Workbook <Workbook>` object::

    workbook   = xlsxwriter.Workbook('filename.xlsx')
    worksheet  = workbook.add_worksheet()  # Required for the chart data.
    chartsheet = workbook.add_chartsheet()
    #...
    workbook.close()


A chartsheet object functions as a worksheet and not as a chart. In order to
have it display data a :ref:`Chart <chart_class>` object must be created and
added to the chartsheet::

    chartsheet = workbook.add_chartsheet()
    chart      = workbook.add_chart({'type': 'bar'})

    # Configure the chart.

    chartsheet.set_chart(chart)

The data for the chartsheet chart must be contained on a separate worksheet.
That is why it is always created in conjunction with at least one data
worksheet, as shown above.


chartsheet.set_chart()
----------------------

.. py:function:: set_chart(chart)

   Add a chart to a chartsheet.

   :param chart:       A chart object.

The ``set_chart()`` method is used to insert a chart into a chartsheet. A chart
object is created via the Workbook :func:`add_chart()` method where the chart
type is specified::

    chart = workbook.add_chart({type, 'column'})

    chartsheet.set_chart(chart)

Only one chart can be added to an individual chartsheet.

See :ref:`chart_class`, :ref:`working_with_charts` and :ref:`chart_examples`.


Worksheet methods
-----------------

The following :ref:`Worksheet` methods are also available through a chartsheet:


* :func:`activate()`
* :func:`select()`
* :func:`hide()`
* :func:`set_first_sheet()`
* :func:`protect()`
* :func:`set_zoom()`
* :func:`set_zoom_to_fit()`
* :func:`set_tab_color()`
* :func:`set_landscape()`
* :func:`set_portrait()`
* :func:`set_paper()`
* :func:`set_margins()`
* :func:`set_header()`
* :func:`set_footer()`
* :func:`get_name()`


For example::

    chartsheet.set_tab_color('#FF9900')

The :func:`set_zoom_to_fit()` method only has an effect for chartsheets. It
ensures that a chartsheet is zoomed automatically by Excel to fit the screen
even when the window is resized.


Chartsheet Example
------------------

See :ref:`ex_chartsheet`.

================
File: dev/docs/source/color.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _color:

The Color Class
===============

The ``Color`` class is used to represent Excel color in the XlsxWriter
interface. It can be used to define RGB colors, Named colors and Theme colors::

    from xlsxwriter.color import Color

    # A Color instance using the HTML string constructor.
    color_format = workbook.add_format({"bg_color": Color("#FF7F50")})
    worksheet.write_string(0, 0, 'Color("#FF7F50")')
    worksheet.write_blank(0, 1, None, color_format)

    # A Color instance using a named color string constructor.
    color_format = workbook.add_format({"bg_color": Color("Green")})
    worksheet.write_string(2, 0, 'Color("Green")')
    worksheet.write_blank(2, 1, None, color_format)

    # A Color instance using the Theme tuple constructor.
    color_format = workbook.add_format({"bg_color": Color((7, 3))})
    worksheet.write_string(4, 0, "Color((7, 3))")
    worksheet.write_blank(4, 1, None, color_format)

.. image:: _images/doc_color_intro.png


See also :ref:`colors`.


Constructor
-----------

.. py:function:: Color(color)

   Create a new XlsxWriter Color object.

   :param str|int|tuple(int, int) color: The value of the color. A hex string,
    an integer, or a tuple of two integers.
   :type color: str|int|tuple(int, int)
   :return: A Color object representing the RGB color.
   :rtype: Color

The ``Color`` constructor can be used to create colors in three ways:

1. **String argument**

   A string to represent an RGB color in HTML format ``#RRGGBB``. The range is
   from ``#000000`` (black) to ``#FFFFFF`` (white). A limited number of named
   colors like ``Green``, ``Red``, and ``Blue`` are also supported. These are
   shortcuts for RGB colors. See :func:`rgb()` below for more details.

2. **Integer argument**

   An integer to represent an RGB color in the format
   ``0xRRGGBB``. As with the HTML variant, the range is from ``0x000000`` (black)
   to ``0xFFFFFF`` (white). See the :func:`rgb_integer()` below for more details.

3. **Tuple**

   Theme colors are defined by a tuple of two integers: the first is the theme
   color index (0-9) and the second is the theme shade index (0-5). See the
   :func:`theme()` below for more details.


color.rgb()
-----------

.. py:function:: rgb(color)

   Create a user-defined RGB color from a HTML color string.

   :param color: An RGB value in the range ``#000000`` (black) to ``#FFFFFF``
    (white).
   :type color: str
   :return: A Color object representing the RGB color.
   :rtype: Color

Create a user-defined RGB color from a HTML color string::

    from xlsxwriter.color import Color

    # Create a red color.
    red_color = Color.rgb("#FF0000")

This is an explicit method that is equivalent to the Constructor with a string
value.

XlsxWriter also supports a limited number of named colors. The named colors
are shortcuts for RGB colors::

    from xlsxwriter.color import Color

    # Create a green color.
    green_color = Color.rgb("Green")


The named colors are:

+------------+----------------+
| Color name | RGB color code |
+============+================+
| Black      | ``#000000``    |
+------------+----------------+
| Blue       | ``#0000FF``    |
+------------+----------------+
| Brown      | ``#800000``    |
+------------+----------------+
| Cyan       | ``#00FFFF``    |
+------------+----------------+
| Gray       | ``#808080``    |
+------------+----------------+
| Green      | ``#008000``    |
+------------+----------------+
| Lime       | ``#00FF00``    |
+------------+----------------+
| Magenta    | ``#FF00FF``    |
+------------+----------------+
| Navy       | ``#000080``    |
+------------+----------------+
| Orange     | ``#FF6600``    |
+------------+----------------+
| Pink       | ``#FF00FF``    |
+------------+----------------+
| Purple     | ``#800080``    |
+------------+----------------+
| Red        | ``#FF0000``    |
+------------+----------------+
| Silver     | ``#C0C0C0``    |
+------------+----------------+
| White      | ``#FFFFFF``    |
+------------+----------------+
| Yellow     | ``#FFFF00``    |
+------------+----------------+



color.rgb_integer()
-------------------

.. py:function:: rgb_integer(color)

   Create a user-defined RGB color from an integer.

   :param color: An RGB value in the range 0x000000 (black) to 0xFFFFFF (white).
   :type color: int
   :return: A Color object representing the RGB color.
   :rtype: Color

Create a user-defined RGB color from an integer value::

    from xlsxwriter.color import Color

    # Create a blue color.
    blue_color = Color.rgb(0x00FF00)

This is an explicit method that is equivalent to the Constructor with an integer
value.

color.theme()
-------------

.. py:function:: theme(color, shade)

   Create a theme color.

   :param color: The theme color index (0-9).
   :type color: int
   :param int shade: The theme shade index (0-5).
   :type shade: int
   :return: A Color object representing the theme color.
   :rtype: Color

This is an explicit method that is equivalent to the Constructor with a tuple
value. Theme colors represent the default Excel theme color palette:

.. image:: _images/theme_color_palette.png

The syntax for theme colors is ``(color, shade)`` where ``color`` is one of the
0-9 values on the top row and ``shade`` is the variant in the associated column
from 0-5. For example "White, background 1" in the top left is ``color.theme(0, 0)``
and "Orange, Accent 6, Darker 50%" in the bottom right is ``color.theme(9, 5)``.

================
File: dev/docs/source/contents.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

Contents
========

.. toctree::
   :maxdepth: 2

   introduction.rst
   getting_started.rst
   tutorial01.rst
   tutorial02.rst
   tutorial03.rst
   workbook.rst
   worksheet.rst
   page_setup.rst
   format.rst
   color.rst
   chart.rst
   chartsheet.rst
   exceptions.rst
   utility.rst
   working_with_cell_notation.rst
   working_with_data.rst
   working_with_formulas.rst
   working_with_dates_and_time.rst
   working_with_colors.rst
   working_with_charts.rst
   working_with_object_positioning.rst
   working_with_autofilters.rst
   working_with_data_validation.rst
   working_with_conditional_formats.rst
   working_with_tables.rst
   working_with_textboxes.rst
   working_with_sparklines.rst
   working_with_cell_comments.rst
   working_with_outlines.rst
   working_with_memory.rst
   working_with_macros.rst
   working_with_pandas.rst
   working_with_polars.rst
   examples.rst
   chart_examples.rst
   pandas_examples.rst
   polars_examples.rst
   alternatives.rst
   third_party.rst
   bugs.rst
   faq.rst
   changes.rst
   author.rst
   license.rst

================
File: dev/docs/source/example_array_formula.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_array_formula:

Example: Array formulas
=======================

This program is an example of writing array formulas with one or more return
values. See the :func:`write_array_formula` method for more details.

.. image:: _images/array_formula.png


.. literalinclude:: ../../../examples/array_formula.py

================
File: dev/docs/source/example_autofilter.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_autofilter:

Example: Applying Autofilters
=============================

This program is an example of using autofilters in a worksheet. See
:ref:`working_with_autofilters` for more details.

.. image:: _images/autofilter3.png

.. literalinclude:: ../../../examples/autofilter.py

================
File: dev/docs/source/example_autofit_manually.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_autofit_manually:

Example: Autofitting columns manually
=====================================

An example of simulating autofitting column widths using the
:func:`cell_autofit_width` utility function.

The following example demonstrates manually auto-fitting the the width of a
column in Excel based on the maximum string width. The worksheet :func:`autofit`
method will do this automatically but occasionally you may need to control the
maximum and minimum column widths yourself.

.. image:: _images/autofit_manually.png

.. literalinclude:: ../../../examples/autofit_manually.py

================
File: dev/docs/source/example_autofit.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_autofit:

Example: Autofitting columns
============================

An example of simulating autofitting column widths using the  :func:`autofit` method:

.. image:: _images/autofit.png

.. literalinclude:: ../../../examples/autofit.py

================
File: dev/docs/source/example_background.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_background:

Example: Setting the Worksheet Background
=========================================

This program is an example of setting a worksheet background image. See the
:func:`set_background` method for more details.

.. image:: _images/background01.png

.. literalinclude:: ../../../examples/background.py

================
File: dev/docs/source/example_chart_area.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_area:

Example: Area Chart
===================

Example of creating Excel Area charts.

Chart 1 in the following example is a default area chart:

.. image:: _images/chart_area1.png
   :scale: 75 %

Chart 2 is a stacked area chart:

.. image:: _images/chart_area2.png
   :scale: 75 %

Chart 3 is a percentage stacked area chart:

.. image:: _images/chart_area3.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_area.py

================
File: dev/docs/source/example_chart_bar.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_bar:

Example: Bar Chart
==================

Example of creating Excel Bar charts.

Chart 1 in the following example is a default bar chart:

.. image:: _images/chart_bar1.png
   :scale: 75 %

Chart 2 is a stacked bar chart:

.. image:: _images/chart_bar2.png
   :scale: 75 %

Chart 3 is a percentage stacked bar chart:

.. image:: _images/chart_bar3.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_bar.py

================
File: dev/docs/source/example_chart_clustered.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_clustered:

Example: Clustered Chart
========================

Example of creating a clustered Excel chart where there are two levels of
category on the X axis.

.. image:: _images/chart_clustered.png
   :scale: 75 %

The categories in clustered charts are 2D ranges, instead of the more normal
1D ranges. The series are shown as formula strings for clarity but you can also
use the a list syntax.

.. literalinclude:: ../../../examples/chart_clustered.py

================
File: dev/docs/source/example_chart_column.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_column:

Example: Column Chart
=====================

Example of creating Excel Column charts.

Chart 1 in the following example is a default column chart:

.. image:: _images/chart_column1.png
   :scale: 75 %

Chart 2 is a stacked column chart:

.. image:: _images/chart_column2.png
   :scale: 75 %

Chart 3 is a percentage stacked column chart:

.. image:: _images/chart_column3.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_column.py

================
File: dev/docs/source/example_chart_combined.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_combined:

Example: Combined Chart
=======================

Example of creating combined Excel charts with two chart types.

In the first example we create a combined column and line chart that share the
same X and Y axes.

.. image:: _images/chart_combined1.png
   :scale: 75 %

In the second example we create a similar combined column and line chart
except that the secondary chart has a secondary Y axis.

.. image:: _images/chart_combined2.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_combined.py

================
File: dev/docs/source/example_chart_data_labels.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_data_labels:

Example: Charts with Data Labels
================================

A demo of some of the Excel chart data labels options that are available via
an XlsxWriter chart. These include custom labels with user text or text taken
from cells in the worksheet. See also :ref:`chart_series_option_data_labels`
and :ref:`chart_series_option_custom_data_labels`.

Chart 1 in the following example is a chart with standard data labels:

.. image:: _images/chart_data_labels11.png
   :scale: 75 %

Chart 2 is a chart with Category and Value data labels:

.. image:: _images/chart_data_labels12.png
   :scale: 75 %

Chart 3 is a chart with data labels with a user defined font:

.. image:: _images/chart_data_labels13.png
   :scale: 75 %

Chart 4 is a chart with standard data labels and formatting:

.. image:: _images/chart_data_labels22.png
   :scale: 75 %

Chart 5 is a chart with custom string data labels:

.. image:: _images/chart_data_labels14.png
   :scale: 75 %

Chart 6 is a chart with custom data labels referenced from worksheet cells:

.. image:: _images/chart_data_labels15.png
   :scale: 75 %

Chart 7 is a chart with a mix of custom and default labels. The ``None`` items
will get the default value. We also set a font for the custom items as an
extra example:

.. image:: _images/chart_data_labels16.png
   :scale: 75 %

Chart 8 is a chart with some deleted custom labels and defaults (set with
``None`` values). This allows us to highlight certain values such as the
minimum and maximum:

.. image:: _images/chart_data_labels17.png
   :scale: 75 %

Chart 9 is a chart with custom string data labels and formatting:

.. image:: _images/chart_data_labels23.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_data_labels.py

================
File: dev/docs/source/example_chart_data_table.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_data_table:

Example: Charts with Data Tables
================================

Example of creating charts with data tables.

Chart 1 in the following example is a column chart with default data table:

.. image:: _images/chart_data_table1.png
   :scale: 75 %

Chart 2 is a column chart with default data table with legend keys:

.. image:: _images/chart_data_table2.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_data_table.py

================
File: dev/docs/source/example_chart_data_tools.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_data_tools:

Example: Charts with Data Tools
===============================

A demo of an various Excel chart data tools that are available via an
XlsxWriter chart. These include, Trendlines, Data Labels, Error Bars, Drop
Lines, High-Low Lines and Up-Down Bars.

Chart 1 in the following example is a chart with trendlines:

.. image:: _images/chart_data_tools1.png
   :scale: 75 %

Chart 2 is a chart with data labels and markers:

.. image:: _images/chart_data_tools2.png
   :scale: 75 %

Chart 3 is a chart with error bars:

.. image:: _images/chart_data_tools3.png
   :scale: 75 %

Chart 4 is a chart with up-down bars:

.. image:: _images/chart_data_tools4.png
   :scale: 75 %

Chart 5 is a chart with hi-low lines:

.. image:: _images/chart_data_tools5.png
   :scale: 75 %

Chart 6 is a chart with drop lines:

.. image:: _images/chart_data_tools6.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_data_tools.py

================
File: dev/docs/source/example_chart_date_axis.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_date_axis:

Example: Date Axis Chart
========================

Date Category Axes are a special case of Category axes in Excel which give them
some of the properties of Values axes.

For example, Excel doesn't normally allow minimum and maximum values to be set
for category axes. However, date axes are an exception.

.. image:: _images/chart_date_axis.png
   :scale: 75 %

In XlsxWriter Date Category Axes are set using the ``date_axis`` option in
:func:`set_x_axis` or :func:`set_y_axis`::

    chart.set_x_axis({'date_axis': True})

If used, the ``min`` and ``max`` values should be set as Excel times or dates.

.. literalinclude:: ../../../examples/chart_date_axis.py

================
File: dev/docs/source/example_chart_doughnut.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_doughnut:

Example: Doughnut Chart
=======================

Example of creating Excel Doughnut charts. Chart 1 in the following example is:

.. image:: _images/chart_doughnut1.png
   :scale: 75 %

Chart 4 shows how to set segment colors and other options.

It is possible to define chart colors for most types of XlsxWriter charts via
the :func:`add_series()` method. However, Pie/Doughnut charts are a special
case since each segment is represented as a point and as such it is necessary
to assign formatting to each point in the series.

.. image:: _images/chart_doughnut2.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_doughnut.py

================
File: dev/docs/source/example_chart_gauge.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_gauge:

Example: Gauge Chart
====================

A Gauge Chart isn't a native chart type in Excel. It is constructed by
combining a doughnut chart and a pie chart and by using some non-filled
elements. This example follows the following online example of how to create a
Gauge Chart in Excel: https://www.excel-easy.com/examples/gauge-chart.html


.. image:: _images/chart_gauge.png

.. literalinclude:: ../../../examples/chart_gauge.py

================
File: dev/docs/source/example_chart_gradient.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_gradient:

Example: Chart with Gradient Fills
==================================

Example of creating an Excel chart with gradient fills, in the columns and
in the plot area.

.. image:: _images/chart_gradient.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_gradient.py

================
File: dev/docs/source/example_chart_line.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_line:

Example: Line Chart
===================

Example of creating an Excel line charts. The X axis of a line chart is a
category axis with fixed point spacing. For a line chart with arbitrary point
spacing see the Scatter chart type.

Chart 1 in the following example is a default line chart:

.. image:: _images/chart_line1.png
   :scale: 75 %

Chart 2 is a stacked line chart:

.. image:: _images/chart_line2.png
   :scale: 75 %

Chart 3 is a percentage stacked line chart:

.. image:: _images/chart_line3.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_line.py

================
File: dev/docs/source/example_chart_pareto.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_pareto:

Example: Pareto Chart
=====================

Example of creating a Pareto chart with a secondary chart and axis.

.. image:: _images/chart_pareto.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_pareto.py

================
File: dev/docs/source/example_chart_pattern.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_pattern:

Example: Chart with Pattern Fills
=================================

Example of creating an Excel chart with pattern fills, in the columns.

.. image:: _images/chart_pattern.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_pattern.py

================
File: dev/docs/source/example_chart_pie.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_pie:

Example: Pie Chart
==================

Example of creating Excel Pie charts. Chart 1 in the following example is:

.. image:: _images/chart_pie1.png
   :scale: 75 %

Chart 2 shows how to set segment colors.

It is possible to define chart colors for most types of XlsxWriter charts via
the :func:`add_series()` method. However, Pie charts are a special case since
each segment is represented as a point and as such it is necessary to assign
formatting to each point in the series.

.. image:: _images/chart_pie2.png
   :scale: 75 %

Chart 3 shows how to rotate the segments of the chart:

.. image:: _images/chart_pie3.png
   :scale: 75 %


.. literalinclude:: ../../../examples/chart_pie.py

================
File: dev/docs/source/example_chart_radar.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_radar:

Example: Radar Chart
====================

Example of creating Excel Column charts.

Chart 1 in the following example is a default radar chart:

.. image:: _images/chart_radar1.png
   :scale: 75 %

Chart 2 in the following example is a radar chart with markers:

.. image:: _images/chart_radar2.png
   :scale: 75 %

Chart 3 in the following example is a filled radar chart:

.. image:: _images/chart_radar3.png
   :scale: 75 %


.. literalinclude:: ../../../examples/chart_radar.py

================
File: dev/docs/source/example_chart_scatter.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_scatter:

Example: Scatter Chart
======================

Example of creating Excel Scatter charts.

Chart 1 in the following example is a default scatter chart:

.. image:: _images/chart_scatter1.png
   :scale: 75 %

Chart 2 is a scatter chart with straight lines and markers:

.. image:: _images/chart_scatter2.png
   :scale: 75 %

Chart 3 is a scatter chart with straight lines and no markers:

.. image:: _images/chart_scatter3.png
   :scale: 75 %

Chart 4 is a scatter chart with smooth lines and markers:

.. image:: _images/chart_scatter4.png
   :scale: 75 %

Chart 5 is a scatter chart with smooth lines and no markers:

.. image:: _images/chart_scatter5.png
   :scale: 75 %


.. literalinclude:: ../../../examples/chart_scatter.py

================
File: dev/docs/source/example_chart_secondary_axis.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_secondary_axis:

Example: Secondary Axis Chart
=============================

Example of creating an Excel Line chart with a secondary axis. Note, the
primary and secondary chart type are the same. The next example shows a
secondary chart of a different type.

.. image:: _images/chart_secondary_axis1.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_secondary_axis.py

================
File: dev/docs/source/example_chart_simple.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_simple:

Example: Chart (Simple)
=======================

Example of a simple column chart with 3 data series:

.. image:: _images/chart_simple.png
   :scale: 75 %


See the :ref:`chart_class` and :ref:`working_with_charts` for more details.

.. literalinclude:: ../../../examples/chart.py

================
File: dev/docs/source/example_chart_stock.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_stock:

Example: Stock Chart
====================

Example of creating and Excel HiLow-Close Stock chart.

Chart 1 in the following example is:

.. image:: _images/chart_stock1.png
   :scale: 75 %

.. literalinclude:: ../../../examples/chart_stock.py

================
File: dev/docs/source/example_chart_styles.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chart_styles:

Example: Styles Chart
=====================

An example showing all 48 default chart styles available in Excel 2007 using
the chart :func:`set_style()` method.

.. image:: _images/chart_styles.png

Note, these styles are not the same as the styles available in Excel 2013.

.. literalinclude:: ../../../examples/chart_styles.py

================
File: dev/docs/source/example_chartsheet.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_chartsheet:

Example: Chartsheet
===================

Example of creating an Excel Bar chart on a :ref:`chartsheet <Chartsheet>`.

.. image:: _images/chartsheet.png

.. literalinclude:: ../../../examples/chartsheet.py

================
File: dev/docs/source/example_check_close.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_check_close:

Example: Catch exception on closing
===================================

A simple program demonstrating a check for exceptions when closing the file.

We try to :func:`close()` the file in a loop so that if there is an exception,
such as if the file is open or locked, we can ask the user to close the file,
after which we can try again to overwrite it.

.. literalinclude:: ../../../examples/check_close.py

================
File: dev/docs/source/example_checkbox.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_checkbox:

Example: Inserting a checkbox in a Worksheet
============================================

An example of adding checkbox boolean values to a worksheet.

.. image:: _images/checkbox.png

.. literalinclude:: ../../../examples/checkbox.py

================
File: dev/docs/source/example_comments1.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_comments1:

Example: Adding Cell Comments to Worksheets (Simple)
====================================================

A simple example of adding cell comments to a worksheet. For more details see
:ref:`cell_comments`.

.. image:: _images/comments1.png

.. literalinclude:: ../../../examples/comments1.py

================
File: dev/docs/source/example_comments2.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_comments2:

Example: Adding Cell Comments to Worksheets (Advanced)
======================================================

Another example of adding cell comments to a worksheet. This example
demonstrates most of the available comment formatting options. For more
details see :ref:`cell_comments`.

.. image:: _images/comments2.png

.. literalinclude:: ../../../examples/comments2.py

================
File: dev/docs/source/example_conditional_format.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_cond_format:

Example: Conditional Formatting
===============================

Example of how to add conditional formatting to an XlsxWriter file.
Conditional formatting allows you to apply a format to a cell or a
range of cells based on certain criteria.

.. image:: _images/conditional_format1.png

.. literalinclude:: ../../../examples/conditional_format.py

================
File: dev/docs/source/example_data_validate.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_data_valid:

Example: Data Validation and Drop Down Lists
============================================

Example of how to add data validation and drop down lists to an XlsxWriter
file. Data validation is a way of limiting user input to certain ranges
or to allow a selection from a drop down list.

.. image:: _images/data_validate1.png

.. literalinclude:: ../../../examples/data_validate.py

================
File: dev/docs/source/example_datetimes.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_datetimes:

Example: Dates and Times in Excel
=================================

This program is an example of writing some of the features of the
XlsxWriter module. See the :ref:`working_with_dates_and_time` section for
more details on this example.

.. image:: _images/working_with_dates_and_times02.png

.. literalinclude:: ../../../examples/datetimes.py

================
File: dev/docs/source/example_defined_name.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_defined_name:

Example: Defined names/Named ranges
===================================

Example of how to create defined names (named ranges) with XlsxWriter.

Defined names are used to define descriptive names to represent a value, a
single cell or a range of cells in a workbook or worksheet. See
:func:`define_name`.

.. image:: _images/defined_name.png

.. literalinclude:: ../../../examples/defined_name.py

================
File: dev/docs/source/example_demo.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_demo:

Example: Simple Feature Demonstration
=====================================

This program is an example of writing some of the features of the XlsxWriter
module.

.. image:: _images/demo.png

.. literalinclude:: ../../../examples/demo.py

Notes:

* This example includes the use of cell formatting via the :ref:`format`.
* Strings and numbers can be written with the same worksheet :func:`write`
  method.
* Data can be written to cells using Row-Column notation or 'A1' style
  notation, see :ref:`cell_notation`.

================
File: dev/docs/source/example_diagonal_border.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_diagonal_border:

Example: Diagonal borders in cells
==================================

Example of how to set diagonal borders in a cell.

.. image:: _images/diagonal_border.png


See :func:`set_diag_border`, :func:`set_diag_type` and :func:`set_diag_border`
for details.


.. literalinclude:: ../../../examples/diagonal_border.py

================
File: dev/docs/source/example_django_simple.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_django_simple:

Example: Simple Django class
============================

A simple Django View class to write an Excel file using the XlsxWriter module.

.. literalinclude:: ../../../examples/django_simple.py

================
File: dev/docs/source/example_doc_properties.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_doc_properties:

Example: Setting Document Properties
====================================

This program is an example setting document properties. See the
:func:`set_properties` workbook method for more details.

.. image:: _images/doc_properties.png

.. literalinclude:: ../../../examples/doc_properties.py

================
File: dev/docs/source/example_dynamic_arrays.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_dynamic_arrays:

Example: Dynamic array formulas
===============================

This program is an example of writing formulas that work with dynamic arrays
using some of the new functions and functionality introduced in Excel 365. See
the :func:`write_dynamic_array_formula` method and
:ref:`formula_dynamic_arrays` for more details.

.. image:: _images/dynamic_arrays01.png

.. literalinclude:: ../../../examples/dynamic_arrays.py

================
File: dev/docs/source/example_embedded_images.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_embedded_images:

Example: Embedding images into a worksheet
==========================================

This program is an example of embedding images into a worksheet. The image will
scale automatically to fit the cell.

This is the equivalent of Excel's menu option to insert an image using the
option to "Place in Cell" which is only available in Excel 365 versions from
2023 onwards. For older versions of Excel a ``#VALUE!`` error is displayed.

See the
:func:`embed_image` method for more details.

.. image:: _images/embedded_images.png

.. literalinclude:: ../../../examples/embedded_images.py

================
File: dev/docs/source/example_headers_footers.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_headers_footers:

Example: Adding Headers and Footers to Worksheets
=================================================

This program is an example of adding headers and footers to worksheets.
See the :func:`set_header` and :func:`set_footer` methods for more details.

.. image:: _images/header_image.png

.. literalinclude:: ../../../examples/headers_footers.py

================
File: dev/docs/source/example_hello_world.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_hello_world:

Example: Hello World
====================

The simplest possible spreadsheet. This is a good place to start to see if
the XlsxWriter module is installed correctly.

.. image:: _images/hello01.png

.. literalinclude:: ../../../examples/hello_world.py

================
File: dev/docs/source/example_hide_row_col.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_hide_row_col:

Example: Hiding Rows and Columns
================================

This program is an example of how to hide rows and columns in XlsxWriter.

An individual row can be hidden using the :func:`set_row` method::

    worksheet.set_row(0, None, None, {'hidden': True})

However, in order to hide a large number of rows, for example all the rows
after row 8, we need to use an Excel optimization to hide rows without setting
each one, (of approximately 1 million rows). To do this we use the
:func:`set_default_row` method.

Columns don't require this optimization and can be hidden using
:func:`set_column`.

.. image:: _images/hide_row_col.png

.. literalinclude:: ../../../examples/hide_row_col.py

================
File: dev/docs/source/example_hide_sheet.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_hide_sheet:

Example: Hiding Worksheets
==========================

This program is an example of how to hide a worksheet using the
:func:`hide` method.

.. image:: _images/hide_sheet.png

.. literalinclude:: ../../../examples/hide_sheet.py

================
File: dev/docs/source/example_http_server.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_http_server:

Example: Simple HTTP Server
===========================

Example of using Python and XlsxWriter to create an Excel XLSX file in an in
memory string suitable for serving via SimpleHTTPRequestHandler or Django or with the
Google App Engine.

Even though the final file will be in memory, via the BytesIO object, the
XlsxWriter module uses temp files during assembly for efficiency. To avoid
this on servers that don't allow temp files set the ``in_memory`` constructor
option to ``True``.

The Python 3 Runtime Environment in Google App Engine supports a
`filesystem with read/write access to /tmp <https://cloud.google.com/appengine/docs/standard/python3/runtime#filesystem>`_
which means that the ``in_memory`` option isn't required there.

.. literalinclude:: ../../../examples/http_server.py

================
File: dev/docs/source/example_hyperlink.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_hyperlink:

Example: Adding hyperlinks
==========================

This program is an example of writing hyperlinks to a worksheet. See the
:func:`write_url` method for more details.

.. image:: _images/hyperlink.png

.. literalinclude:: ../../../examples/hyperlink.py

================
File: dev/docs/source/example_ignore_errors.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_ignore_errors:

Example: Ignoring Worksheet errors and warnings
===============================================

An example of ignoring Excel worksheet errors/warnings using the worksheet
:func:`ignore_errors()` method.

.. image:: _images/ignore_errors2.png

.. literalinclude:: ../../../examples/ignore_errors.py

================
File: dev/docs/source/example_images_bytesio.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_images_bytesio:

Example: Inserting images from a URL or byte stream into a worksheet
====================================================================

This program is an example of inserting images from a Python
:class:`io.BytesIO` byte stream into a worksheet.

The example byte streams are populated from a URL and from a local file.

See the :func:`insert_image` method for more details.

.. image:: _images/images_bytesio.png

.. literalinclude:: ../../../examples/images_bytesio.py

================
File: dev/docs/source/example_images.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_insert_image:

Example: Inserting images into a worksheet
==========================================

This program is an example of inserting images into a worksheet. See the
:func:`insert_image` method for more details.

.. image:: _images/images.png

.. literalinclude:: ../../../examples/images.py

================
File: dev/docs/source/example_inheritance1.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_inheritance1:

Example: Example of subclassing the Workbook and Worksheet classes
==================================================================

Example of how to subclass the Workbook and Worksheet objects.

We also override the default ``worksheet.write()`` method to show how that is
done.

.. image:: _images/inheritance1.png

.. literalinclude:: ../../../examples/inheritance1.py

================
File: dev/docs/source/example_inheritance2.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_inheritance2:

Example: Advanced example of subclassing
========================================

Example of how to subclass the Workbook and Worksheet objects. See also the
simpler :ref:`inheritance1.py <ex_inheritance1>` example.

In this example we see an approach to implementing a simulated autofit in a
user application. This works by overriding the ``write_string()`` method to
track the maximum width string in each column and then set the column widths
when closing the workbook.

Some notes on this:

* **This isn't a fully functional autofit example** (as shown by the longer
  strings in the screen shot). It is only a proof or concept or a framework to
  try out solutions. See the the worksheet :func:`autofit` method instead.

* The hard part is coming up with an accurate (or mainly accurate)
  ``excel_string_width()`` function. One possibility is to use the PIL
  `ImageFont()
  <https://pillow.readthedocs.io/en/latest/reference/ImageFont.html>`_ method
  and convert the pixel width back to a character width.

* A more rigorous approach would have to consider font sizes, bold, italic,
  etc.
* The ``set_column()`` calls in ``close()`` will override any others set by the
  user. They also don't set any column formats.
* It doesn't work for horizontal merge ranges.
* There are probably some other corner cases hiding here.

.. image:: _images/inheritance2.png

.. literalinclude:: ../../../examples/inheritance2.py

================
File: dev/docs/source/example_lambda.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_lambda:

Example: Excel 365 LAMBDA() function
====================================

This program is an example of using the new Excel ``LAMBDA()`` function. It
demonstrates how to create a lambda function in Excel and also how to assign a
name to it so that it can be called as a user defined function. This
particular example converts from Fahrenheit to Celsius.

See the :ref:`formula_lambda` section of the documentation for more details.

.. image:: _images/lambda01.png

.. literalinclude:: ../../../examples/lambda.py

================
File: dev/docs/source/example_macros.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_macros:

Example: Adding a VBA macro to a Workbook
=========================================

This program is an example of how to add a button connected to a VBA macro to
a worksheet.

See :ref:`macros` for more details.


.. image:: _images/macros.png

.. literalinclude:: ../../../examples/macros.py

================
File: dev/docs/source/example_merge_rich.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_merge_rich:

Example: Merging Cells with a Rich String
=========================================

This program is an example of merging cells that contain a rich string.

Using the standard XlsxWriter API we can only write simple types to merged
ranges so we first write a blank string to the merged range. We then overwrite
the first merged cell with a rich string.

Note that we must also pass the cell format used in the merged cells format at
the end

See the :func:`merge_range` and :func:`write_rich_string` methods for more
details.

.. image:: _images/merge_rich.png

.. literalinclude:: ../../../examples/merge_rich_string.py

================
File: dev/docs/source/example_merge1.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_merge1:

Example: Merging Cells
======================

This program is an example of merging cells in a worksheet. See the
:func:`merge_range` method for more details.

.. image:: _images/merge1.png

.. literalinclude:: ../../../examples/merge1.py

================
File: dev/docs/source/example_outline1.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_outline1:

Example: Outline and Grouping
=============================

Examples of how use XlsxWriter to generate Excel outlines and grouping. See
also :ref:`outlines`.

.. image:: _images/outline1.png

.. literalinclude:: ../../../examples/outline.py

================
File: dev/docs/source/example_outline2.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_outline2:

Example: Collapsed Outline and Grouping
=======================================

Examples of how use XlsxWriter to generate Excel outlines and
grouping. These examples focus mainly on collapsed outlines. See also
:ref:`outlines`.

.. image:: _images/outline2.png

.. literalinclude:: ../../../examples/outline_collapsed.py

================
File: dev/docs/source/example_pandas_autofilter.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_autofilter:

Example: Pandas Excel output with an autofilter
===============================================

An example of converting a Pandas dataframe to an Excel file with a
autofilter, and filtered data, using Pandas and XlsxWriter. See
:ref:`working_with_autofilters` for a more detailed explanation of
autofilters.

.. image:: _images/pandas_autofilter.png

.. literalinclude:: ../../../examples/pandas_autofilter.py

================
File: dev/docs/source/example_pandas_chart_columns.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_chart_columns:

Example: Pandas Excel output with a column chart
================================================

An example of converting a Pandas dataframe to an Excel file with a column
chart using Pandas and XlsxWriter.

.. image:: _images/pandas_chart_columns.png
   :scale: 75 %

.. literalinclude:: ../../../examples/pandas_chart_columns.py

================
File: dev/docs/source/example_pandas_chart_line.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_chart_line:

Example: Pandas Excel output with a line chart
==============================================

A simple example of converting a Pandas dataframe to an Excel file with a
line chart using Pandas and XlsxWriter.

.. image:: _images/pandas_chart_line.png
   :scale: 75 %

.. literalinclude:: ../../../examples/pandas_chart_line.py

================
File: dev/docs/source/example_pandas_chart.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_chart:

Example: Pandas Excel output with a chart
=========================================

A simple example of converting a Pandas dataframe to an Excel file with a
chart using Pandas and XlsxWriter.

.. image:: _images/pandas_chart.png

.. literalinclude:: ../../../examples/pandas_chart.py

================
File: dev/docs/source/example_pandas_column_formats.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_column_formats:

Example: Pandas Excel output with column formatting
===================================================

An example of converting a Pandas dataframe to an Excel file with column
formats using Pandas and XlsxWriter.

It isn't possible to format any cells that already have a format such as
the index or headers or any cells that contain dates or datetimes.

Note: This feature requires Pandas >= 0.16.

.. image:: _images/pandas_column_formats.png

.. literalinclude:: ../../../examples/pandas_column_formats.py

================
File: dev/docs/source/example_pandas_conditional.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_conditional:

Example: Pandas Excel output with conditional formatting
========================================================

An example of converting a Pandas dataframe to an Excel file with a
conditional formatting using Pandas and XlsxWriter.

.. image:: _images/pandas_conditional.png

.. literalinclude:: ../../../examples/pandas_conditional_format.py

================
File: dev/docs/source/example_pandas_datetime.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_datetime:

Example: Pandas Excel output with datetimes
===========================================

An example of converting a Pandas dataframe with datetimes to an Excel file
with a default datetime and date format using Pandas and XlsxWriter.


.. image:: _images/pandas_datetime.png

.. literalinclude:: ../../../examples/pandas_datetime.py

================
File: dev/docs/source/example_pandas_header_format.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_header_format:

Example: Pandas Excel output with user defined header format
============================================================

An example of converting a Pandas dataframe to an Excel file with a user
defined header format using Pandas and XlsxWriter.

.. image:: _images/pandas_header_format.png

.. literalinclude:: ../../../examples/pandas_header_format.py

================
File: dev/docs/source/example_pandas_multiple.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_multiple:

Example: Pandas Excel with multiple dataframes
==============================================

An example of writing multiple dataframes to worksheets using Pandas and
XlsxWriter.

.. image:: _images/pandas_multiple.png

.. literalinclude:: ../../../examples/pandas_multiple.py

================
File: dev/docs/source/example_pandas_percentage.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_percentage:

Example: Pandas Excel output with percentage formatting
=======================================================

To create a percentage in Excel the data must be a number, must be divided by
100 and must have a percentage number format applied.

Here is a simple example of converting some string percentage data in a Pandas
dataframe to percentage numbers in an xlsx file using XlsxWriter as the Pandas
excel engine:

.. image:: _images/pandas_percentage.png

.. literalinclude:: ../../../examples/pandas_percentage.py

================
File: dev/docs/source/example_pandas_positioning.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_positioning:

Example: Pandas Excel dataframe positioning
===========================================

An example of positioning dataframes in a worksheet using Pandas and
XlsxWriter. It also demonstrates how to write a dataframe without the header
and index.

.. image:: _images/pandas_positioning.png

.. literalinclude:: ../../../examples/pandas_positioning.py

================
File: dev/docs/source/example_pandas_simple.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_simple:

Example: Pandas Excel example
=============================

A simple example of converting a Pandas dataframe to an Excel file using
Pandas and XlsxWriter. See :ref:`ewx_pandas` for more details.

.. image:: _images/pandas_simple.png

.. literalinclude:: ../../../examples/pandas_simple.py

================
File: dev/docs/source/example_pandas_table.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_pandas_table:

Example: Pandas Excel output with a worksheet table
===================================================

An example of inserting a Pandas dataframe into an Excel worksheet table file
using Pandas and XlsxWriter.

.. image:: _images/pandas_table.png

.. literalinclude:: ../../../examples/pandas_table.py

================
File: dev/docs/source/example_panes.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_panes:

Example: Freeze Panes and Split Panes
=====================================

An example of how to create panes in a worksheet, both "freeze" panes and
"split" panes. See the :func:`freeze_panes` and :func:`split_panes` methods
for more details.

.. image:: _images/panes.png

.. literalinclude:: ../../../examples/panes.py

================
File: dev/docs/source/example_polars_chart.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_chart:

Example: Polars Excel output with a chart
=========================================

An example of adding a Polars dataframe to a worksheet created by XlsxWriter and
then adding a chart of the data. See :ref:`ewx_polars` for more details.

.. image:: _images/polars_chart.png

.. literalinclude:: ../../../examples/polars_chart.py

================
File: dev/docs/source/example_polars_checkbox.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_checkbox:

Example: Polars Excel output with a boolean checkboxes
======================================================

A example of displaying the boolean values in a Polars dataframe as checkboxes
in an output xlsx file.

.. image:: _images/polars_checkbox.png

.. literalinclude:: ../../../examples/polars_checkbox.py

================
File: dev/docs/source/example_polars_conditional.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_conditional:

Example: Polars Excel output with conditional formatting
========================================================

An example of adding a dataframe with conditional formatting to a worksheet
using Polars and XlsxWriter. See :ref:`ewx_polars` for more details.

.. image:: _images/polars_conditional.png

.. literalinclude:: ../../../examples/polars_conditional_format.py

================
File: dev/docs/source/example_polars_format_custom.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_format_custom:

Example: Polars custom format example
=====================================

A simple example of converting a Polars dataframe to an xlsx file with
custom formatting of the worksheet table. See :ref:`ewx_polars` for more details.

.. image:: _images/polars_format_custom.png

.. literalinclude:: ../../../examples/polars_format_custom.py

================
File: dev/docs/source/example_polars_format_default.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_format_default:

Example: Polars default format example
======================================

A simple example of converting a Polars dataframe to an xlsx file with
default formatting. See :ref:`ewx_polars` for more details.

.. image:: _images/polars_format_default.png

.. literalinclude:: ../../../examples/polars_format_default.py

================
File: dev/docs/source/example_polars_multiple.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_multiple:

Example: Polars Excel with multiple dataframes
==============================================

An example of writing multiple dataframes to worksheets using Polars and
XlsxWriter. See :ref:`ewx_polars` for more details.

.. image:: _images/polars_multiple.png

.. literalinclude:: ../../../examples/polars_multiple.py

================
File: dev/docs/source/example_polars_positioning.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_positioning:

Example: Polars Excel dataframe positioning
===========================================

An example of positioning dataframes in a worksheet using Polars and XlsxWriter.
It also demonstrates how to write a dataframe without a header. See
:ref:`ewx_polars` for more details.

.. image:: _images/polars_positioning.png

.. literalinclude:: ../../../examples/polars_positioning.py

================
File: dev/docs/source/example_polars_simple.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_simple:

Example: Polars Excel getting started example
=============================================

A simple getting started example of converting a Polars dataframe to an Excel
file using Polars and XlsxWriter. See :ref:`ewx_polars` for more details.

.. image:: _images/polars_simple.png

.. literalinclude:: ../../../examples/polars_simple.py

================
File: dev/docs/source/example_polars_sparklines.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_sparklines:

Example: Polars Excel output with sparklines
============================================

An example of adding a sparklines to the output of a Polars dataframe. See
:ref:`ewx_polars` for more details.

.. image:: _images/polars_sparklines.png

.. literalinclude:: ../../../examples/polars_sparklines.py

================
File: dev/docs/source/example_polars_xlsxwriter.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_polars_xlsxwriter:

Example: Polars integration with XlsxWriter
===========================================

An example of adding a Polars dataframe to a worksheet created by XlsxWriter.
See :ref:`ewx_polars` for more details.

.. image:: _images/polars_xlsxwriter2.png

.. literalinclude:: ../../../examples/polars_xlsxwriter.py

================
File: dev/docs/source/example_protection.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_protection:

Example: Enabling Cell protection in Worksheets
===============================================

This program is an example cell locking and formula hiding in an Excel
worksheet using the :func:`protect` worksheet method and the Format
:func:`set_locked` property.

Note, that Excel's behavior is that all cells are locked once you set the
default protection. Therefore you need to explicitly unlock cells rather than
explicitly lock them.

.. image:: _images/worksheet_protection.png

.. literalinclude:: ../../../examples/worksheet_protection.py

================
File: dev/docs/source/example_rich_strings.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_rich_strings:

Example: Writing "Rich" strings with multiple formats
=====================================================

This program is an example of writing rich strings with multiple format to a
cell in a worksheet. See the :func:`write_rich_string` method for more details.

.. image:: _images/rich_strings.png

.. literalinclude:: ../../../examples/rich_strings.py

================
File: dev/docs/source/example_right_to_left.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_right_to_left:

Example: Left to Right worksheets and text
==========================================

Example of how to use Python and the XlsxWriter module to change the default
worksheet and cell text direction from left-to-right to right-to-left as
required by some middle eastern versions of Excel.

.. image:: _images/right_to_left.png

.. only:: html

   .. literalinclude:: ../../../examples/right_to_left.py

================
File: dev/docs/source/example_sensitivity_label.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_sensitivity_label:

Example: Setting the Sensitivity Label for a Document
=====================================================

This program is an example of adding a Sensitivity Label to an XlsxWriter file. See the
:func:`set_custom_property` workbook method for more details.

Sensitivity Labels are a property that can be added to an Office 365 document to
indicate that it is compliant with a company's information protection policies.
Sensitivity Labels have designations like "Confidential", "Internal use only",
or "Public" depending on the policies implemented by the company. They are
generally only enabled for enterprise versions of Office.

See the following Microsoft documentation on how to `Apply sensitivity labels to
your files and email
<https://support.microsoft.com/en-us/office/apply-sensitivity-labels-to-your-files-and-email-2f96e7cd-d5a4-403b-8bd7-4cc636bae0f9>`_.

Sensitivity Labels are generally stored as custom document properties so they
can be enabled using ``set_custom_property()``. However, since the metadata
differs from company to company you will need to extract some of the required
metadata from sample files.

The first step is to create a new file in Excel and set a non-encrypted
sensitivity label. Then unzip the file by changing the extension from `.xlsx` to
`.zip` or by using a command line utility like this:

.. code-block:: bash

  $ unzip myfile.xlsx -d myfile
  Archive:  myfile.xlsx
    inflating: myfile/[Content_Types].xml
    inflating: myfile/docProps/app.xml
    inflating: myfile/docProps/custom.xml
    inflating: myfile/docProps/core.xml
    inflating: myfile/_rels/.rels
    inflating: myfile/xl/workbook.xml
    inflating: myfile/xl/worksheets/sheet1.xml
    inflating: myfile/xl/styles.xml
    inflating: myfile/xl/theme/theme1.xml
    inflating: myfile/xl/_rels/workbook.xml.rels


Then examine the ``docProps/custom.xml`` file from the unzipped xlsx file. The
file doesn't contain newlines so it is best to view it in an editor that can
handle XML or use a commandline utility like libxmlâ€™s `xmllint`_ to format the
XML for clarity:

.. _xmllint: https://gnome.pages.gitlab.gnome.org/libxml2/xmllint.html

.. code-block:: xml

  $ xmllint --format myfile/docProps/custom.xml
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <Properties
      xmlns="http://schemas.openxmlformats.org/officeDocument/2006/custom-properties"
      xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="2"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_Enabled">
      <vt:lpwstr>true</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="3"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_SetDate">
      <vt:lpwstr>2024-01-01T12:00:00Z</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="4"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_Method">
      <vt:lpwstr>Privileged</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="5"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_Name">
      <vt:lpwstr>Confidential</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="6"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_SiteId">
      <vt:lpwstr>cb46c030-1825-4e81-a295-151c039dbf02</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="7"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_ActionId">
      <vt:lpwstr>88124cf5-1340-457d-90e1-0000a9427c99</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="8"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_ContentBits">
      <vt:lpwstr>2</vt:lpwstr>
    </property>
  </Properties>

The MSIP (Microsoft Information Protection) labels in the ``name`` attributes
contain a GUID that is unique to each company. The "SiteId" field will also be
unique to your company/location. The meaning of each of these fields is
explained in the the following Microsoft document on `Microsoft Information
Protection SDK - Metadata
<https://learn.microsoft.com/en-us/information-protection/develop/concept-mip-metadata>`_.

Once you have identified the necessary metadata you can add it to a new document
as shown below.

Note, some sensitivity labels require that the document is encrypted. In order
to extract the required metadata you will need to unencrypt the file which may
remove the sensitivity label. In that case you may need to use a third party
tool such as `msoffice-crypt`_.

.. _msoffice-crypt: https://github.com/herumi/msoffice



.. literalinclude:: ../../../examples/sensitivity_label.py

================
File: dev/docs/source/example_sparklines1.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_sparklines1:

Example: Sparklines (Simple)
============================

Example of how to add sparklines to a XlsxWriter worksheet.

Sparklines are small charts that fit in a single cell and are used to show
trends in data.

See the :ref:`sparklines` method for more details.

.. image:: _images/sparklines1.png

.. literalinclude:: ../../../examples/sparklines1.py

================
File: dev/docs/source/example_sparklines2.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_sparklines2:

Example: Sparklines (Advanced)
==============================

This example shows the majority of options that can be applied to sparklines.

Sparklines are small charts that fit in a single cell and are used to show
trends in data.

See the :ref:`sparklines` method for more details.

.. image:: _images/sparklines2.png

.. literalinclude:: ../../../examples/sparklines2.py

================
File: dev/docs/source/example_tab_colors.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_tab_colors:

Example: Setting Worksheet Tab Colors
=====================================

This program is an example of setting worksheet tab colors. See the
:func:`set_tab_color` method for more details.

.. image:: _images/tab_colors.png

.. literalinclude:: ../../../examples/tab_colors.py

================
File: dev/docs/source/example_tables.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_tables:

Example: Worksheet Tables
=========================

Example of how to add tables to an XlsxWriter worksheet.

Tables in Excel are used to group rows and columns of data into a single
structure that can be referenced in a formula or formatted collectively.

See also :ref:`tables`.

.. image:: _images/tables12.png

.. literalinclude:: ../../../examples/tables.py

================
File: dev/docs/source/example_textbox.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_textbox:

Example: Insert Textboxes into a Worksheet
==========================================

The following is an example of how to insert and format textboxes in a
worksheet, see :func:`insert_textbox()` and :ref:`working_with_textboxes` for
more details.

.. image:: _images/textbox01.png

.. literalinclude:: ../../../examples/textbox.py

================
File: dev/docs/source/example_unicode_polish_utf8.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_unicode_polish_utf8:

Example: Unicode - Polish in UTF-8
==================================

This program is an example of reading in data from a UTF-8 encoded text file
and converting it to a worksheet.

The main trick is to ensure that the data read in is converted to UTF-8
within the Python program. The XlsxWriter module will then take care of
writing the encoding to the Excel file.

.. image:: _images/unicode_polish_utf8.png

.. literalinclude:: ../../../examples/unicode_polish_utf8.py

================
File: dev/docs/source/example_unicode_shift_jis.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_unicode_shift_jis:

Example: Unicode - Shift JIS
============================

This program is an example of reading in data from a Shift JIS encoded text
file and converting it to a worksheet.

The main trick is to ensure that the data read in is converted to UTF-8
within the Python program. The XlsxWriter module will then take care of
writing the encoding to the Excel file.

The encoding of the input data shouldn't matter once it can be converted
to UTF-8 via the :mod:`codecs` module.

.. image:: _images/unicode_shift_jis.png

.. literalinclude:: ../../../examples/unicode_shift_jis.py

================
File: dev/docs/source/example_unicode.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_unicode:

Example: Simple Unicode with Python 3
=====================================

To write Unicode text in UTF-8 to a xlsxwriter file in Python 3 you just need
to encode the file as UTF-8.

.. image:: _images/unicode_python3.png

.. only:: html

   .. literalinclude:: ../../../examples/unicode.py

================
File: dev/docs/source/example_user_types1.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_user_type1:

Example: Writing User Defined Types (1)
=======================================

An example of adding support for user defined types to the XlsxWriter
:func:`write()` method using the :func:`add_write_handler` method.

This example takes UUID data and writes it as a string by adding a callback
handler to the ``write()`` method. A UUID data type would normally raise a
``TypeError`` in XlsxWriter since it isn't a type that is supported by Excel.

See the :ref:`writing_user_types` section for more details on how this
functionality works.

.. image:: _images/user_types1.png

.. literalinclude:: ../../../examples/user_types1.py

================
File: dev/docs/source/example_user_types2.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_user_type2:

Example: Writing User Defined Types (2)
=======================================

An example of adding support for user defined types to the XlsxWriter
:func:`write()` method using the :func:`add_write_handler` method.

This example removes ``NaN`` (Not a Number) values from numeric data and
writes a blank cell instead. Note, another way to handle this is with the
``nan_inf_to_errors`` option in the :func:`Workbook` constructor.

See the :ref:`writing_user_types` section for more details on how this
functionality works.


.. image:: _images/user_types2.png

.. literalinclude:: ../../../examples/user_types2.py

================
File: dev/docs/source/example_user_types3.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_user_type3:

Example: Writing User Defined types (3)
=======================================

An example of adding support for user defined types to the XlsxWriter
:func:`write()` method using the :func:`add_write_handler` method.

This, somewhat artificial, example shows how to use the ``row`` and ``col``
parameters to control the logic of the callback function. It changes the
worksheet ``write()`` method so that it hides/replaces user passwords when
writing string values based on their position in the worksheet.

See the :ref:`writing_user_types` section for more details on how this
functionality works.

.. image:: _images/user_types3.png

.. literalinclude:: ../../../examples/user_types3.py

================
File: dev/docs/source/example_watermark.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ex_watermark:

Example: Setting a Worksheet Watermark
=========================================

This program is an example of adding a worksheet watermark image using the
method recommended in the Microsoft documentation: `Add a watermark in Excel
<https://support.microsoft.com/en-us/office/add-a-watermark-in-excel-a372182a-d733-484e-825c-18ddf3edf009>`_.

.. image:: _images/worksheet_watermark.png

.. literalinclude:: ../../../examples/watermark.py

================
File: dev/docs/source/examples.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _main_examples:

Examples
========

The following are some of the examples included in the
`examples <https://github.com/jmcnamara/XlsxWriter/tree/main/examples>`_
directory of the XlsxWriter distribution.

.. toctree::
   :maxdepth: 1

   example_hello_world.rst
   example_demo.rst
   example_check_close.rst
   example_datetimes.rst
   example_hyperlink.rst
   example_array_formula.rst
   example_dynamic_arrays.rst
   example_autofilter.rst
   example_data_validate.rst
   example_conditional_format.rst
   example_defined_name.rst
   example_merge1.rst
   example_autofit.rst
   example_autofit_manually.rst
   example_rich_strings.rst
   example_merge_rich.rst
   example_images.rst
   example_images_bytesio.rst
   example_embedded_images.rst
   example_right_to_left.rst
   example_django_simple.rst
   example_http_server.rst
   example_headers_footers.rst
   example_panes.rst
   example_tables.rst
   example_checkbox.rst
   example_user_types1.rst
   example_user_types2.rst
   example_user_types3.rst
   example_ignore_errors.rst
   example_sparklines1.rst
   example_sparklines2.rst
   example_comments1.rst
   example_comments2.rst
   example_textbox.rst
   example_outline1.rst
   example_outline2.rst
   example_doc_properties.rst
   example_sensitivity_label.rst
   example_unicode.rst
   example_unicode_polish_utf8.rst
   example_unicode_shift_jis.rst
   example_watermark.rst
   example_background.rst
   example_tab_colors.rst
   example_diagonal_border.rst
   example_protection.rst
   example_hide_sheet.rst
   example_hide_row_col.rst
   example_inheritance1.rst
   example_inheritance2.rst
   example_macros.rst
   example_lambda.rst

================
File: dev/docs/source/exceptions.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _exceptions:

The Exceptions Class
====================

The Exception class contains the various exceptions that can be raised by
XlsxWriter. In general XlsxWriter only raised exceptions for un-recoverable
errors or for errors that would lead to file corruption such as creating two
worksheets with the same name.

The hierarchy of exceptions in XlsxWriter is:

* ``XlsxWriterException(Exception)``

  * ``XlsxFileError(XlsxWriterException)``

    * ``FileCreateError(XlsxFileError)``

    * ``UndefinedImageSize(XlsxFileError)``

    * ``UndefinedImageSize(XlsxFileError)``

    * ``FileSizeError(XlsxFileError)``

  * ``XlsxInputError(XlsxWriterException)``

    * ``DuplicateTableName(XlsxInputError)``

    * ``InvalidWorksheetName(XlsxInputError)``

    * ``DuplicateWorksheetName(XlsxInputError)``

    * ``OverlappingRange(XlsxInputError)``

    * ``ThemeFileError(XlsxInputError)``


Exception: XlsxWriterException
------------------------------

.. py:exception:: XlsxWriterException


Base exception for XlsxWriter.


Exception: XlsxFileError
------------------------

.. py:exception:: XlsxFileError


Base exception for all file related errors.


Exception: XlsxInputError
-------------------------

.. py:exception:: XlsxInputError


Base exception for all input data related errors.


Exception: FileCreateError
--------------------------

.. py:exception:: FileCreateError

This exception is raised if there is a file permission, or IO error, when
writing the xlsx file to disk. This can be caused by an non-existent directory
or (in Windows) if the file is already open in Excel::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    worksheet = workbook.add_worksheet()

    # The file exception.xlsx is already open in Excel.
    workbook.close()

Raises::

    xlsxwriter.exceptions.FileCreateError:
        [Errno 13] Permission denied: 'exception.xlsx'

This exception can be caught in a ``try`` block where you can instruct the
user to close the open file before overwriting it::

    while True:
        try:
            workbook.close()
        except xlsxwriter.exceptions.FileCreateError as e:
            decision = input("Exception caught in workbook.close(): %s\n"
                             "Please close the file if it is open in Excel.\n"
                             "Try to write file again? [Y/n]: " % e)
            if decision != 'n':
                continue

        break

See also :ref:`ex_check_close`.


Exception: UndefinedImageSize
-----------------------------

.. py:exception:: UndefinedImageSize

This exception is raised if an image added via :func:`insert_image()` doesn't
contain height or width information. The exception is raised during Workbook
:func:`close()`::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    worksheet = workbook.add_worksheet()

    worksheet.insert_image('A1', 'logo.png')

    workbook.close()

Raises::

    xlsxwriter.exceptions.UndefinedImageSize:
         logo.png: no size data found in image file.

.. note::

   This is a relatively rare error that is most commonly caused by XlsxWriter
   failing to parse the dimensions of the image rather than the image not
   containing the information. In these cases you should raise a GitHub issue
   with the image attached, or provided via a link.


Exception: UnsupportedImageFormat
---------------------------------

.. py:exception:: UnsupportedImageFormat

This exception is raised if if an image added via :func:`insert_image()` isn't
one of the supported file formats: PNG, JPEG, GIF, BMP, WMF or EMF. The exception
is raised during Workbook :func:`close()`::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    worksheet = workbook.add_worksheet()

    worksheet.insert_image('A1', 'logo.xyz')

    workbook.close()

Raises::

    xlsxwriter.exceptions.UnsupportedImageFormat:
        logo.xyz: Unknown or unsupported image file format.

.. note::

   If the image type is one of the supported types, and you are sure that the
   file format is correct, then the exception may be caused by XlsxWriter
   failing to parse the type of the image correctly. In these cases you should
   raise a GitHub issue with the image attached, or provided via a link.


Exception: FileSizeError
------------------------

.. py:exception:: FileSizeError

This exception is raised if one of the XML files that is part of the xlsx file, or the xlsx file itself, exceeds 4GB in size::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    worksheet = workbook.add_worksheet()

    # Write lots of data to create a very big file.

    workbook.close()

Raises::

    xlsxwriter.exceptions.FileSizeError:
        Filesize would require ZIP64 extensions. Use workbook.use_zip64().

As noted in the exception message, files larger than 4GB can be created by
turning on the zipfile.py ZIP64 extensions using the :func:`use_zip64` method.



Exception: EmptyChartSeries
---------------------------

.. py:exception:: EmptyChartSeries

This exception is raised if a chart is added to a worksheet without a data
series. The exception is raised during Workbook :func:`close()`::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')
    worksheet = workbook.add_worksheet()

    chart = workbook.add_chart({'type': 'column'})

    worksheet.insert_chart('A7', chart)

    workbook.close()

Raises::

    xlsxwriter.exceptions.EmptyChartSeries:
        Chart1 must contain at least one data series. See chart.add_series().


Exception: DuplicateTableName
-----------------------------

.. py:exception:: DuplicateTableName

This exception is raised if a duplicate worksheet table name in used via
:func:`add_table()`. The exception is raised during Workbook :func:`close()`::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')
    worksheet = workbook.add_worksheet()

    worksheet.add_table('B1:F3', {'name': 'SalesData'})
    worksheet.add_table('B4:F7', {'name': 'SalesData'})

    workbook.close()

Raises::

    xlsxwriter.exceptions.DuplicateTableName:
        Duplicate name 'SalesData' used in worksheet.add_table().


Exception: InvalidWorksheetName
-------------------------------

.. py:exception:: InvalidWorksheetName

This exception is raised during Workbook :func:`add_worksheet()` if a
worksheet name is too long or contains restricted characters.

For example with a 32 character worksheet name::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    name = 'name_that_is_longer_than_thirty_one_characters'
    worksheet = workbook.add_worksheet(name)

    workbook.close()

Raises::

    xlsxwriter.exceptions.InvalidWorksheetName:
        Excel worksheet name 'name_that_is_longer_than_thirty_one_characters'
        must be <= 31 chars.

Or for a worksheet name containing one of the Excel restricted characters,
i.e. ``[ ] : * ? / \``::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    worksheet = workbook.add_worksheet('Data[Jan]')

    workbook.close()

Raises::

    xlsxwriter.exceptions.InvalidWorksheetName:
        Invalid Excel character '[]:*?/\' in sheetname 'Data[Jan]'.

Or for a worksheet name start or ends with an apostrophe::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    worksheet = workbook.add_worksheet("'Sheet1'")

    workbook.close()

Raises::

    xlsxwriter.exceptions.InvalidWorksheetName:
        Sheet name cannot start or end with an apostrophe "'Sheet1'".


Exception: DuplicateWorksheetName
---------------------------------

.. py:exception:: DuplicateWorksheetName

This exception is raised during Workbook :func:`add_worksheet()` if a
worksheet name has already been used. As with Excel the check is case
insensitive::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    worksheet1 = workbook.add_worksheet('Sheet1')
    worksheet2 = workbook.add_worksheet('sheet1')

    workbook.close()

Raises::

    xlsxwriter.exceptions.DuplicateWorksheetName:
        Sheetname 'sheet1', with case ignored, is already in use.


Exception: OverlappingRange
---------------------------------

.. py:exception:: OverlappingRange

This exception is raised during Worksheet :func:`add_table()` or
:func:`merge_range()` if the range overlaps an existing worksheet table or merge
range. This is a file corruption error in Excel::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    worksheet = workbook.add_worksheet()

    worksheet.merge_range('A1:G10', 'Range 1')
    worksheet.merge_range('G10:K20', 'Range 2')

    workbook.close()

Raises::

    xlsxwriter.exceptions.OverlappingRange:
        Merge range 'G10:K20' overlaps previous merge range 'A1:G10'.

Exception: ThemeFileError
-------------------------

.. py:exception:: ThemeFileError

This exception is raised during Workbook :func:`use_custom_theme()` if the theme
file is invalid or contains unsupported elements such as image fills::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('exception.xlsx')

    workbook.use_custom_theme("theme.xml")

    worksheet = workbook.add_worksheet()

    workbook.close()

Raises::

    xlsxwriter.exceptions.ThemeFileError:
        Invalid XML theme file: 'theme.xml'.

================
File: dev/docs/source/faq.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _faq:

Frequently Asked Questions
==========================

The section outlines some answers to frequently asked questions.

.. _faq_rewrite:

Q. Can XlsxWriter use an existing Excel file as a template?
-----------------------------------------------------------

No.

XlsxWriter is designed only as a file *writer*. It cannot read or modify an
existing Excel file.

.. _faq_zero_result:

Q. Why do my formulas show a zero result in some, non-Excel applications?
-------------------------------------------------------------------------

Due to a wide range of possible formulas and the interdependencies between
them XlsxWriter doesn't, and realistically cannot, calculate the result of a
formula when it is written to an XLSX file. Instead, it stores the value 0 as
the formula result. It then sets a global flag in the XLSX file to say that
all formulas and functions should be recalculated when the file is opened.

This is the method recommended in the Excel documentation and in general it
works fine with spreadsheet applications. However, applications that don't
have a facility to calculate formulas, such as Excel Viewer, or several mobile
applications, will only display the 0 results.

If required, it is also possible to specify the calculated result of the
formula using the optional ``value`` parameter in :func:`write_formula()`::

    worksheet.write_formula('A1', '=2+2', None, 4)

See also :ref:`formula_result`.

Note: **LibreOffice** doesn't recalculate Excel formulas that reference other
cells by default, in which case you will get the default XlsxWriter value
of 0. You can work around this by setting the "LibreOffice Preferences ->
LibreOffice Calc -> Formula -> Recalculation on File Load" option to "Always
recalculate" (see the LibreOffice `documentation
<https://help.libreoffice.org/6.4/en-US/text/scalc/01/06080000.html>`_). Or,
you can set a blank result in the formula, which will also force
recalculation::

    worksheet.write_formula('A1', '=Sheet1!$A$1', None, '')

.. _faq_ampersand:

Q. Why do my formulas have a @ in them?
---------------------------------------

Microsoft refers to the ``@`` in formulas as the `Implicit Intersection
Operator
<https://support.microsoft.com/en-us/office/implicit-intersection-operator-ce3be07b-0101-4450-a24e-c1c999be2b34?ui=en-us&rs=en-us&ad=us>`_.
It indicates that an input range is being reduced from multiple values to a
single value. In some cases it is just a warning indicator and doesn't affect
the calculation or result. However, in practical terms it generally means that
your formula should be written as an array formula using either
:func:`write_array_formula` or :func:`write_dynamic_array_formula`.

For more details see the :ref:`formula_dynamic_arrays` and
:ref:`formula_intersection_operator` sections of the XlsxWriter documentation.

.. _faq_format_range:

Q. Can I apply a format to a range of cells in one go?
------------------------------------------------------

Currently no. However, it is a planned features to allow cell formats and data
to be written separately.

.. _faq_future:

Q. Is feature X supported or will it be supported?
--------------------------------------------------

All supported features are documented. Future features are on the `Roadmap
<https://github.com/jmcnamara/XlsxWriter/issues/653>`_.

.. _faq_protect_workbook:

Q. Can I password protect an XlsxWriter xlsx file
-------------------------------------------------

Although it is possible to password protect a worksheet using the Worksheet
:func:`protect` method it isn't possible to password protect the entire
workbook/file using XlsxWriter.

The reason for this is that a protected/encrypted xlsx file is in a different
format from an ordinary xlsx file. This would require a lot of additional work,
and testing, and isn't something that is on the XlsxWriter roadmap.

However, it is possible to password protect an XlsxWriter generated file using
a third party open source tool called `msoffice-crypt
<https://github.com/herumi/msoffice>`_. This works for macOS, Linux and Windows::

    msoffice-crypt.exe -e -p password clear.xlsx encrypted.xlsx

.. _faq_faq:

Q. Do people actually ask these questions frequently, or at all?
----------------------------------------------------------------

Apart from this question, yes.

================
File: dev/docs/source/format.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _format:

The Format Class
================

This section describes the methods and properties that are available for
formatting cells in Excel.

The properties of a cell that can be formatted include: fonts, colors,
patterns, borders, alignment and number formatting.

.. image:: _images/formats_intro.png

Creating and using a Format object
----------------------------------

Cell formatting is defined through a Format object. Format objects are created
by calling the workbook :func:`add_format` method as follows::

    cell_format1 = workbook.add_format()       # Set properties later.
    cell_format2 = workbook.add_format(props)  # Set properties at creation.

There are two ways of setting Format properties: by using the object interface
or by setting the property as a dictionary of key/value pairs in the
constructor. For example, a typical use of the object interface would be as
follows::

    cell_format = workbook.add_format()
    cell_format.set_bold()
    cell_format.set_font_color('red')

By comparison the properties can be set by passing a dictionary of properties
to the :func:`add_format` constructor::

    cell_format = workbook.add_format({'bold': True, 'font_color': 'red'})

In general the key/value interface is more flexible and clearer than the
object method and is the recommended method for setting format
properties. However, both methods produce the same result.

Once a Format object has been constructed and its properties have been set it
can be passed as an argument to the worksheet :func:`write` methods as
follows::

    worksheet.write       (0, 0, 'Foo', cell_format)
    worksheet.write_string(1, 0, 'Bar', cell_format)
    worksheet.write_number(2, 0, 3,     cell_format)
    worksheet.write_blank (3, 0, '',    cell_format)

Formats can also be passed to the worksheet :func:`set_row` and
:func:`set_column` methods to define the default formatting properties for a
row or column::

    worksheet.set_row(0, 18, cell_format)
    worksheet.set_column('A:D', 20, cell_format)

Format Defaults
---------------

The default Excel 2007+ cell format is Calibri 11 with all other properties off.

In general a format method call without an argument will turn a property on,
for example::

    cell_format = workbook.add_format()

    cell_format.set_bold()      # Turns bold on.
    cell_format.set_bold(True)  # Also turns bold on.


Since most properties are already off by default it isn't generally required to
turn them off. However, it is possible if required::

    cell_format.set_bold(False)  # Turns bold off.


Modifying Formats
-----------------

Each unique cell format in an XlsxWriter spreadsheet must have a corresponding
Format object. It isn't possible to use a Format with a :func:`write` method
and then redefine it for use at a later stage. This is because a Format is
applied to a cell not in its current state but in its final state. Consider
the following example::

    cell_format = workbook.add_format({'bold': True, 'font_color': 'red'})
    worksheet.write('A1', 'Cell A1', cell_format)

    # Later...
    cell_format.set_font_color('green')
    worksheet.write('B1', 'Cell B1', cell_format)

Cell A1 is assigned a format which initially has the font set to the color
red. However, the color is subsequently set to green. When Excel displays
Cell A1 it will display the final state of the Format which in this case will
be the color green.


.. _num_format_categories:

Number Format Categories
------------------------

The :func:`set_num_format` method, shown below, is used to set the number
format for numbers::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('currency_format.xlsx')
    worksheet = workbook.add_worksheet()

    currency_format = workbook.add_format({'num_format': '$#,##0.00'})
    worksheet.write('A1', 1234.56, currency_format)

    workbook.close()

If the number format you use is the same as one of Excel's built in number
formats then it will have a number category such as General, Number, Currency,
Accounting, Date, Time, Percentage, Fraction, Scientific, Text, Special or
Custom. In the case of the example above the formatted output shows up as a
Number category:

.. image:: _images/currency_format1.png

If we wanted it to have a different category, such as Currency, then
we would have to match the number format string with the number format used by
Excel. The easiest way to do this is to open the Number Formatting dialog in
Excel and set the format that you want:

.. image:: _images/currency_format2.png

Then, while still in the dialog, change to Custom. The format displayed is the
format used by Excel.

.. image:: _images/currency_format3.png

If we put the format that we found (``'[$$-409]#,##0.00'``) into our previous
example and rerun it we will get a number format in the Currency category::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('currency_format.xlsx')
    worksheet = workbook.add_worksheet()

    currency_format = workbook.add_format({'num_format': '[$$-409]#,##0.00'})
    worksheet.write('A1', 1234.56, currency_format)

    workbook.close()

Here is the output:

.. image:: _images/currency_format4.png

The same process can be used to find format strings for Date or Accountancy
formats. However, you also need to be aware of the OS settings Excel uses for
number separators such as the "grouping/thousands" separator and the "decimal"
point. See the next section for details.


.. _num_format_locale:

Number Formats in different locales
-----------------------------------

As shown in the previous section the :func:`set_num_format` method is used to
set the number format for Xlsxwriter formats. A common use case is to set a
number format with a "grouping/thousands" separator and a "decimal" point::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('number_format.xlsx')
    worksheet = workbook.add_worksheet()

    number_format = workbook.add_format({'num_format': '#,##0.00'})
    worksheet.write('A1', 1234.56, number_format)

    workbook.close()

In the US locale (and some others) where the number "grouping/thousands"
separator is "," and the "decimal" point is "." this would be shown in Excel
as:

.. image:: _images/currency_format5.png

In other locales these values may be reversed or different. They are generally
set in the "Region" settings of Windows or Mac OS.  Excel handles this by
storing the number format in the file format in the US locale, in this case
``#,##0.00``, but renders it according to the regional settings of the host
OS. For example, here is the same, unmodified, output file shown above in a
German locale:

.. image:: _images/currency_format6.png

And here is the same file in a Russian locale. Note the use of a space as the
"grouping/thousands" separator:

.. image:: _images/currency_format7.png

In order to replicate Excel's behavior all XlsxWriter programs should use US
locale formatting which will then be rendered in the settings of your host OS.


Format methods and Format properties
------------------------------------

The following table shows the Excel format categories, the formatting
properties that can be applied and the equivalent object method:

+------------+------------------+----------------------+------------------------------+
| Category   | Description      | Property             | Method Name                  |
+============+==================+======================+==============================+
| Font       | Font type        | ``'font_name'``      | :func:`set_font_name()`      |
+------------+------------------+----------------------+------------------------------+
|            | Font size        | ``'font_size'``      | :func:`set_font_size()`      |
+------------+------------------+----------------------+------------------------------+
|            | Font color       | ``'font_color'``     | :func:`set_font_color()`     |
+------------+------------------+----------------------+------------------------------+
|            | Bold             | ``'bold'``           | :func:`set_bold()`           |
+------------+------------------+----------------------+------------------------------+
|            | Italic           | ``'italic'``         | :func:`set_italic()`         |
+------------+------------------+----------------------+------------------------------+
|            | Underline        | ``'underline'``      | :func:`set_underline()`      |
+------------+------------------+----------------------+------------------------------+
|            | Strikeout        | ``'font_strikeout'`` | :func:`set_font_strikeout()` |
+------------+------------------+----------------------+------------------------------+
|            | Super/Subscript  | ``'font_script'``    | :func:`set_font_script()`    |
+------------+------------------+----------------------+------------------------------+
| Number     | Numeric format   | ``'num_format'``     | :func:`set_num_format()`     |
+------------+------------------+----------------------+------------------------------+
| Protection | Lock cells       | ``'locked'``         | :func:`set_locked()`         |
+------------+------------------+----------------------+------------------------------+
|            | Hide formulas    | ``'hidden'``         | :func:`set_hidden()`         |
+------------+------------------+----------------------+------------------------------+
| Alignment  | Horizontal align | ``'align'``          | :func:`set_align()`          |
+------------+------------------+----------------------+------------------------------+
|            | Vertical align   | ``'valign'``         | :func:`set_align()`          |
+------------+------------------+----------------------+------------------------------+
|            | Rotation         | ``'rotation'``       | :func:`set_rotation()`       |
+------------+------------------+----------------------+------------------------------+
|            | Text wrap        | ``'text_wrap'``      | :func:`set_text_wrap()`      |
+------------+------------------+----------------------+------------------------------+
|            | Reading order    | ``'reading_order'``  | :func:`set_reading_order()`  |
+------------+------------------+----------------------+------------------------------+
|            | Justify last     | ``'text_justlast'``  | :func:`set_text_justlast()`  |
+------------+------------------+----------------------+------------------------------+
|            | Center across    | ``'center_across'``  | :func:`set_center_across()`  |
+------------+------------------+----------------------+------------------------------+
|            | Indentation      | ``'indent'``         | :func:`set_indent()`         |
+------------+------------------+----------------------+------------------------------+
|            | Shrink to fit    | ``'shrink'``         | :func:`set_shrink()`         |
+------------+------------------+----------------------+------------------------------+
| Pattern    | Cell pattern     | ``'pattern'``        | :func:`set_pattern()`        |
+------------+------------------+----------------------+------------------------------+
|            | Background color | ``'bg_color'``       | :func:`set_bg_color()`       |
+------------+------------------+----------------------+------------------------------+
|            | Foreground color | ``'fg_color'``       | :func:`set_fg_color()`       |
+------------+------------------+----------------------+------------------------------+
| Border     | Cell border      | ``'border'``         | :func:`set_border()`         |
+------------+------------------+----------------------+------------------------------+
|            | Bottom border    | ``'bottom'``         | :func:`set_bottom()`         |
+------------+------------------+----------------------+------------------------------+
|            | Top border       | ``'top'``            | :func:`set_top()`            |
+------------+------------------+----------------------+------------------------------+
|            | Left border      | ``'left'``           | :func:`set_left()`           |
+------------+------------------+----------------------+------------------------------+
|            | Right border     | ``'right'``          | :func:`set_right()`          |
+------------+------------------+----------------------+------------------------------+
|            | Border color     | ``'border_color'``   | :func:`set_border_color()`   |
+------------+------------------+----------------------+------------------------------+
|            | Bottom color     | ``'bottom_color'``   | :func:`set_bottom_color()`   |
+------------+------------------+----------------------+------------------------------+
|            | Top color        | ``'top_color'``      | :func:`set_top_color()`      |
+------------+------------------+----------------------+------------------------------+
|            | Left color       | ``'left_color'``     | :func:`set_left_color()`     |
+------------+------------------+----------------------+------------------------------+
|            | Right color      | ``'right_color'``    | :func:`set_right_color()`    |
+------------+------------------+----------------------+------------------------------+
| Other      | Cell border      | ``'quote_prefix'``   | :func:`set_quote_prefix()`   |
+------------+------------------+----------------------+------------------------------+
|            | Checkbox format  | ``'checkbox'``       | :func:`set_checkbox()`       |
+------------+------------------+----------------------+------------------------------+


The format properties and methods are explained in the following sections.


format.set_font_name()
----------------------

.. py:function:: set_font_name(fontname)

   Set the font used in the cell.

   :param string fontname: Cell font.

Specify the font used used in the cell format::

    cell_format.set_font_name('Times New Roman')

.. image:: _images/format_font_name.png

Excel can only display fonts that are installed on the system that it is
running on. Therefore it is best to use the fonts that come as standard such
as 'Calibri', 'Times New Roman' and 'Courier New'.

The default font for an unformatted cell in Excel 2007+ is 'Calibri'.


format.set_font_size()
----------------------

.. py:function:: set_font_size(size)

   Set the size of the font used in the cell.

   :param int size: The cell font size.

Set the font size of the cell format::

    cell_format = workbook.add_format()
    cell_format.set_font_size(30)

.. image:: _images/format_font_size.png

Excel adjusts the height of a row to accommodate the largest font size in the
row. You can also explicitly specify the height of a row using the
:func:`set_row` worksheet method.


format.set_font_color()
-----------------------

.. py:function:: set_font_color(color)

   Set the color of the font used in the cell.

   :param color: The cell font color.
   :type color: string|Color


Set the font color::

    cell_format = workbook.add_format()

    cell_format.set_font_color('red')

    worksheet.write(0, 0, 'Wheelbarrow', cell_format)

.. image:: _images/format_font_color.png

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.

Note: The :func:`set_font_color` method is used to set the color of the font
in a cell. To set the color of a cell use the :func:`set_bg_color` and
:func:`set_pattern` methods.


format.set_bold()
-----------------

.. py:function:: set_bold()

   Turn on bold for the format font.

Set the bold property of the font::

    cell_format.set_bold()

.. image:: _images/format_font_bold.png


format.set_italic()
-------------------

.. py:function:: set_italic()

   Turn on italic for the format font.

Set the italic property of the font::

    cell_format.set_italic()

.. image:: _images/format_font_italic.png


format.set_underline()
----------------------

.. py:function:: set_underline()

   Turn on underline for the format.

   :param int style: Underline style.

Set the underline property of the format::

    cell_format.set_underline()

.. image:: _images/format_font_underlined.png

The available underline styles are:

* 1 = Single underline (the default)
* 2 = Double underline
* 33 = Single accounting underline
* 34 = Double accounting underline


format.set_font_strikeout()
---------------------------

.. py:function:: set_font_strikeout()

   Set the strikeout property of the font.

.. image:: _images/format_font_strikeout.png


format.set_font_script()
------------------------

.. py:function:: set_font_script()

   Set the superscript/subscript property of the font.

The available options are:

* 1 = Superscript
* 2 = Subscript

.. image:: _images/format_font_script.png


This property is generally only useful when used in conjunction with
:func:`write_rich_string`.


format.set_num_format()
-----------------------

.. py:function:: set_num_format(format_string)

   Set the number format for a cell.

   :param string format_string: The cell number format.

This method is used to define the numerical format of a number in Excel. It
controls whether a number is displayed as an integer, a floating point number,
a date, a currency value or some other user defined format.

The numerical format of a cell can be specified by using a format string or an
index to one of Excel's built-in formats::

    cell_format1 = workbook.add_format()
    cell_format2 = workbook.add_format()

    cell_format1.set_num_format('d mmm yyyy')  # Format string.
    cell_format2.set_num_format(0x0F)          # Format index.

Format strings can control any aspect of number formatting allowed by Excel::

    cell_format01.set_num_format('0.000')
    worksheet.write(1, 0, 3.1415926, cell_format01)       # -> 3.142

    cell_format02.set_num_format('#,##0')
    worksheet.write(2, 0, 1234.56, cell_format02)         # -> 1,235

    cell_format03.set_num_format('#,##0.00')
    worksheet.write(3, 0, 1234.56, cell_format03)         # -> 1,234.56

    cell_format04.set_num_format('0.00')
    worksheet.write(4, 0, 49.99, cell_format04)           # -> 49.99

    cell_format05.set_num_format('mm/dd/yy')
    worksheet.write(5, 0, 36892.521, cell_format05)       # -> 01/01/01

    cell_format06.set_num_format('mmm d yyyy')
    worksheet.write(6, 0, 36892.521, cell_format06)       # -> Jan 1 2001

    cell_format07.set_num_format('d mmmm yyyy')
    worksheet.write(7, 0, 36892.521, cell_format07)       # -> 1 January 2001

    cell_format08.set_num_format('dd/mm/yyyy hh:mm AM/PM')
    worksheet.write(8, 0, 36892.521, cell_format08)       # -> 01/01/2001 12:30 PM

    cell_format09.set_num_format('0 "dollar and" .00 "cents"')
    worksheet.write(9, 0, 1.87, cell_format09)            # -> 1 dollar and .87 cents

    # Conditional numerical formatting.
    cell_format10.set_num_format('[Green]General;[Red]-General;General')
    worksheet.write(10, 0, 123, cell_format10)  # > 0 Green
    worksheet.write(11, 0, -45, cell_format10)  # < 0 Red
    worksheet.write(12, 0,   0, cell_format10)  # = 0 Default color

    # Zip code.
    cell_format11.set_num_format('00000')
    worksheet.write(13, 0, 1209, cell_format11)

.. image:: _images/formats_num_str.png

The number system used for dates is described in
:ref:`working_with_dates_and_time`.

The color format should have one of the following values::

    [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]

For more information refer to the `Microsoft documentation on cell formats
<https://support.microsoft.com/en-us/office/create-a-custom-number-format-78f2a361-936b-4c03-8772-09fab54be7f4?ui=en-us&rs=en-us&ad=us>`_.

For information on how to get a number format to show up as one of the number
format categories such as Currency, Accounting, Date, Time, Percentage,
Fraction, Scientific or Text, see :ref:`num_format_categories`, above.

For backwards compatibility XlsxWriter also supports Excel's built-in formats
which are set via an index number, rather than a string::

    cell_format.set_num_format(3)  # Same as #,##0

The format indexes and the equivalent strings are shown in the following
table:

+-------+--------------------------------------------------------+
| Index | Format String                                          |
+=======+========================================================+
| 0     | ``General``                                            |
+-------+--------------------------------------------------------+
| 1     | ``0``                                                  |
+-------+--------------------------------------------------------+
| 2     | ``0.00``                                               |
+-------+--------------------------------------------------------+
| 3     | ``#,##0``                                              |
+-------+--------------------------------------------------------+
| 4     | ``#,##0.00``                                           |
+-------+--------------------------------------------------------+
| 5     | ``($#,##0_);($#,##0)``                                 |
+-------+--------------------------------------------------------+
| 6     | ``($#,##0_);[Red]($#,##0)``                            |
+-------+--------------------------------------------------------+
| 7     | ``($#,##0.00_);($#,##0.00)``                           |
+-------+--------------------------------------------------------+
| 8     | ``($#,##0.00_);[Red]($#,##0.00)``                      |
+-------+--------------------------------------------------------+
| 9     | ``0%``                                                 |
+-------+--------------------------------------------------------+
| 10    | ``0.00%``                                              |
+-------+--------------------------------------------------------+
| 11    | ``0.00E+00``                                           |
+-------+--------------------------------------------------------+
| 12    | ``# ?/?``                                              |
+-------+--------------------------------------------------------+
| 13    | ``# ??/??``                                            |
+-------+--------------------------------------------------------+
| 14    | ``m/d/yy``                                             |
+-------+--------------------------------------------------------+
| 15    | ``d-mmm-yy``                                           |
+-------+--------------------------------------------------------+
| 16    | ``d-mmm``                                              |
+-------+--------------------------------------------------------+
| 17    | ``mmm-yy``                                             |
+-------+--------------------------------------------------------+
| 18    | ``h:mm AM/PM``                                         |
+-------+--------------------------------------------------------+
| 19    | ``h:mm:ss AM/PM``                                      |
+-------+--------------------------------------------------------+
| 20    | ``h:mm``                                               |
+-------+--------------------------------------------------------+
| 21    | ``h:mm:ss``                                            |
+-------+--------------------------------------------------------+
| 22    | ``m/d/yy h:mm``                                        |
+-------+--------------------------------------------------------+
| ...   | ...                                                    |
+-------+--------------------------------------------------------+
| 37    | ``(#,##0_);(#,##0)``                                   |
+-------+--------------------------------------------------------+
| 38    | ``(#,##0_);[Red](#,##0)``                              |
+-------+--------------------------------------------------------+
| 39    | ``(#,##0.00_);(#,##0.00)``                             |
+-------+--------------------------------------------------------+
| 40    | ``(#,##0.00_);[Red](#,##0.00)``                        |
+-------+--------------------------------------------------------+
| 41    | ``_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)``            |
+-------+--------------------------------------------------------+
| 42    | ``_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)``         |
+-------+--------------------------------------------------------+
| 43    | ``_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)``    |
+-------+--------------------------------------------------------+
| 44    | ``_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)`` |
+-------+--------------------------------------------------------+
| 45    | ``mm:ss``                                              |
+-------+--------------------------------------------------------+
| 46    | ``[h]:mm:ss``                                          |
+-------+--------------------------------------------------------+
| 47    | ``mm:ss.0``                                            |
+-------+--------------------------------------------------------+
| 48    | ``##0.0E+0``                                           |
+-------+--------------------------------------------------------+
| 49    | ``@``                                                  |
+-------+--------------------------------------------------------+


Numeric formats 23 to 36 are not documented by Microsoft and may differ in
international versions. The listed date and currency formats may also vary
depending on system settings.

The dollar sign in the above format usually appears as the defined local
currency symbol. To get more locale specific formatting see see
:ref:`num_format_categories`, above.


format.set_locked()
-------------------

.. py:function:: set_locked(state)

   Set the cell locked state.

   :param bool state: Turn cell locking on or off. Defaults to True.

This property can be used to prevent modification of a cell's contents.
Following Excel's convention, cell locking is turned on by default. However,
it only has an effect if the worksheet has been protected using the worksheet
:func:`protect` method::

    locked = workbook.add_format()
    locked.set_locked(True)

    unlocked = workbook.add_format()
    unlocked.set_locked(False)

    # Enable worksheet protection
    worksheet.protect()

    # This cell cannot be edited.
    worksheet.write('A1', '=1+2', locked)

    # This cell can be edited.
    worksheet.write('A2', '=1+2', unlocked)


format.set_hidden()
-------------------

.. py:function:: set_hidden()

   Hide formulas in a cell.

This property is used to hide a formula while still displaying its
result. This is generally used to hide complex calculations from end users who
are only interested in the result. It only has an effect if the worksheet has
been protected using the worksheet :func:`protect` method::

    hidden = workbook.add_format()
    hidden.set_hidden()

    # Enable worksheet protection
    worksheet.protect()

    # The formula in this cell isn't visible
    worksheet.write('A1', '=1+2', hidden)


format.set_align()
------------------

.. py:function:: set_align(alignment)

   Set the alignment for data in the cell.

   :param string alignment: The vertical and or horizontal alignment direction.

This method is used to set the horizontal and vertical text alignment within a
cell. The following are the available horizontal alignments:

+----------------------+
| Horizontal alignment |
+======================+
| left                 |
+----------------------+
| center               |
+----------------------+
| right                |
+----------------------+
| fill                 |
+----------------------+
| justify              |
+----------------------+
| center_across        |
+----------------------+
| distributed          |
+----------------------+

The following are the available vertical alignments:

+--------------------+
| Vertical alignment |
+====================+
| top                |
+--------------------+
| vcenter            |
+--------------------+
| bottom             |
+--------------------+
| vjustify           |
+--------------------+
| vdistributed       |
+--------------------+


As in Excel, vertical and horizontal alignments can be combined::

    cell_format = workbook.add_format()

    cell_format.set_align('center')
    cell_format.set_align('vcenter')

    worksheet.set_row(0, 70)
    worksheet.set_column('A:A', 30)

    worksheet.write(0, 0, 'Some Text', cell_format)

.. image:: _images/format_font_align.png

Text can be aligned across two or more adjacent cells using the
``'center_across'`` property. However, for genuine merged cells it is better
to use the :func:`merge_range` worksheet method.

The ``'vjustify'`` (vertical justify) option can be used to provide automatic
text wrapping in a cell. The height of the cell will be adjusted to
accommodate the wrapped text. To specify where the text wraps use the
:func:`set_text_wrap` method.


format.set_center_across()
--------------------------

.. py:function:: set_center_across()

   Center text across adjacent cells.

Text can be aligned across two or more adjacent cells using the
:func:`set_center_across` method. This is an alias for the
``set_align('center_across')`` method call.

Only the leftmost cell should contain the text. The other cells in the range
should be blank but should include the formatting::

    cell_format = workbook.add_format()
    cell_format.set_center_across()

    worksheet.write(1, 1, 'Center across selection', cell_format)
    worksheet.write_blank(1, 2, '', cell_format)

For actual merged cells it is better to use the :func:`merge_range` worksheet
method.


format.set_text_wrap()
----------------------

.. py:function:: set_text_wrap()

   Wrap text in a cell.

Turn text wrapping on for text in a cell::

    cell_format = workbook.add_format()
    cell_format.set_text_wrap()

    worksheet.write(0, 0, "Some long text to wrap in a cell", cell_format)

If you wish to control where the text is wrapped you can add newline characters
to the string::

    worksheet.write(2, 0, "It's\na bum\nwrap", cell_format)

.. image:: _images/format_font_text_wrap.png

Excel will adjust the height of the row to accommodate the wrapped text, as
shown in the image above. This can be useful but it can also have unwanted
side-effects:

* Objects such as images or charts that cross the automatically adjusted cells
  will not be scaled correctly. See :ref:`object_position_auto_row_height`.

* You may not want the row height to change. In that case you should set the
  row height to a non-default value such as 15.001.


format.set_rotation()
---------------------

.. py:function:: set_rotation(angle)

   Set the rotation of the text in a cell.

   :param int angle: Rotation angle in the range -90 to 90 and 270.

Set the rotation of the text in a cell. The rotation can be any angle in the
range -90 to 90 degrees::

    cell_format = workbook.add_format()
    cell_format.set_rotation(30)

    worksheet.write(0, 0, 'This text is rotated', cell_format)

.. image:: _images/format_font_text_rotated.png

The angle 270 is also supported. This indicates text where the letters run from
top to bottom.


format.set_reading_order()
--------------------------

.. py:function:: set_reading_order(direction)

   Set the reading order for the text in a cell.

   :param int direction: Reading order direction.

Set the text reading direction. This is useful when creating Arabic, Hebrew or
other near or far eastern worksheets. It can be used in conjunction with the
Worksheet :func:`right_to_left` method to also change the direction of the
worksheet.

.. only:: html

   ::

       format_left_to_right = workbook.add_format()
       format_left_to_right.set_reading_order(1)

       format_right_to_left = workbook.add_format()
       format_right_to_left.set_reading_order(2)

       worksheet.right_to_left()

       worksheet.write('A1', 'Ù†Øµ Ø¹Ø±Ø¨ÙŠ / English text')  # Default direction.
       worksheet.write('A2', 'Ù†Øµ Ø¹Ø±Ø¨ÙŠ / English text', format_left_to_right)
       worksheet.write('A3', 'Ù†Øµ Ø¹Ø±Ø¨ÙŠ / English text', format_right_to_left)

.. image:: _images/right_to_left.png


format.set_indent()
-------------------

.. py:function:: set_indent(level)

   Set the cell text indentation level.

   :param int level: Indentation level.

This method can be used to indent text in a cell. The argument, which should be
an integer, is taken as the level of indentation::

    cell_format1 = workbook.add_format()
    cell_format2 = workbook.add_format()

    cell_format1.set_indent(1)
    cell_format2.set_indent(2)

    worksheet.write('A1', 'This text is indented 1 level',  cell_format1)
    worksheet.write('A2', 'This text is indented 2 levels', cell_format2)

.. image:: _images/text_indent.png

Indentation is a horizontal alignment property. It will override any other
horizontal properties but it can be used in conjunction with vertical
properties.


format.set_shrink()
-------------------

.. py:function:: set_shrink()

   Turn on the text "shrink to fit" for a cell.

This method can be used to shrink text so that it fits in a cell::

    cell_format = workbook.add_format()
    cell_format.set_shrink()

    worksheet.write(0, 0, 'Honey, I shrunk the text!', cell_format)


format.set_text_justlast()
--------------------------

.. py:function:: set_text_justlast()

   Turn on the justify last text property.

Only applies to Far Eastern versions of Excel.


format.set_pattern()
--------------------

.. py:function:: set_pattern(index)

   :param int index: Pattern index. 0 - 18.

Set the background pattern of a cell.

The most common pattern is 1 which is a solid fill of the background color.


format.set_bg_color()
---------------------

.. py:function:: set_bg_color(color)

   Set the color of the background pattern in a cell.

   :param color: The cell background color.
   :type color: string|Color

The :func:`set_bg_color` method can be used to set the background color of a
pattern. Patterns are defined via the :func:`set_pattern` method. If a pattern
hasn't been defined then a solid fill pattern is used as the default.

Here is an example of how to set up a solid fill in a cell::

    cell_format = workbook.add_format()

    cell_format.set_pattern(1)  # This is optional when using a solid fill.
    cell_format.set_bg_color('green')

    worksheet.write('A1', 'Ray', cell_format)

.. image:: _images/formats_set_bg_color.png

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.



format.set_fg_color()
---------------------

.. py:function:: set_fg_color(color)

   Set the color of the foreground pattern in a cell.

   :param color: The cell foreground color.
   :type color: string|Color

The :func:`set_fg_color` method can be used to set the foreground color of a
pattern.

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.



format.set_border()
-------------------

.. py:function:: set_border(style)

   Set the cell border style.

   :param int style: Border style index. Default is 1.

Individual border elements can be configured using the following methods with
the same parameters:

* :func:`set_bottom`
* :func:`set_top`
* :func:`set_left`
* :func:`set_right`

A cell border is comprised of a border on the bottom, top, left and right.
These can be set to the same value using :func:`set_border` or individually
using the relevant method calls shown above.

The following shows the border styles sorted by XlsxWriter index number:

+-------+---------------+--------+-----------------+
| Index | Name          | Weight | Style           |
+=======+===============+========+=================+
| 0     | None          | 0      |                 |
+-------+---------------+--------+-----------------+
| 1     | Continuous    | 1      | ``-----------`` |
+-------+---------------+--------+-----------------+
| 2     | Continuous    | 2      | ``-----------`` |
+-------+---------------+--------+-----------------+
| 3     | Dash          | 1      | ``- - - - - -`` |
+-------+---------------+--------+-----------------+
| 4     | Dot           | 1      | ``. . . . . .`` |
+-------+---------------+--------+-----------------+
| 5     | Continuous    | 3      | ``-----------`` |
+-------+---------------+--------+-----------------+
| 6     | Double        | 3      | ``===========`` |
+-------+---------------+--------+-----------------+
| 7     | Continuous    | 0      | ``-----------`` |
+-------+---------------+--------+-----------------+
| 8     | Dash          | 2      | ``- - - - - -`` |
+-------+---------------+--------+-----------------+
| 9     | Dash Dot      | 1      | ``- . - . - .`` |
+-------+---------------+--------+-----------------+
| 10    | Dash Dot      | 2      | ``- . - . - .`` |
+-------+---------------+--------+-----------------+
| 11    | Dash Dot Dot  | 1      | ``- . . - . .`` |
+-------+---------------+--------+-----------------+
| 12    | Dash Dot Dot  | 2      | ``- . . - . .`` |
+-------+---------------+--------+-----------------+
| 13    | SlantDash Dot | 2      | ``/ - . / - .`` |
+-------+---------------+--------+-----------------+

The following shows the borders in the order shown in the Excel Dialog:

+-------+-----------------+-------+-----------------+
| Index | Style           | Index | Style           |
+=======+=================+=======+=================+
| 0     | None            | 12    | ``- . . - . .`` |
+-------+-----------------+-------+-----------------+
| 7     | ``-----------`` | 13    | ``/ - . / - .`` |
+-------+-----------------+-------+-----------------+
| 4     | ``. . . . . .`` | 10    | ``- . - . - .`` |
+-------+-----------------+-------+-----------------+
| 11    | ``- . . - . .`` | 8     | ``- - - - - -`` |
+-------+-----------------+-------+-----------------+
| 9     | ``- . - . - .`` | 2     | ``-----------`` |
+-------+-----------------+-------+-----------------+
| 3     | ``- - - - - -`` | 5     | ``-----------`` |
+-------+-----------------+-------+-----------------+
| 1     | ``-----------`` | 6     | ``===========`` |
+-------+-----------------+-------+-----------------+


format.set_bottom()
-------------------

.. py:function:: set_bottom(style)

   Set the cell bottom border style.

   :param int style: Border style index. Default is 1.

Set the cell bottom border style. See :func:`set_border` for details on the
border styles.


format.set_top()
----------------

.. py:function:: set_top(style)

   Set the cell top border style.

   :param int style: Border style index. Default is 1.

Set the cell top border style. See :func:`set_border` for details on the
border styles.


format.set_left()
-----------------

.. py:function:: set_left(style)

   Set the cell left border style.

   :param int style: Border style index. Default is 1.

Set the cell left border style. See :func:`set_border` for details on the
border styles.


format.set_right()
------------------

.. py:function:: set_right(style)

   Set the cell right border style.

   :param int style: Border style index. Default is 1.

Set the cell right border style. See :func:`set_border` for details on the
border styles.


format.set_border_color()
-------------------------

.. py:function:: set_border_color(color)

   Set the color of the cell border.

   :param color: The cell border color.
   :type color: string|Color

Individual border elements can be configured using the following methods with
the same parameters:

* :func:`set_bottom_color`
* :func:`set_top_color`
* :func:`set_left_color`
* :func:`set_right_color`

Set the color of the cell borders. A cell border is comprised of a border on
the bottom, top, left and right. These can be set to the same color using
:func:`set_border_color` or individually using the relevant method calls shown
above.

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.


format.set_bottom_color()
-------------------------

.. py:function:: set_bottom_color(color)

   Set the color of the bottom cell border.

   :param color: The cell border color.
   :type color: string|Color

See :func:`set_border_color` for details on the border colors.


format.set_top_color()
----------------------

.. py:function:: set_top_color(color)

   Set the color of the top cell border.

   :param color: The cell border color.
   :type color: string|Color

See :func:`set_border_color` for details on the border colors.


format.set_left_color()
-----------------------

.. py:function:: set_left_color(color)

   Set the color of the left cell border.

   :param color: The cell border color.
   :type color: string|Color

See :func:`set_border_color` for details on the border colors.


format.set_right_color()
------------------------

.. py:function:: set_right_color(color)

   Set the color of the right cell border.

   :param color: The cell border color.
   :type color: string|Color

See :func:`set_border_color` for details on the border colors.


format.set_diag_border()
------------------------

.. py:function:: set_diag_border(style)

   Set the diagonal cell border style.

   :param int style: Border style index. Default is 1.

Set the style for a diagonal border. The `style` is the same as those used in
:func:`set_border`.

See :ref:`ex_diagonal_border`.

.. image:: _images/diagonal_border.png


format.set_diag_type()
------------------------

.. py:function:: set_diag_type(style)

   Set the diagonal cell border type.

   :param int style: Border type, 1-3. No default.

Set the type of the diagonal border. The `style` should be one of the
following values:

1. From bottom left to top right.
2. From top left to bottom right.
3. Same as type 1 and 2 combined.


format.set_diag_color()
-----------------------

.. py:function:: set_diag_color(color)

   Set the color of the diagonal cell border.

   :param color: The cell border color.
   :type color: string|Color

See :func:`set_border_color` for details on the border colors.


format.set_quote_prefix()
-------------------------

.. py:function:: set_quote_prefix()

   Turn on quote prefix for the format.

Set the quote prefix property of a format to ensure a string is treated as a
string after editing. This is the same as prefixing the string with a single
quote in Excel. You don't need to add the quote to the string but you do need
to add the format.


format.set_checkbox()
---------------------

.. py:function:: set_checkbox()

   Turn on the checkbox property for the format.

This format property can be used with a cell that contains a boolean value to
display it as a checkbox. This property isn't required very often and it is
generally easier to create a checkbox using the :func:`insert_checkbox` method.

================
File: dev/docs/source/getting_started.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _getting_started:

Getting Started with XlsxWriter
===============================

Here are some easy instructions to get you up and running with the XlsxWriter
module.


Installing XlsxWriter
---------------------

The first step is to install the XlsxWriter module. There are several ways to
do this.

Using PIP
*********

The `pip <https://pip.pypa.io/en/latest/>`_  installer is
the preferred method for installing Python modules from
`PyPI <https://pypi.org/>`_, the Python Package Index::

    $ pip install XlsxWriter

    # Or to a non system dir:
    $ pip install --user XlsxWriter


Installing from a tarball
*************************

If you download a tarball of the latest version of XlsxWriter you can install
it as follows (change the version number to suit)::

    $ tar -zxvf XlsxWriter-1.2.3.tar.gz

    $ cd XlsxWriter-1.2.3
    $ python setup.py install

A tarball of the latest code can be downloaded from GitHub as follows::

    $ curl -O -L http://github.com/jmcnamara/XlsxWriter/archive/main.tar.gz

    $ tar zxvf main.tar.gz
    $ cd XlsxWriter-main/
    $ python setup.py install


Cloning from GitHub
*******************

The XlsxWriter source code and bug tracker is in the
`XlsxWriter repository <https://github.com/jmcnamara/XlsxWriter>`_ on GitHub.
You can clone the repository and install from it as follows::

    $ git clone https://github.com/jmcnamara/XlsxWriter.git

    $ cd XlsxWriter
    $ python setup.py install


Running a sample program
------------------------

If the installation went correctly you can create a small sample program like
the following to verify that the module works correctly:

.. code-block:: python

    import xlsxwriter

    workbook = xlsxwriter.Workbook('hello.xlsx')
    worksheet = workbook.add_worksheet()

    worksheet.write('A1', 'Hello world')

    workbook.close()

Save this to a file called ``hello.py`` and run it as follows::

    $ python hello.py

This will output a file called ``hello.xlsx`` which should look something like
the following:

.. image:: _images/hello01.png

If you downloaded a tarball or cloned the repo, as shown above, you should also
have a directory called
`examples <https://github.com/jmcnamara/XlsxWriter/tree/main/examples>`_
with some sample applications that demonstrate different features of
XlsxWriter.


Next steps
----------

Once you are happy that the module is installed and operational you can have a
look at the rest of the XlsxWriter documentation. :ref:`tutorial1` is a good
place to start.

================
File: dev/docs/source/index.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

Creating Excel files with Python and XlsxWriter
===============================================

XlsxWriter is a Python module for creating Excel XLSX files.

.. image:: _images/demo.png

.. only:: html

   (:ref:`Sample code to create the above spreadsheet <ex_demo>`.)

   **XlsxWriter**

XlsxWriter is a Python module that can be used to write text, numbers, formulas
and hyperlinks to multiple worksheets in an Excel 2007+ XLSX file. It supports
features such as formatting and many more, including:

* 100% compatible Excel XLSX files.
* Full formatting.
* Merged cells.
* Defined names.
* Charts.
* Autofilters.
* Data validation and drop down lists.
* Conditional formatting.
* Worksheet PNG/JPEG/GIF/BMP/WMF/EMF images.
* Rich multi-format strings.
* Cell comments.
* Textboxes.
* Integration with Pandas and Polars.
* Memory optimization mode for writing large files.

It supports Python 3.8+ and PyPy3 and uses standard libraries only.

.. only:: html

   This document explains how to use the XlsxWriter module. See the following
   sections for more information, or jump straight to the :ref:`intro`.

   .. toctree::
      :maxdepth: 1

      contents.rst

.. toctree::
   :maxdepth: 1

   introduction.rst
   getting_started.rst

.. toctree::
   :maxdepth: 1

   tutorial01.rst
   tutorial02.rst
   tutorial03.rst

.. toctree::
   :maxdepth: 1

   workbook.rst
   worksheet.rst
   page_setup.rst
   format.rst
   color.rst
   chart.rst
   chartsheet.rst
   exceptions.rst
   utility.rst

.. toctree::
   :maxdepth: 1

   working_with_cell_notation.rst
   working_with_data.rst
   working_with_formulas.rst
   working_with_dates_and_time.rst
   working_with_colors.rst
   working_with_charts.rst
   working_with_object_positioning.rst
   working_with_autofilters.rst
   working_with_data_validation.rst
   working_with_conditional_formats.rst
   working_with_tables.rst
   working_with_textboxes.rst
   working_with_sparklines.rst
   working_with_cell_comments.rst
   working_with_outlines.rst
   working_with_memory.rst
   working_with_macros.rst
   working_with_pandas.rst
   working_with_polars.rst

.. toctree::
   :maxdepth: 1

   examples.rst

.. toctree::
   :maxdepth: 1

   chart_examples.rst

.. toctree::
   :maxdepth: 1

   pandas_examples.rst
   polars_examples.rst

.. toctree::
   :maxdepth: 1

   alternatives.rst
   third_party.rst
   bugs.rst
   faq.rst
   changes.rst
   author.rst
   license.rst

================
File: dev/docs/source/introduction.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _intro:

Introduction
============

**XlsxWriter** is a Python module for writing files in the Excel 2007+ XLSX
file format.

It can be used to write text, numbers, and formulas to multiple worksheets and
it supports features such as formatting, images, charts, page setup,
autofilters, conditional formatting and many others.

XlsxWriter has some advantages and disadvantages over the
:ref:`alternative Python modules <alternatives>` for writing Excel files.

* Advantages:

   * It supports more Excel features than any of the alternative modules.

   * It has a high degree of fidelity with files produced by Excel. In most
     cases the files produced are 100% equivalent to files produced by Excel.

   * It has extensive documentation, example files and tests.

   * It is fast and can be configured to use very little memory even for very
     large output files.

* Disadvantages:

   * It cannot read or modify existing Excel XLSX files.


XlsxWriter is licensed under a BSD 2-Clause :ref:`License` and the source code is
available on `GitHub <https://github.com/jmcnamara/XlsxWriter>`_.

To try out the module see the next section on :ref:`getting_started`.

================
File: dev/docs/source/license.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _license:

License
=======

XlsxWriter is released under a BSD 2-Clause license.


.. include:: ../../../LICENSE.txt

================
File: dev/docs/source/page_setup.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _page_setup:

The Worksheet Class (Page Setup)
================================

Page set-up methods affect the way that a worksheet looks to the user or when
it is printed. They control features such as paper size, orientation, page
headers and margins and gridlines.

These methods are really just standard :ref:`worksheet <worksheet>` methods.
They are documented separately for the sake of clarity.


worksheet.set_landscape()
-------------------------

.. py:function:: set_landscape()

   Set the page orientation as landscape.

This method is used to set the orientation of a worksheet's printed page to
landscape::

    worksheet.set_landscape()


worksheet.set_portrait()
------------------------

.. py:function:: set_portrait()

   Set the page orientation as portrait.

This method is used to set the orientation of a worksheet's printed page to
portrait. The default worksheet orientation is portrait, so you won't
generally need to call this method::

    worksheet.set_portrait()


worksheet.set_page_view()
-------------------------

.. py:function:: set_page_view(view=1)

   Set the page view mode.

   :param int view: 0: Normal, 1: Page Layout, 2: Page Break.


This method is used to display the worksheet in "Page View/Layout" mode::

    worksheet.set_page_view()

It can also be used to set the other view modes:

- 0: Normal view mode.
- 1: Page view mode (the default).
- 2: Page break view mode. Same as ``set_pagebreak_view()``.

worksheet.set_pagebreak_view()
------------------------------

.. py:function:: set_pagebreak_view()

   Set the page break view mode.

This method is used to display the worksheet in "Page Break Preview" mode::

    worksheet.set_pagebreak_view()


worksheet.set_paper()
---------------------

.. py:function:: set_paper(index)

   Set the paper type.

   :param int index: The Excel paper format index.

This method is used to set the paper format for the printed output of a
worksheet. The following paper styles are available:

+-------+----------------------+-------------------+
| Index | Paper format         | Paper size        |
+=======+======================+===================+
| 0     | Printer default      | Printer default   |
+-------+----------------------+-------------------+
| 1     | Letter               | 8 1/2 x 11 in     |
+-------+----------------------+-------------------+
| 2     | Letter Small         | 8 1/2 x 11 in     |
+-------+----------------------+-------------------+
| 3     | Tabloid              | 11 x 17 in        |
+-------+----------------------+-------------------+
| 4     | Ledger               | 17 x 11 in        |
+-------+----------------------+-------------------+
| 5     | Legal                | 8 1/2 x 14 in     |
+-------+----------------------+-------------------+
| 6     | Statement            | 5 1/2 x 8 1/2 in  |
+-------+----------------------+-------------------+
| 7     | Executive            | 7 1/4 x 10 1/2 in |
+-------+----------------------+-------------------+
| 8     | A3                   | 297 x 420 mm      |
+-------+----------------------+-------------------+
| 9     | A4                   | 210 x 297 mm      |
+-------+----------------------+-------------------+
| 10    | A4 Small             | 210 x 297 mm      |
+-------+----------------------+-------------------+
| 11    | A5                   | 148 x 210 mm      |
+-------+----------------------+-------------------+
| 12    | B4                   | 250 x 354 mm      |
+-------+----------------------+-------------------+
| 13    | B5                   | 182 x 257 mm      |
+-------+----------------------+-------------------+
| 14    | Folio                | 8 1/2 x 13 in     |
+-------+----------------------+-------------------+
| 15    | Quarto               | 215 x 275 mm      |
+-------+----------------------+-------------------+
| 16    | ---                  | 10x14 in          |
+-------+----------------------+-------------------+
| 17    | ---                  | 11x17 in          |
+-------+----------------------+-------------------+
| 18    | Note                 | 8 1/2 x 11 in     |
+-------+----------------------+-------------------+
| 19    | Envelope 9           | 3 7/8 x 8 7/8     |
+-------+----------------------+-------------------+
| 20    | Envelope 10          | 4 1/8 x 9 1/2     |
+-------+----------------------+-------------------+
| 21    | Envelope 11          | 4 1/2 x 10 3/8    |
+-------+----------------------+-------------------+
| 22    | Envelope 12          | 4 3/4 x 11        |
+-------+----------------------+-------------------+
| 23    | Envelope 14          | 5 x 11 1/2        |
+-------+----------------------+-------------------+
| 24    | C size sheet         | ---               |
+-------+----------------------+-------------------+
| 25    | D size sheet         | ---               |
+-------+----------------------+-------------------+
| 26    | E size sheet         | ---               |
+-------+----------------------+-------------------+
| 27    | Envelope DL          | 110 x 220 mm      |
+-------+----------------------+-------------------+
| 28    | Envelope C3          | 324 x 458 mm      |
+-------+----------------------+-------------------+
| 29    | Envelope C4          | 229 x 324 mm      |
+-------+----------------------+-------------------+
| 30    | Envelope C5          | 162 x 229 mm      |
+-------+----------------------+-------------------+
| 31    | Envelope C6          | 114 x 162 mm      |
+-------+----------------------+-------------------+
| 32    | Envelope C65         | 114 x 229 mm      |
+-------+----------------------+-------------------+
| 33    | Envelope B4          | 250 x 353 mm      |
+-------+----------------------+-------------------+
| 34    | Envelope B5          | 176 x 250 mm      |
+-------+----------------------+-------------------+
| 35    | Envelope B6          | 176 x 125 mm      |
+-------+----------------------+-------------------+
| 36    | Envelope             | 110 x 230 mm      |
+-------+----------------------+-------------------+
| 37    | Monarch              | 3.875 x 7.5 in    |
+-------+----------------------+-------------------+
| 38    | Envelope             | 3 5/8 x 6 1/2 in  |
+-------+----------------------+-------------------+
| 39    | Fanfold              | 14 7/8 x 11 in    |
+-------+----------------------+-------------------+
| 40    | German Std Fanfold   | 8 1/2 x 12 in     |
+-------+----------------------+-------------------+
| 41    | German Legal Fanfold | 8 1/2 x 13 in     |
+-------+----------------------+-------------------+


Note, it is likely that not all of these paper types will be available to the
end user since it will depend on the paper formats that the user's printer
supports. Therefore, it is best to stick to standard paper types::

    worksheet.set_paper(1)  # US Letter
    worksheet.set_paper(9)  # A4

If you do not specify a paper type the worksheet will print using the printer's
default paper style.


worksheet.center_horizontally()
-------------------------------

.. py:function:: center_horizontally()

   Center the printed page horizontally.

Center the worksheet data horizontally between the margins on the printed page::

    worksheet.center_horizontally()


worksheet.center_vertically()
-----------------------------

.. py:function:: center_vertically()

   Center the printed page vertically.

Center the worksheet data vertically between the margins on the printed page::

    worksheet.center_vertically()

worksheet.set_margins()
-----------------------

.. py:function:: set_margins([left=0.7,] right=0.7,] top=0.75,] bottom=0.75]]])

   Set the worksheet margins for the printed page.

   :param float left:   Left margin in inches. Default 0.7.
   :param float right:  Right margin in inches. Default 0.7.
   :param float top:    Top margin in inches. Default 0.75.
   :param float bottom: Bottom margin in inches. Default 0.75.


The ``set_margins()`` method is used to set the margins of the worksheet when
it is printed. The units are in inches. All parameters are optional and have
default values corresponding to the default Excel values.


worksheet.set_header()
----------------------

.. py:function:: set_header([header='',] options]])

   Set the printed page header caption and options.

   :param string header: Header string with Excel control characters.
   :param dict options:  Header options.

Headers and footers are generated using a string which is a combination of
plain text and control characters.

The available control character are:

+---------------+---------------+-----------------------+
| Control       | Category      | Description           |
+===============+===============+=======================+
| &L            | Justification | Left                  |
+---------------+---------------+-----------------------+
| &C            |               | Center                |
+---------------+---------------+-----------------------+
| &R            |               | Right                 |
+---------------+---------------+-----------------------+
| &P            | Information   | Page number           |
+---------------+---------------+-----------------------+
| &N            |               | Total number of pages |
+---------------+---------------+-----------------------+
| &D            |               | Date                  |
+---------------+---------------+-----------------------+
| &T            |               | Time                  |
+---------------+---------------+-----------------------+
| &F            |               | File name             |
+---------------+---------------+-----------------------+
| &A            |               | Worksheet name        |
+---------------+---------------+-----------------------+
| &Z            |               | Workbook path         |
+---------------+---------------+-----------------------+
| &fontsize     | Font          | Font size             |
+---------------+---------------+-----------------------+
| &"font,style" |               | Font name and style   |
+---------------+---------------+-----------------------+
| &U            |               | Single underline      |
+---------------+---------------+-----------------------+
| &E            |               | Double underline      |
+---------------+---------------+-----------------------+
| &S            |               | Strikethrough         |
+---------------+---------------+-----------------------+
| &X            |               | Superscript           |
+---------------+---------------+-----------------------+
| &Y            |               | Subscript             |
+---------------+---------------+-----------------------+
| &[Picture]    | Images        | Image placeholder     |
+---------------+---------------+-----------------------+
| &G            |               | Same as &[Picture]    |
+---------------+---------------+-----------------------+
| &&            | Misc.         | Literal ampersand "&" |
+---------------+---------------+-----------------------+


Text in headers and footers can be justified (aligned) to the left, center and
right by prefixing the text with the control characters ``&L``, ``&C`` and
``&R``.

For example::

    worksheet.set_header('&LHello')

        ---------------------------------------------------------------
       |                                                               |
       | Hello                                                         |
       |                                                               |


    $worksheet->set_header('&CHello');

        ---------------------------------------------------------------
       |                                                               |
       |                          Hello                                |
       |                                                               |


    $worksheet->set_header('&RHello');

        ---------------------------------------------------------------
       |                                                               |
       |                                                         Hello |
       |                                                               |


For simple text, if you do not specify any justification the text will be
centered. However, you must prefix the text with ``&C`` if you specify a font
name or any other formatting::

    worksheet.set_header('Hello')

        ---------------------------------------------------------------
       |                                                               |
       |                          Hello                                |
       |                                                               |

You can have text in each of the justification regions::

    worksheet.set_header('&LCiao&CBello&RCielo')

        ---------------------------------------------------------------
       |                                                               |
       | Ciao                     Bello                          Cielo |
       |                                                               |


The information control characters act as variables that Excel will update as
the workbook or worksheet changes. Times and dates are in the users default
format::

    worksheet.set_header('&CPage &P of &N')

        ---------------------------------------------------------------
       |                                                               |
       |                        Page 1 of 6                            |
       |                                                               |

    worksheet.set_header('&CUpdated at &T')

        ---------------------------------------------------------------
       |                                                               |
       |                    Updated at 12:30 PM                        |
       |                                                               |

Images can be inserted using the ``options`` shown below. Each image must
have a placeholder in header string using the ``&[Picture]`` or ``&G``
control characters::

    worksheet.set_header('&L&G', {'image_left': 'logo.jpg'})

.. image:: _images/header_image.png


You can specify the font size of a section of the text by prefixing it with the
control character ``&n`` where ``n`` is the font size::

    worksheet1.set_header('&C&30Hello Big')
    worksheet2.set_header('&C&10Hello Small')

You can specify the font of a section of the text by prefixing it with the
control sequence ``&"font,style"`` where ``fontname`` is a font name such as
"Courier New" or "Times New Roman" and ``style`` is one of the standard
Windows font descriptions: "Regular", "Italic", "Bold" or "Bold Italic"::

    worksheet1.set_header('&C&"Courier New,Italic"Hello')
    worksheet2.set_header('&C&"Courier New,Bold Italic"Hello')
    worksheet3.set_header('&C&"Times New Roman,Regular"Hello')

It is possible to combine all of these features together to create
sophisticated headers and footers. As an aid to setting up complicated headers
and footers you can record a page set-up as a macro in Excel and look at the
format strings that VBA produces. Remember however that VBA uses two double
quotes ``""`` to indicate a single double quote. For the last example above
the equivalent VBA code looks like this::

    .LeftHeader = ""
    .CenterHeader = "&""Times New Roman,Regular""Hello"
    .RightHeader = ""

Alternatively you can inspect the header and footer strings in an Excel file by
unzipping it and grepping the XML sub-files. The following shows how to do that
using `libxml's xmllint
<https://gnome.pages.gitlab.gnome.org/libxml2/xmllint.html>`_ to format the XML
for clarity::

    $ unzip myfile.xlsm -d myfile
    $ xmllint --format `find myfile -name "*.xml" | xargs` | egrep "Header|Footer" | sed 's/&amp;/\&/g'

      <headerFooter scaleWithDoc="0">
        <oddHeader>&L&P</oddHeader>
      </headerFooter>

To include a single literal ampersand ``&`` in a header or footer you should
use a double ampersand ``&&``::

    worksheet1.set_header('&CCuriouser && Curiouser - Attorneys at Law')

The available options are:

* ``margin``: (float) Header margin in inches. Defaults to 0.3 inch.
* ``image_left``: (string) The path to the image. Needs ``&G`` placeholder.
* ``image_center``: (string) Same as above.
* ``image_right``: (string) Same as above.
* ``image_data_left``: (BytesIO) A byte stream of the image data.
* ``image_data_center``: (BytesIO) Same as above.
* ``image_data_right``: (BytesIO) Same as above.
* ``scale_with_doc``: (boolean) Scale header with document. Defaults to True.
* ``align_with_margins``: (boolean) Align header to margins. Defaults to True.

As with the other margins the ``margin`` value should be in inches. The
default header and footer margin is 0.3 inch. It can be changed as follows::

    worksheet.set_header('&CHello', {'margin': 0.75})

The header and footer margins are independent of, and should not be confused
with, the top and bottom worksheet margins.

The image options must have an accompanying ``&[Picture]`` or ``&G`` control
character in the header string::

     worksheet.set_header('&L&[Picture]&C&[Picture]&R&[Picture]',
                          {'image_left':   'red.jpg',
                           'image_center': 'blue.jpg',
                           'image_right':  'yellow.jpg'})


The ``image_data_`` parameters are used to add an in-memory byte stream in
:class:`io.BytesIO` format::

     image_file = open('logo.jpg', 'rb')
     image_data = BytesIO(image_file.read())

     worksheet.set_header('&L&G',
                          {'image_left': 'logo.jpg',
                           'image_data_left': image_data})

When using the ``image_data_`` parameters a filename must still be passed to
to the equivalent ``image_`` parameter since it is required by Excel. See also
:func:`insert_image` for details on handling images from byte streams.

Note, Excel does not allow header or footer strings longer than 255 characters,
including control characters. Strings longer than this will not be written
and a warning will be issued.

See also :ref:`ex_headers_footers`.

worksheet.set_footer()
----------------------

.. py:function:: set_footer([footer='',] options]])

   Set the printed page footer caption and options.

   :param string footer: Footer string with Excel control characters.
   :param dict options:  Footer options.

The syntax of the ``set_footer()`` method is the same as :func:`set_header`.


worksheet.repeat_rows()
-----------------------

.. py:function:: repeat_rows(first_row[, last_row])

   Set the number of rows to repeat at the top of each printed page.

   :param int first_row: First row of repeat range.
   :param int last_row:  Last row of repeat range. Optional.

For large Excel documents it is often desirable to have the first row or rows
of the worksheet print out at the top of each page.

This can be achieved by using the ``repeat_rows()`` method. The parameters
``first_row`` and ``last_row`` are zero based. The ``last_row`` parameter is
optional if you only wish to specify one row::

    worksheet1.repeat_rows(0)     # Repeat the first row.
    worksheet2.repeat_rows(0, 1)  # Repeat the first two rows.


worksheet.repeat_columns()
--------------------------

.. py:function:: repeat_columns(first_col[, last_col])

   Set the columns to repeat at the left hand side of each printed page.

   :param int first_col: First column of repeat range.
   :param int last_col:  Last column of repeat range. Optional.

For large Excel documents it is often desirable to have the first column or
columns of the worksheet print out at the left hand side of each page.

This can be achieved by using the ``repeat_columns()`` method. The parameters
``first_column`` and ``last_column`` are zero based. The ``last_column``
parameter is optional if you only wish to specify one column. You can also
specify the columns using A1 column notation, see :ref:`cell_notation` for
more details.::

    worksheet1.repeat_columns(0)      # Repeat the first column.
    worksheet2.repeat_columns(0, 1)   # Repeat the first two columns.
    worksheet3.repeat_columns('A:A')  # Repeat the first column.
    worksheet4.repeat_columns('A:B')  # Repeat the first two columns.


worksheet.hide_gridlines()
--------------------------

.. py:function:: hide_gridlines([option=1])

   Set the option to hide gridlines on the screen and the printed page.

   :param int option: Hide gridline options. See below.

This method is used to hide the gridlines on the screen and printed page.
Gridlines are the lines that divide the cells on a worksheet. Screen and
printed gridlines are turned on by default in an Excel worksheet.

If you have defined your own cell borders you may wish to hide the default
gridlines::

    worksheet.hide_gridlines()

The following values of ``option`` are valid:

0. Don't hide gridlines.
1. Hide printed gridlines only.
2. Hide screen and printed gridlines.

If you don't supply an argument the default option is 1, i.e. only the printed
gridlines are hidden.


worksheet.print_row_col_headers()
---------------------------------

.. py:function:: print_row_col_headers()

   Set the option to print the row and column headers on the printed page.

When you print a worksheet from Excel you get the data selected in the print
area. By default the Excel row and column headers (the row numbers on the left
and the column letters at the top) aren't printed.

The ``print_row_col_headers()`` method sets the printer option to print these
headers::

    worksheet.print_row_col_headers()


worksheet.hide_row_col_headers()
--------------------------------

.. py:function:: hide_row_col_headers()

   Set the option to hide the row and column headers in a worksheet.

This method is similar to the ``print_row_col_headers()`` except that it hides
the row and column headers on the worksheet::

    worksheet.hide_row_col_headers()

.. image:: _images/hide_row_col_headers.png


worksheet.print_area()
----------------------

.. py:function:: print_area(first_row, first_col, last_row, last_col)

   Set the print area in the current worksheet.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :type  first_row:   integer
   :type  first_col:   integer
   :type  last_row:    integer
   :type  last_col:    integer

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

This method is used to specify the area of the worksheet that will be printed.

All four parameters must be specified. You can also use A1 notation, see
:ref:`cell_notation`::

    worksheet1.print_area('A1:H20')     # Cells A1 to H20.
    worksheet2.print_area(0, 0, 19, 7)  # The same as above.

In order to set a row or column range you must specify the entire range::

    worksheet3.print_area('A1:H1048576')  # Same as A:H.


worksheet.print_across()
------------------------

.. py:function:: print_across()

   Set the order in which pages are printed.

The ``print_across`` method is used to change the default print direction. This
is referred to by Excel as the sheet "page order"::

    worksheet.print_across()

The default page order is shown below for a worksheet that extends over 4
pages. The order is called "down then across"::

    [1] [3]
    [2] [4]

However, by using the ``print_across`` method the print order will be changed
to "across then down"::

    [1] [2]
    [3] [4]

worksheet.fit_to_pages()
------------------------

.. py:function:: fit_to_pages(width, height)

   Fit the printed area to a specific number of pages both vertically and
   horizontally.

   :param int width:  Number of pages horizontally.
   :param int height: Number of pages vertically.

The ``fit_to_pages()`` method is used to fit the printed area to a specific
number of pages both vertically and horizontally. If the printed area exceeds
the specified number of pages it will be scaled down to fit. This ensures that
the printed area will always appear on the specified number of pages even if
the page size or margins change::

    worksheet1.fit_to_pages(1, 1)  # Fit to 1x1 pages.
    worksheet2.fit_to_pages(2, 1)  # Fit to 2x1 pages.
    worksheet3.fit_to_pages(1, 2)  # Fit to 1x2 pages.

The print area can be defined using the ``print_area()`` method as described
above.

A common requirement is to fit the printed output to ``n`` pages wide but have
the height be as long as necessary. To achieve this set the ``height`` to
zero::

    worksheet1.fit_to_pages(1, 0)  # 1 page wide and as long as necessary.

.. Note::
   Although it is valid to use both :func:`fit_to_pages()` and
   :func:`set_print_scale()` on the same worksheet in Excel only allows one of
   these options to be active at a time. The last method call made will set
   the active option.

.. Note::
   The :func:`fit_to_pages()` will override any manual page breaks that are
   defined in the worksheet.

.. Note::
   When using :func:`fit_to_pages()` it may also be required to set the
   printer paper size using :func:`set_paper()` or else Excel will default
   to "US Letter".


worksheet.set_start_page()
--------------------------

.. py:function:: set_start_page()

   Set the start/first page number when printing.

   :param int start_page:  Starting page number.

The ``set_start_page()`` method is used to set the page number of the starting
page when the worksheet is printed out. It is the same as the "First Page
Number" option in Excel::

    # Start print from page 2.
    worksheet.set_start_page(2)


worksheet.set_print_scale()
---------------------------

.. py:function:: set_print_scale()

   Set the scale factor for the printed page.

   :param int scale: Print scale of worksheet to be printed.

Set the scale factor of the printed page. Scale factors in the range
``10 <= $scale <= 400`` are valid::

    worksheet1.set_print_scale(50)
    worksheet2.set_print_scale(75)
    worksheet3.set_print_scale(300)
    worksheet4.set_print_scale(400)

The default scale factor is 100. Note, ``set_print_scale()`` does not affect
the scale of the visible page in Excel. For that you should use
:func:`set_zoom()`.

Note also that although it is valid to use both ``fit_to_pages()`` and
``set_print_scale()`` on the same worksheet Excel only allows one of these
options to be active at a time. The last method call made will set the active
option.


worksheet.print_black_and_white()
---------------------------------

.. py:function:: print_black_and_white()

   Set the worksheet to print in black and white.

Set the option to print the worksheet in black and white::

    worksheet.print_black_and_white()



worksheet.set_h_pagebreaks()
----------------------------

.. py:function:: set_h_pagebreaks(breaks)

   Set the horizontal page breaks on a worksheet.

   :param list breaks: List of page break rows.

The ``set_h_pagebreaks()`` method adds horizontal page breaks to a worksheet. A
page break causes all the data that follows it to be printed on the next page.
Horizontal page breaks act between rows.

The ``set_h_pagebreaks()`` method takes a list of one or more page breaks::

    worksheet1.set_v_pagebreaks([20])
    worksheet2.set_v_pagebreaks([20, 40, 60, 80, 100])

To create a page break between rows 20 and 21 you must specify the break at row
21. However in zero index notation this is actually row 20. So you can pretend
for a small while that you are using 1 index notation::

    worksheet.set_h_pagebreaks([20])  # Break between row 20 and 21.

.. Note::
   Note: If you specify the "fit to page" option via the ``fit_to_pages()``
   method it will override all manual page breaks.

There is a silent limitation of 1023 horizontal page breaks per worksheet in
line with an Excel internal limitation.


worksheet.set_v_pagebreaks()
----------------------------

.. py:function:: set_v_pagebreaks(breaks)

   Set the vertical page breaks on a worksheet.

   :param list breaks: List of page break columns.

The ``set_v_pagebreaks()`` method is the same as the above
:func:`set_h_pagebreaks()` method except it adds page breaks between columns.

================
File: dev/docs/source/pandas_examples.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _pandas_examples:

Pandas with XlsxWriter Examples
===============================

The following are some of the examples included in the
`examples <https://github.com/jmcnamara/XlsxWriter/tree/master/examples>`_
directory of the XlsxWriter distribution.

They show how to use XlsxWriter with `Pandas <https://pandas.pydata.org/>`_.

.. toctree::
   :maxdepth: 1

   example_pandas_simple.rst
   example_pandas_multiple.rst
   example_pandas_positioning.rst
   example_pandas_chart.rst
   example_pandas_conditional.rst
   example_pandas_autofilter.rst
   example_pandas_table.rst
   example_pandas_datetime.rst
   example_pandas_column_formats.rst
   example_pandas_header_format.rst
   example_pandas_percentage.rst
   example_pandas_chart_line.rst
   example_pandas_chart_columns.rst

================
File: dev/docs/source/polars_examples.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _polars_examples:

Polars with XlsxWriter Examples
===============================

The following are some of the examples included in the
`examples <https://github.com/jmcnamara/XlsxWriter/tree/master/examples>`_
directory of the XlsxWriter distribution.

They show how to use XlsxWriter with `Polars <https://pola.rs/>`_ .

.. toctree::
   :maxdepth: 1

   example_polars_simple.rst
   example_polars_xlsxwriter.rst
   example_polars_positioning.rst
   example_polars_multiple.rst
   example_polars_chart.rst
   example_polars_conditional.rst
   example_polars_format_default.rst
   example_polars_format_custom.rst
   example_polars_checkbox.rst
   example_polars_sparklines.rst

================
File: dev/docs/source/third_party.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _third_party:

Libraries that use or enhance XlsxWriter
========================================

The following are some libraries or applications that wrap or extend
XlsxWriter.


Pandas
------

Python `Pandas <https://pandas.pydata.org/>`_ is a Python data analysis
library. It can read, filter and re-arrange small and large data sets and
output them in a range of formats including Excel.

XlsxWriter is available as an Excel output engine in Pandas. See also See
:ref:`ewx_pandas`.


XlsxPandasFormatter
-------------------

`XlsxPandasFormatter
<https://github.com/webermarcolivier/xlsxpandasformatter>`_ is a helper class
that wraps the worksheet, workbook and dataframe objects written by Pandas
``to_excel()`` method using the ``xlsxwriter`` engine to allow consistent
formatting of cells.

================
File: dev/docs/source/tutorial01.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _tutorial1:

Tutorial 1: Create a simple XLSX file
=====================================

.. highlight:: python

Let's start by creating a simple spreadsheet using Python and the XlsxWriter
module.

Say that we have some data on monthly outgoings that we want to convert into an
Excel XLSX file::

    expenses = (
        ['Rent', 1000],
        ['Gas',   100],
        ['Food',  300],
        ['Gym',    50],
    )

To do that we can start with a small program like the following:

.. code-block:: python

    import xlsxwriter

    # Create a workbook and add a worksheet.
    workbook = xlsxwriter.Workbook('Expenses01.xlsx')
    worksheet = workbook.add_worksheet()

    # Some data we want to write to the worksheet.
    expenses = (
        ['Rent', 1000],
        ['Gas',   100],
        ['Food',  300],
        ['Gym',    50],
    )

    # Start from the first cell. Rows and columns are zero indexed.
    row = 0
    col = 0

    # Iterate over the data and write it out row by row.
    for item, cost in (expenses):
        worksheet.write(row, col,     item)
        worksheet.write(row, col + 1, cost)
        row += 1

    # Write a total using a formula.
    worksheet.write(row, 0, 'Total')
    worksheet.write(row, 1, '=SUM(B1:B4)')

    workbook.close()

If we run this program we should get a spreadsheet that looks like this:

.. image:: _images/tutorial01.png

This is a simple example but the steps involved are representative of all
programs that use XlsxWriter, so let's break it down into separate parts.

The first step is to import the module::

    import xlsxwriter

The next step is to create a new workbook object using the ``Workbook()``
constructor.

:func:`Workbook` takes one, non-optional, argument which is the filename that
we want to create::

    workbook = xlsxwriter.Workbook('Expenses01.xlsx')

.. note::
   XlsxWriter can only create *new files*. It cannot read or modify existing
   files.

The workbook object is then used to add a new worksheet via the
:func:`add_worksheet` method::

    worksheet = workbook.add_worksheet()

By default worksheet names in the spreadsheet will be `Sheet1`, `Sheet2` etc.,
but we can also specify a name::

    worksheet1 = workbook.add_worksheet()        # Defaults to Sheet1.
    worksheet2 = workbook.add_worksheet('Data')  # Data.
    worksheet3 = workbook.add_worksheet()        # Defaults to Sheet3.

We can then use the worksheet object to write data via the :func:`write`
method::

    worksheet.write(row, col, some_data)

.. Note::
   Throughout XlsxWriter, *rows* and *columns* are zero indexed. The
   first cell in a worksheet, ``A1``, is ``(0, 0)``.

So in our example we iterate over our data and write it out as follows::

    # Iterate over the data and write it out row by row.
    for item, cost in (expenses):
        worksheet.write(row, col,     item)
        worksheet.write(row, col + 1, cost)
        row += 1

We then add a formula to calculate the total of the items in the second column::

    worksheet.write(row, 1, '=SUM(B1:B4)')

Finally, we close the Excel file via the :func:`close` method::

    workbook.close()

And that's it. We now have a file that can be read by Excel and other
spreadsheet applications.

In the next sections we will see how we can use the XlsxWriter module to add
formatting and other Excel features.

================
File: dev/docs/source/tutorial02.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _tutorial2:

Tutorial 2: Adding formatting to the XLSX File
==============================================

.. highlight:: python

In the previous section we created a simple spreadsheet using Python and the
XlsxWriter module.

This converted the required data into an Excel file but it looked a little
bare. In order to make the information clearer we would like to add some
simple formatting, like this:

.. image:: _images/tutorial02.png

The differences here are that we have added **Item** and **Cost** column
headers in a bold font, we have formatted the currency in the second column
and we have made the **Total** string bold.

To do this we can extend our program as follows:

.. only:: html

   (The significant changes are shown with a red line.)

.. code-block:: python
   :emphasize-lines: 7-15, 32, 36-37

    import xlsxwriter

    # Create a workbook and add a worksheet.
    workbook = xlsxwriter.Workbook('Expenses02.xlsx')
    worksheet = workbook.add_worksheet()

    # Add a bold format to use to highlight cells.
    bold = workbook.add_format({'bold': True})

    # Add a number format for cells with money.
    money = workbook.add_format({'num_format': '$#,##0'})

    # Write some data headers.
    worksheet.write('A1', 'Item', bold)
    worksheet.write('B1', 'Cost', bold)

    # Some data we want to write to the worksheet.
    expenses = (
        ['Rent', 1000],
        ['Gas',   100],
        ['Food',  300],
        ['Gym',    50],
    )

    # Start from the first cell below the headers.
    row = 1
    col = 0

    # Iterate over the data and write it out row by row.
    for item, cost in (expenses):
        worksheet.write(row, col,     item)
        worksheet.write(row, col + 1, cost, money)
        row += 1

    # Write a total using a formula.
    worksheet.write(row, 0, 'Total',       bold)
    worksheet.write(row, 1, '=SUM(B2:B5)', money)

    workbook.close()

The main difference between this and the previous program is that we have added
two :ref:`Format <Format>` objects that we can use to format cells in the
spreadsheet.

Format objects represent all of the formatting properties that can be applied
to a cell in Excel such as fonts, number formatting, colors and borders. This
is explained in more detail in :ref:`format` section.

For now we will avoid getting into the details and just use a limited amount of
the format functionality to add some simple formatting::

    # Add a bold format to use to highlight cells.
    bold = workbook.add_format({'bold': True})

    # Add a number format for cells with money.
    money = workbook.add_format({'num_format': '$#,##0'})

We can then pass these formats as an optional third parameter to the
:ref:`worksheet. <Worksheet>`:func:`write()` method to format the data in the
cell::

    write(row, column, token, [format])

Like this::

    worksheet.write(row, 0, 'Total', bold)

Which leads us to another new feature in this program. To add the headers in
the first row of the worksheet we used :func:`write()` like this::

    worksheet.write('A1', 'Item', bold)
    worksheet.write('B1', 'Cost', bold)

So, instead of ``(row, col)`` we used the Excel ``'A1'``  style notation. See
:ref:`cell_notation` for more details but don't be too concerned about it for
now. It is just a little syntactic sugar to help with laying out worksheets.

In the next section we will look at handling more data types.

================
File: dev/docs/source/tutorial03.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _tutorial3:

Tutorial 3: Writing different types of data to the XLSX File
============================================================

.. highlight:: python

In the previous section we created a simple spreadsheet with formatting using
Python and the XlsxWriter module.

This time let's extend the data we want to write to include some dates::

    expenses = (
        ['Rent', '2013-01-13', 1000],
        ['Gas',  '2013-01-14',  100],
        ['Food', '2013-01-16',  300],
        ['Gym',  '2013-01-20',   50],
    )

The corresponding spreadsheet will look like this:

.. image:: _images/tutorial03.png

The differences here are that we have added a Date column with formatting and
made that column a little wider to accommodate the dates.

To do this we can extend our program as follows:

.. only:: html

   (The significant changes are shown with a red line.)

.. code-block:: python
   :emphasize-lines: 1, 15, 18, 27-30, 39-43

    from datetime import datetime
    import xlsxwriter

    # Create a workbook and add a worksheet.
    workbook = xlsxwriter.Workbook('Expenses03.xlsx')
    worksheet = workbook.add_worksheet()

    # Add a bold format to use to highlight cells.
    bold = workbook.add_format({'bold': 1})

    # Add a number format for cells with money.
    money_format = workbook.add_format({'num_format': '$#,##0'})

    # Add an Excel date format.
    date_format = workbook.add_format({'num_format': 'mmmm d yyyy'})

    # Adjust the column width.
    worksheet.set_column(1, 1, 15)

    # Write some data headers.
    worksheet.write('A1', 'Item', bold)
    worksheet.write('B1', 'Date', bold)
    worksheet.write('C1', 'Cost', bold)

    # Some data we want to write to the worksheet.
    expenses = (
        ['Rent', '2013-01-13', 1000],
        ['Gas',  '2013-01-14',  100],
        ['Food', '2013-01-16',  300],
        ['Gym',  '2013-01-20',   50],
    )

    # Start from the first cell below the headers.
    row = 1
    col = 0

    for item, date_str, cost in (expenses):
        # Convert the date string into a datetime object.
        date = datetime.strptime(date_str, "%Y-%m-%d")

        worksheet.write_string  (row, col,     item              )
        worksheet.write_datetime(row, col + 1, date, date_format )
        worksheet.write_number  (row, col + 2, cost, money_format)
        row += 1

    # Write a total using a formula.
    worksheet.write(row, 0, 'Total', bold)
    worksheet.write(row, 2, '=SUM(C2:C5)', money_format)

    workbook.close()

The main difference between this and the previous program is that we have added
a new :ref:`Format <Format>` object for dates and we have additional handling
for data types.

Excel treats different types of input data, such as strings and numbers,
differently although it generally does it transparently to the user.
XlsxWriter tries to emulate this in the
:ref:`worksheet. <Worksheet>`:func:`write()` method by mapping Python data
types to types that Excel supports.

The ``write()`` method acts as a general alias for several more specific
methods:

* :func:`write_string()`
* :func:`write_number()`
* :func:`write_blank()`
* :func:`write_formula()`
* :func:`write_datetime()`
* :func:`write_boolean()`
* :func:`write_url()`

In this version of our program we have used some of these explicit ``write_``
methods for different types of data::

        worksheet.write_string  (row, col,     item              )
        worksheet.write_datetime(row, col + 1, date, date_format )
        worksheet.write_number  (row, col + 2, cost, money_format)

This is mainly to show that if you need more control over the type of data you
write to a worksheet you can use the appropriate method. In this simplified
example the :func:`write()` method would actually have worked just as well.

The handling of dates is also new to our program.

Dates and times in Excel are floating point numbers that have a number format
applied to display them in the correct format. If the date and time are Python
:mod:`datetime` objects XlsxWriter makes the required number conversion
automatically. However, we also need to add the number format to ensure that
Excel displays it as as date::

    from datetime import datetime
    ...

    date_format = workbook.add_format({'num_format': 'mmmm d yyyy'})
    ...

    for item, date_str, cost in (expenses):
        # Convert the date string into a datetime object.
        date = datetime.strptime(date_str, "%Y-%m-%d")
        ...
        worksheet.write_datetime(row, col + 1, date, date_format )
        ...

Date handling is explained in more detail in :ref:`working_with_dates_and_time`.

The last addition to our program is the :func:`set_column` method to adjust the
width of column 'B' so that the dates are more clearly visible::

    # Adjust the column width.
    worksheet.set_column('B:B', 15)

That completes the tutorial section.

In the next sections we will look at the API in more detail starting with
:ref:`workbook`.

================
File: dev/docs/source/utility.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _utility:

Utility and Helper Functions
----------------------------

The ``XlsxWriter`` ``utility`` module contains several helper functions for
dealing with A1 notation and strings. These functions can be imported as
follows::

    from xlsxwriter.utility import xl_rowcol_to_cell

    cell = xl_rowcol_to_cell(1, 2)  # C2


xl_rowcol_to_cell()
~~~~~~~~~~~~~~~~~~~

.. py:function:: xl_rowcol_to_cell(row, col[, row_abs, col_abs])

   Convert a zero indexed row and column cell reference to a A1 style string.

   :param int row:      The cell row.
   :param int col:      The cell column.
   :param bool row_abs: Optional flag to make the row absolute.
   :param bool col_abs: Optional flag to make the column absolute.
   :return:             ``A1`` style string.
   :rtype:              str


The ``xl_rowcol_to_cell()`` function converts a zero indexed row and column
cell values to an ``A1`` style string::

    cell = xl_rowcol_to_cell(0, 0)   # A1
    cell = xl_rowcol_to_cell(0, 1)   # B1
    cell = xl_rowcol_to_cell(1, 0)   # A2

The optional parameters ``row_abs`` and ``col_abs`` can be used to indicate
that the row or column is absolute::

    str = xl_rowcol_to_cell(0, 0, col_abs=True)                # $A1
    str = xl_rowcol_to_cell(0, 0, row_abs=True)                # A$1
    str = xl_rowcol_to_cell(0, 0, row_abs=True, col_abs=True)  # $A$1


xl_cell_to_rowcol()
~~~~~~~~~~~~~~~~~~~

.. py:function:: xl_cell_to_rowcol(cell_str)

   Convert a cell reference in ``A1`` notation to a zero indexed row and column.

   :param string cell_str: ``A1`` style string, absolute or relative.
   :return:                Tuple of ints for (row, col).
   :rtype:                 (int, int).


The ``xl_cell_to_rowcol()`` function converts an Excel cell reference in ``A1``
notation to a zero based row and column. The function will also handle Excel's
absolute, ``$``, cell notation::

    (row, col) = xl_cell_to_rowcol('A1')    # (0, 0)
    (row, col) = xl_cell_to_rowcol('B1')    # (0, 1)
    (row, col) = xl_cell_to_rowcol('C2')    # (1, 2)
    (row, col) = xl_cell_to_rowcol('$C2')   # (1, 2)
    (row, col) = xl_cell_to_rowcol('C$2')   # (1, 2)
    (row, col) = xl_cell_to_rowcol('$C$2')  # (1, 2)


xl_col_to_name()
~~~~~~~~~~~~~~~~

.. py:function:: xl_col_to_name(col[, col_abs])

   Convert a zero indexed column cell reference to a string.

   :param int col:      The cell column.
   :param bool col_abs: Optional flag to make the column absolute.
   :return:             Column style string.
   :rtype:              str


The ``xl_col_to_name()`` converts a zero based column reference to a string::

    column = xl_col_to_name(0)    # A
    column = xl_col_to_name(1)    # B
    column = xl_col_to_name(702)  # AAA

The optional parameter ``col_abs`` can be used to indicate if the column is
absolute::

    column = xl_col_to_name(0, False)  # A
    column = xl_col_to_name(0, True)   # $A
    column = xl_col_to_name(1, True)   # $B


xl_range()
~~~~~~~~~~

.. py:function:: xl_range(first_row, first_col, last_row, last_col)

   Converts zero indexed row and column cell references to a A1:B1 range
   string.

   :param int first_row:     The first cell row.
   :param int first_col:     The first cell column.
   :param int last_row:      The last cell row.
   :param int last_col:      The last cell column.
   :return:                  ``A1:B1`` style range string.
   :rtype:                   str


The ``xl_range()`` function converts zero based row and column cell references
to an ``A1:B1`` style range string::

    cell_range = xl_range(0, 0, 9, 0)  # A1:A10
    cell_range = xl_range(1, 2, 8, 2)  # C2:C9
    cell_range = xl_range(0, 0, 3, 4)  # A1:E4
    cell_range = xl_range(0, 0, 0, 0)  # A1


xl_range_abs()
~~~~~~~~~~~~~~

.. py:function:: xl_range_abs(first_row, first_col, last_row, last_col)

   Converts zero indexed row and column cell references to a $A$1:$B$1
   absolute range string.

   :param int first_row:     The first cell row.
   :param int first_col:     The first cell column.
   :param int last_row:      The last cell row.
   :param int last_col:      The last cell column.
   :return:                  ``$A$1:$B$1`` style range string.
   :rtype:                   str


The ``xl_range_abs()`` function converts zero based row and column cell
references to an absolute ``$A$1:$B$1`` style range string::

    cell_range = xl_range_abs(0, 0, 9, 0)  # $A$1:$A$10
    cell_range = xl_range_abs(1, 2, 8, 2)  # $C$2:$C$9
    cell_range = xl_range_abs(0, 0, 3, 4)  # $A$1:$E$4
    cell_range = xl_range_abs(0, 0, 0, 0)  # $A$1




cell_autofit_width()
~~~~~~~~~~~~~~~~~~~~

.. py:function:: cell_autofit_width(string)

   Calculate the width required to auto-fit a string in a cell.

   :param String string: The string to calculate the cell width for.
   :return:              The string autofit width in pixels. Returns 0 if the
                         string is empty.
   :rtype:               int

The Worksheet :func:`autofit` method can be used to auto-fit cell data to the
optimal column width. However, in some cases you may wish to handle auto-fitting
yourself and apply additional logic to limit the maximum and minimum ranges.

The ``cell_autofit_width()`` function can be used to perform the required
calculation. It works by estimating the pixel width of a string based on the
width of each character. It also adds a 7 pixel padding for the cell
boundary in the same way that Excel does.

You can use the  calculated width in conjunction with Worksheet
:func:`set_column_pixels` method:

.. literalinclude:: ../../../examples/autofit_manually.py
   :lines: 11-

.. image:: _images/autofit_manually.png

The limitations that apply to the Worksheet ``autofit`` method also applies to
this function. See the docs on :func:`autofit`  for more information.

================
File: dev/docs/source/workbook.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _workbook:

The Workbook Class
==================

The Workbook class is the main class exposed by the XlsxWriter module and it is
the only class that you will need to instantiate directly.

The Workbook class represents the entire spreadsheet as you see it in Excel and
internally it represents the Excel file as it is written on disk.

Constructor
-----------

.. py:function:: Workbook(filename [,options])

   Create a new XlsxWriter Workbook object.

   :param string filename: The name of the new Excel file to create.
   :param dict options:    Optional workbook parameters. See below.
   :rtype:                 A Workbook object.


The ``Workbook()`` constructor is used to create a new Excel workbook with a
given filename::

    import xlsxwriter

    workbook  = xlsxwriter.Workbook('filename.xlsx')
    worksheet = workbook.add_worksheet()

    worksheet.write(0, 0, 'Hello Excel')

    workbook.close()

.. image:: _images/workbook01.png

The constructor options are:

* **constant_memory**: Reduces the amount of data stored in memory so that
  large files can be written efficiently::

       workbook = xlsxwriter.Workbook(filename, {'constant_memory': True})

  Note, in this mode a row of data is written and then discarded when a cell
  in a new row is added via one of the worksheet ``write_()`` methods.
  Therefore, once this mode is active, data should be written in sequential
  row order. For this reason the :func:`add_table()` and :func:`merge_range()`
  Worksheet methods don't work in this mode.

  See :ref:`memory_perf` for more details.

* **tmpdir**: ``XlsxWriter`` stores workbook data in temporary files prior
  to assembling the final XLSX file. The temporary files are created in the
  system's temp directory. If the default temporary directory isn't accessible
  to your application, or doesn't contain enough space, you can specify an
  alternative location using the ``tmpdir`` option::

       workbook = xlsxwriter.Workbook(filename, {'tmpdir': '/home/user/tmp'})

  The temporary directory must exist and will not be created.

* **in_memory**: To avoid the use of temporary files in the assembly of the
  final XLSX file, for example on servers that don't allow temp files, set the
  ``in_memory`` constructor option to ``True``::

       workbook = xlsxwriter.Workbook(filename, {'in_memory': True})

  This option overrides the ``constant_memory`` option.

  .. Note::
     This option used to be the recommended way of deploying XlsxWriter on
     Google APP Engine since it didn't support a ``/tmp`` directory. However,
     the Python 3 Runtime Environment in Google App Engine supports a
     `filesystem with read/write access to /tmp <https://cloud.google.com/appengine/docs/standard/python3/runtime#filesystem>`_
     which means this option isn't required.


* **strings_to_numbers**: Enable the
  :ref:`worksheet. <Worksheet>`:func:`write()` method to convert strings to
  numbers, where possible, using :func:`float()` in order to avoid an Excel
  warning about "Numbers Stored as Text". The default is ``False``. To enable
  this option use::

      workbook = xlsxwriter.Workbook(filename, {'strings_to_numbers': True})

* **strings_to_formulas**: Enable the
  :ref:`worksheet. <Worksheet>`:func:`write()` method to convert strings to
  formulas. The default is ``True``. To disable this option use::

      workbook = xlsxwriter.Workbook(filename, {'strings_to_formulas': False})

* **strings_to_urls**: Enable the :ref:`worksheet. <Worksheet>`:func:`write()`
  method to convert strings to urls. The default is ``True``. To disable this
  option use::

      workbook = xlsxwriter.Workbook(filename, {'strings_to_urls': False})

* **use_future_functions**: Enable the use of newer Excel "future" functions
  without having to prefix them with with ``_xlfn.``. The default is
  ``False``. To enable this option use::

      workbook = xlsxwriter.Workbook(filename, {'use_future_functions': True})

  See also :ref:`formula_future`.

* **max_url_length**: Set the maximum length for hyperlinks in worksheets. The
  default is 2079 and the minimum is 255. Versions of Excel prior to Excel
  2015 limited hyperlink links and anchor/locations to 255 characters
  each. Versions after that support urls up to 2079 characters. XlsxWriter
  versions >= 1.2.3 support the new longer limit by default. However, a lower
  or user defined limit can be set via the ``max_url_length`` option::

      workbook = xlsxwriter.Workbook(filename, {'max_url_length': 255})

* **nan_inf_to_errors**: Enable the
  :ref:`worksheet. <Worksheet>`:func:`write()` and :func:`write_number()`
  methods to convert ``nan``, ``inf`` and ``-inf`` to Excel errors. Excel
  doesn't handle NAN/INF as numbers so as a workaround they are mapped to
  formulas that yield the error codes ``#NUM!`` and ``#DIV/0!``.  The default
  is ``False``. To enable this option use::

      workbook = xlsxwriter.Workbook(filename, {'nan_inf_to_errors': True})

* **default_date_format**: This option is used to specify a default date
  format string for use with the
  :ref:`worksheet. <Worksheet>`:func:`write_datetime()` method when an
  explicit format isn't given. See :ref:`working_with_dates_and_time` for more
  details::

      xlsxwriter.Workbook(filename, {'default_date_format': 'dd/mm/yy'})

* **remove_timezone**: Excel doesn't support timezones in datetimes/times so
  there isn't any fail-safe way that XlsxWriter can map a Python timezone aware
  datetime into an Excel datetime in functions such as
  :func:`write_datetime`. As such the user should convert and remove the
  timezones in some way that makes sense according to their
  requirements. Alternatively the ``remove_timezone`` option can be used to
  strip the timezone from datetime values. The default is ``False``. To enable
  this option use::

      workbook = xlsxwriter.Workbook(filename, {'remove_timezone': True})

  See also :ref:`Timezone Handling in XlsxWriter <timezone_handling>`.


* **use_zip64**: Use ZIP64 extensions when writing the xlsx file zip container
  to allow files greater than 4 GB. This is the same as calling
  :func:`use_zip64` after creating the Workbook object. This constructor
  option is just syntactic sugar to make the use of the option more
  explicit. The following are equivalent::

      workbook = xlsxwriter.Workbook(filename, {'use_zip64': True})

      # Same as:
      workbook = xlsxwriter.Workbook(filename)
      workbook.use_zip64()

  See the note about the Excel warning caused by using this option in
  :func:`use_zip64`.


* **date_1904**: Excel for Windows uses a default epoch of 1900 and Excel for
  Mac uses an epoch of 1904. However, Excel on either platform will convert
  automatically between one system and the other. XlsxWriter stores dates in
  the 1900 format by default. If you wish to change this you can use the
  ``date_1904`` workbook option. This option is mainly for enhanced
  compatibility with Excel and in general isn't required very often::

      workbook = xlsxwriter.Workbook(filename, {'date_1904': True})

When specifying a filename it is recommended that you use an ``.xlsx``
extension or Excel will generate a warning when opening the file.

The ``Workbook()`` method also works using the ``with`` context manager. In
which case it doesn't need an explicit `close()` statement::

    with xlsxwriter.Workbook('hello_world.xlsx') as workbook:
        worksheet = workbook.add_worksheet()

        worksheet.write('A1', 'Hello world')

It is possible to write files to in-memory strings using BytesIO as follows::

    from io import BytesIO

    output = BytesIO()
    workbook = xlsxwriter.Workbook(output)
    worksheet = workbook.add_worksheet()

    worksheet.write('A1', 'Hello')
    workbook.close()

    xlsx_data = output.getvalue()

To avoid the use of any temporary files and keep the entire file in-memory use
the ``in_memory`` constructor option shown above.

See also :ref:`ex_http_server`.


workbook.add_worksheet()
------------------------

.. function:: add_worksheet([name])

   Add a new worksheet to a workbook.

   :param string name: Optional worksheet name, defaults to Sheet1, etc.
   :rtype: A :ref:`worksheet <Worksheet>` object.

   :raises DuplicateWorksheetName: if a duplicate worksheet name is used.
   :raises InvalidWorksheetName: if an invalid worksheet name is used.

The ``add_worksheet()`` method adds a new worksheet to a workbook.

At least one worksheet should be added to a new workbook. The
:ref:`Worksheet <worksheet>` object is used to write data and configure a
worksheet in the workbook.

The ``name`` parameter is optional. If it is not specified, or blank, the
default Excel convention will be followed, i.e. Sheet1, Sheet2, etc.::

    worksheet1 = workbook.add_worksheet()           # Sheet1
    worksheet2 = workbook.add_worksheet('Foglio2')  # Foglio2
    worksheet3 = workbook.add_worksheet('Data')     # Data
    worksheet4 = workbook.add_worksheet()           # Sheet4

.. image:: _images/workbook02.png

The worksheet name must be a valid Excel worksheet name:

* It must be less than 32 characters. This error will raise a
  :exc:`InvalidWorksheetName` exception.

* It cannot contain any of the characters: ``[ ] : * ? / \``. This error will
  raise a :exc:`InvalidWorksheetName` exception.

* It cannot begin or end with an apostrophe. This error will raise a
  :exc:`InvalidWorksheetName` exception.

* You cannot use the same, case insensitive, ``name`` for more than one
  worksheet. This error will raise a :exc:`DuplicateWorksheetName` exception.

* You should not use the Excel reserved name "History", or case insensitive
  variants as this is restricted in English, and other, versions of Excel.

The rules for worksheet names in Excel are explained in the Microsoft Office
documentation on how to `Rename a worksheet
<https://support.microsoft.com/en-us/office/rename-a-worksheet-3f1f7148-ee83-404d-8ef0-9ff99fbad1f9>`_.


workbook.add_format()
---------------------

.. py:function:: add_format([properties])

   Create a new Format object to formats cells in worksheets.

   :param dictionary properties: An optional dictionary of format properties.
   :rtype: A :ref:`format <Format>` object.

The ``add_format()`` method can be used to create new :ref:`Format <Format>`
objects which are used to apply formatting to a cell. You can either define
the properties at creation time via a dictionary of property values or later
via method calls::

    format1 = workbook.add_format(props)  # Set properties at creation.
    format2 = workbook.add_format()       # Set properties later.

See the :ref:`format` section for more details about Format properties and how
to set them.


workbook.add_chart()
--------------------

.. py:function:: add_chart(options)

   Create a chart object that can be added to a worksheet.

   :param dictionary options: An dictionary of chart type options.
   :rtype: A :ref:`Chart <chart_class>` object.

This method is use to create a new chart object that can be inserted into a
worksheet via the :func:`insert_chart()` Worksheet method::

    chart = workbook.add_chart({'type': 'column'})

The properties that can be set are::

    type    (required)
    subtype (optional)
    name    (optional)

* ``type``

  This is a required parameter. It defines the type of chart that will be
  created::

    chart = workbook.add_chart({'type': 'line'})

  The available types are::

    area
    bar
    column
    doughnut
    line
    pie
    radar
    scatter
    stock

* ``subtype``

  Used to define a chart subtype where available::

    workbook.add_chart({'type': 'bar', 'subtype': 'stacked'})

  See the :ref:`chart_class` for a list of available chart subtypes.

* ``name``

  Set the name for the chart sheet::

    chart = workbook.add_chart({'type': 'column', 'name': 'MyChart'})

  The name property is optional and if it isn't supplied it will default to
  ``Chart1``, ``Chart2``, etc. The name must be a valid Excel chart name.

.. Note::

   A chart can only be inserted into a worksheet once. If several similar
   charts are required then each one must be created separately with
   ``add_chart()``.


See also :ref:`working_with_charts` and :ref:`chart_examples`.

workbook.add_chartsheet()
-------------------------

.. function:: add_chartsheet([sheetname])

   Add a new add_chartsheet to a workbook.

   :param string sheetname: Optional chartsheet name, defaults to Chart1, etc.
   :rtype: A :ref:`chartsheet <Chartsheet>` object.

The ``add_chartsheet()`` method adds a new chartsheet to a workbook.

.. image:: _images/chartsheet.png

See :ref:`chartsheet` for details.

The ``sheetname`` parameter is optional. If it is not specified the default
Excel convention will be followed, i.e. Chart1, Chart2, etc.

The chartsheet name must be a valid Excel worksheet name. See
:func:`add_worksheet()` for the limitation on Excel worksheet names.


workbook.close()
----------------

.. py:function:: close()

   Close the Workbook object and write the XLSX file.

   :raises FileCreateError: if there is a file or permissions error during writing.
   :raises DuplicateTableName: if a duplicate worksheet table name was added.
   :raises EmptyChartSeries: if a chart is added without a data series.
   :raises UndefinedImageSize: if an image doesn't contain height/width data.
   :raises UnsupportedImageFormat: if an image type isn't supported.
   :raises FileSizeError: if the file size would require ZIP64 extensions.

The workbook ``close()`` method writes all data to the xlsx file and closes
it::

    workbook.close()

This is a required method call to close and write the xlsxwriter file, unless
you are using the ``with`` context manager, see below.

The ``Workbook`` object also works using the ``with`` context manager. In
which case it doesn't need an explicit ``close()`` statement::

    With xlsxwriter.Workbook('hello_world.xlsx') as workbook:
        worksheet = workbook.add_worksheet()

        worksheet.write('A1', 'Hello world')

The workbook will close automatically when exiting the scope of the ``with``
statement.

The most common exception during ``close()`` is ``FileCreateError`` which is
generally caused by a write permission error.  On Windows this usually occurs
if the file being created is already open in Excel. This exception can be
caught in a ``try`` block where you can instruct the user to close the open
file before overwriting it::

    while True:
        try:
            workbook.close()
        except xlsxwriter.exceptions.FileCreateError as e:
            decision = input("Exception caught in workbook.close(): %s\n"
                             "Please close the file if it is open in Excel.\n"
                             "Try to write file again? [Y/n]: " % e)
            if decision != 'n':
                continue

        break

The ``close()`` method can only write a file once. It doesn't behave like a
save method and it cannot be called multiple times to write a file at
different stages. If it is called more than once it will raise a
``UserWarning`` in order to help avoid issues where a file is closed within a
loop or at the wrong scope level.

See also :ref:`ex_check_close`.


workbook.set_size()
-------------------

.. py:function:: set_size(width, height)

   Set the size of a workbook window.

   :param int width:  Width of the window in pixels.
   :param int height: Height of the window in pixels.

The ``set_size()`` method can be used to set the size of a workbook window::

    workbook.set_size(1200, 800)

The Excel window size was used in Excel 2007 to define the width and height of
a workbook window within the Multiple Document Interface (MDI). In later
versions of Excel for Windows this interface was dropped. This method is
currently only useful when setting the window size in Excel for Mac 2011. The
units are pixels and the default size is 1073 x 644.

Note, this doesn't equate exactly to the Excel for Mac pixel size since it is
based on the original Excel 2007 for Windows sizing. Some trial and error may
be required to get an exact size.


workbook.tab_ratio()
--------------------

.. py:function:: set_tab_ratio(tab_ratio)

   Set the ratio between the worksheet tabs and the horizontal slider.

   :param float tab_ratio:  The tab ratio between 0 and 100.

The ``set_tab_ratio()`` method can be used to set the ratio between worksheet
tabs and the horizontal slider at the bottom of a workbook. This can be
increased to give more room to the tabs or reduced to increase the size of the
horizontal slider:

.. image:: _images/tab_ratio.png

The default value in Excel is 60. It can be changed as follows::

    workbook.set_tab_ratio(75)


workbook.set_properties()
-------------------------

.. py:function:: set_properties(properties)

   Set the document properties such as Title, Author etc.

   :param dict properties: Dictionary of document properties.

The ``set_properties()`` method can be used to set the document properties of the
Excel file created by ``XlsxWriter``. These properties are visible when you
use the ``Office Button -> Prepare -> Properties`` option in Excel and are
also available to external applications that read or index windows files.

The properties that can be set are:

* ``title``
* ``subject``
* ``author``
* ``manager``
* ``company``
* ``category``
* ``keywords``
* ``comments``
* ``status``
* ``hyperlink_base``
* ``created`` - the file creation date as a :class:`datetime.date` object.

The properties are all optional and should be passed in dictionary format as
follows::

    workbook.set_properties({
        'title':    'This is an example spreadsheet',
        'subject':  'With document properties',
        'author':   'John McNamara',
        'manager':  'Dr. Heinz Doofenshmirtz',
        'company':  'of Wolves',
        'category': 'Example spreadsheets',
        'keywords': 'Sample, Example, Properties',
        'created':  datetime.date(2018, 1, 1),
        'comments': 'Created with Python and XlsxWriter'})

.. image:: _images/doc_properties.png

See also :ref:`ex_doc_properties`.


workbook.set_custom_property()
------------------------------

.. py:function:: set_custom_property(name, value [, property_type])

   Set a custom document property.

   :param name:          The name of the custom property.
   :param value:         The value of the custom property (various types).
   :param property_type: The type of the property. Optional.
   :type name:           string
   :type property_type:  string


The ``set_custom_property()`` method can be used to set one or more custom
document properties not covered by the standard properties in the
``set_properties()`` method above.

For example::

    date = datetime.strptime('2016-12-12', '%Y-%m-%d')

    workbook.set_custom_property('Checked by',       'Eve')
    workbook.set_custom_property('Date completed',   date)
    workbook.set_custom_property('Document number',  12345)
    workbook.set_custom_property('Reference number', 1.2345)
    workbook.set_custom_property('Has review',       True)
    workbook.set_custom_property('Signed off',       False)

.. image:: _images/custom_properties.png


Date parameters should be :class:`datetime.datetime` objects.

The optional ``property_type`` parameter can be used to set an explicit type
for the custom property, just like in Excel. The available types are::

    text
    date
    number
    bool

However, in almost all cases the type will be inferred correctly from the
Python type, like in the example above.


Note: the ``name`` and ``value`` parameters are limited to 255 characters by
Excel.

Custom properties can also be used to set Sensitivity Labels. Sensitivity Labels
are a property that can be added to an Office 365 document to indicate that it
is compliant with a company's information protection policies. Sensitivity
Labels have designations like "Confidential", "Internal use only", or "Public"
depending on the policies implemented by the company. They are generally only
enabled for enterprise versions of Office.

See the following Microsoft documentation on how to `Apply sensitivity labels to
your files and email
<https://support.microsoft.com/en-us/office/apply-sensitivity-labels-to-your-files-and-email-2f96e7cd-d5a4-403b-8bd7-4cc636bae0f9>`_.

Sensitivity Labels are generally stored as custom document properties so they
can be enabled using ``set_custom_property()``. However, since the metadata
differs from company to company you will need to extract some of the required
metadata from sample files.

The first step is to create a new file in Excel and set a non-encrypted
sensitivity label. Then unzip the file by changing the extension from `.xlsx` to
`.zip` or by using a command line utility like this:

.. code-block:: bash

  $ unzip myfile.xlsx -d myfile
  Archive:  myfile.xlsx
    inflating: myfile/[Content_Types].xml
    inflating: myfile/docProps/app.xml
    inflating: myfile/docProps/custom.xml
    inflating: myfile/docProps/core.xml
    inflating: myfile/_rels/.rels
    inflating: myfile/xl/workbook.xml
    inflating: myfile/xl/worksheets/sheet1.xml
    inflating: myfile/xl/styles.xml
    inflating: myfile/xl/theme/theme1.xml
    inflating: myfile/xl/_rels/workbook.xml.rels


Then examine the ``docProps/custom.xml`` file from the unzipped xlsx file. The
file doesn't contain newlines so it is best to view it in an editor that can
handle XML or use a commandline utility like libxmlâ€™s `xmllint`_ to format the
XML for clarity:

.. _xmllint: https://gnome.pages.gitlab.gnome.org/libxml2/xmllint.html

.. code-block:: xml

  $ xmllint --format myfile/docProps/custom.xml
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <Properties
      xmlns="http://schemas.openxmlformats.org/officeDocument/2006/custom-properties"
      xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="2"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_Enabled">
      <vt:lpwstr>true</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="3"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_SetDate">
      <vt:lpwstr>2024-01-01T12:00:00Z</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="4"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_Method">
      <vt:lpwstr>Privileged</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="5"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_Name">
      <vt:lpwstr>Confidential</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="6"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_SiteId">
      <vt:lpwstr>cb46c030-1825-4e81-a295-151c039dbf02</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="7"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_ActionId">
      <vt:lpwstr>88124cf5-1340-457d-90e1-0000a9427c99</vt:lpwstr>
    </property>
    <property fmtid="{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"
              pid="8"
              name="MSIP_Label_2096f6a2-d2f7-48be-b329-b73aaa526e5d_ContentBits">
      <vt:lpwstr>2</vt:lpwstr>
    </property>
  </Properties>

The MSIP (Microsoft Information Protection) labels in the ``name`` attributes
contain a GUID that is unique to each company. The "SiteId" field will also be
unique to your company/location. The meaning of each of these fields is
explained in the the following Microsoft document on `Microsoft Information
Protection SDK - Metadata
<https://learn.microsoft.com/en-us/information-protection/develop/concept-mip-metadata>`_.

Once you have identified the necessary metadata you can add it to a new document
as shown below::

  import xlsxwriter

  workbook = xlsxwriter.Workbook("sensitivity_label.xlsx")
  worksheet = workbook.add_worksheet()

  # Metadata extracted from a company specific file.
  company_guid = "2096f6a2-d2f7-48be-b329-b73aaa526e5d"
  site_id = "cb46c030-1825-4e81-a295-151c039dbf02"
  action_id = "88124cf5-1340-457d-90e1-0000a9427c99"

  # Add the document properties. Note that these should all be in text format.
  workbook.set_custom_property(f"MSIP_Label_{company_guid}_Enabled", "true", "text")
  workbook.set_custom_property(f"MSIP_Label_{company_guid}_SetDate", "2024-01-01T12:00:00Z", "text")
  workbook.set_custom_property(f"MSIP_Label_{company_guid}_Method", "Privileged", "text")
  workbook.set_custom_property(f"MSIP_Label_{company_guid}_Name", "Confidential", "text")
  workbook.set_custom_property(f"MSIP_Label_{company_guid}_SiteId", site_id, "text")
  workbook.set_custom_property(f"MSIP_Label_{company_guid}_ActionId", action_id, "text")
  workbook.set_custom_property(f"MSIP_Label_{company_guid}_ContentBits", "2", "text")

  workbook.close()


Note, some sensitivity labels require that the document is encrypted. In order
to extract the required metadata you will need to unencrypt the file which may
remove the sensitivity label. In that case you may need to use a third party
tool such as `msoffice-crypt`_.

.. _msoffice-crypt: https://github.com/herumi/msoffice


workbook.define_name()
----------------------

.. py:function:: define_name()

   Create a defined name in the workbook to use as a variable.

   :param string name:    The defined name.
   :param string formula: The cell or range that the defined name refers to.

This method is used to defined a name that can be used to represent a value, a
single cell or a range of cells in a workbook. These are sometimes referred to
as a "Named Range".

Defined names are generally used to simplify or clarify formulas by using
descriptive variable names::

    workbook.define_name('Exchange_rate', '=0.96')
    worksheet.write('B3', '=B2*Exchange_rate')

.. image:: _images/defined_name.png

As in Excel a name defined like this is "global" to the workbook and can be
referred to from any worksheet::

    # Global workbook name.
    workbook.define_name('Sales', '=Sheet1!$G$1:$H$10')

It is also possible to define a local/worksheet name by prefixing it with the
sheet name using the syntax ``'sheetname!definedname'``::

    # Local worksheet name.
    workbook.define_name('Sheet2!Sales', '=Sheet2!$G$1:$G$10')

If the sheet name contains spaces or special characters you must follow the
Excel convention and enclose it in single quotes::

    workbook.define_name("'New Data'!Sales", '=Sheet2!$G$1:$G$10')

The rules for names in Excel are explained in the Microsoft Office
documentation on how to `Define and use names in formulas
<https://support.microsoft.com/en-us/office/define-and-use-names-in-formulas-4d0f13ac-53b7-422e-afd2-abd7ff379c64>`_.

See also :ref:`ex_defined_name`.


workbook.add_vba_project()
--------------------------

.. py:function:: add_vba_project(vba_project[, is_stream])

   Add a vbaProject binary to the Excel workbook.

   :param      vba_project: The vbaProject binary file name.
   :param bool is_stream:   The vba_project is an in memory byte stream.

The ``add_vba_project()`` method can be used to add macros or functions to a
workbook using a binary VBA project file that has been extracted from an
existing Excel xlsm file::

    workbook.add_vba_project('./vbaProject.bin')

Only one ``vbaProject.bin`` file can be added per workbook. The name doesn't
have to be ``vbaProject.bin``. Any suitable path/name for an existing VBA bin
file will do.

The ``is_stream`` parameter is used to indicate that ``vba_project`` refers to
a BytesIO byte stream rather than a physical file. This can be used when
working with the workbook ``in_memory`` mode.

See :ref:`macros` for more details.


workbook.add_signed_vba_project()
---------------------------------

.. py:function:: add_signed_vba_project(vba_project,
                                        signature [,
                                        project_is_stream, [
                                        signature_is_stream ]]):

   Add a vbaProject binary and a vbaProjectSignature binary to the Excel workbook.

   :param      vba_project:         The vbaProject binary file name.
   :param      signature:           The vbaProjectSignature binary file name.
   :param bool project_is_stream:   The vba_project is an in memory byte stream.
   :param bool signature_is_stream: The signature is an in memory byte stream.

The ``add_signed_vba_project()`` method can be used to add digitally
signed macros or functions to a workbook. The method adds a binary VBA project
file and a binary VBA project signature file that have been extracted from an
existing Excel xlsm file with digitally signed macros:

    workbook.add_signed_vba_project('./vbaProject.bin', './vbaProjectSignature.bin')

Only one ``vbaProject.bin`` file can be added per workbook. The name doesn't
have to be ``vbaProject.bin``. Any suitable path/name for an existing VBA bin
file will do. The same applies for ``vbaProjectSignature.bin``.

The ``project_is_stream`` (``signature_is_stream``, resp.) parameter is used to indicate
that ``vba_project`` (``signature``, resp.) refers to a BytesIO byte stream rather than
a physical file. This can be used when working with the workbook ``in_memory`` mode.

See :ref:`macros` for more details.


workbook.set_vba_name()
-----------------------

.. py:function:: set_vba_name(name)

   Set the VBA name for the workbook.

   :param string name: The VBA name for the workbook.

The ``set_vba_name()`` method can be used to set the VBA codename for the
workbook. This is sometimes required when a vbaProject macro included via
``add_vba_project()`` refers to the workbook. The default Excel VBA name of
``ThisWorkbook`` is used if a user defined name isn't specified.

See :ref:`macros` for more details.


workbook.use_custom_theme()
---------------------------

.. py:function:: use_custom_theme(theme)

   Change the default workbook theme to a user defined custom theme.

   :param theme: The custom theme as a file path or StringIO object. The file
                 should be a valid Excel ``.thmx`` or ``.xlsx`` file or a
                 ``theme1.xml`` file extracted from an unzipped Excel xlsx file.
                 The ``StringIO`` object should contain the XML data of a valid
                 theme XML file.
   :type theme:  str, os.PathLike, or StringIO

   :raises IOError: If the theme file cannot be read.
   :raises ThemeFileError: If the theme file is invalid or contains unsupported features.
   :raises ValueError: If the theme parameter type is not supported.

Excel uses themes to define default fonts and colors for a workbook. The
XlsxWriter library uses the original "Office" theme with Calibri 11 as the
default font but, if required, the ``use_custom_theme()`` method can be used to
change to a custom, user-supplied, theme.

The theme file must be a valid Excel ``.thmx`` or ``.xlsx`` file or a theme XML
file extracted from an unzipped Excel xlsx file. This theme file is typically
located at ``xl/theme/theme1.xml``. Alternatively ``theme`` argument can be a
``StringIO`` object containing the XML data of a valid theme XML file.

In addition to supplying the theme XML file it is also necessary to set the
default format to match the theme. This is done via the constructor properties
``default_format_properties``, ``default_row_height``, and
``default_col_width``. When setting a font that will be used as the default
format it is also necessary to set the scheme parameter to ``minor``.

Note, older Excel 2007 style theme files that contain image fills as part of the
theme are not currently supported and will raise an :exc:`ThemeFileError`
exception on loading.


workbook.worksheets()
---------------------

.. py:function:: worksheets()

   Return a list of the worksheet objects in the workbook.

   :rtype: A list of :ref:`worksheet <Worksheet>` objects.

The ``worksheets()`` method returns a list of the worksheets in a workbook.
This is useful if you want to repeat an operation on each worksheet in a
workbook::

    for worksheet in workbook.worksheets():
        worksheet.write('A1', 'Hello')


workbook.get_worksheet_by_name()
--------------------------------

.. function:: get_worksheet_by_name(name)

   Return a worksheet object in the workbook using the sheetname.

   :param string name: Name of worksheet that you wish to retrieve.
   :rtype: A :ref:`worksheet <Worksheet>` object.

The ``get_worksheet_by_name()`` method returns the worksheet or chartsheet
object with the given ``name`` or ``None`` if it isn't found::

    worksheet = workbook.get_worksheet_by_name('Sheet1')


workbook.get_default_url_format()
---------------------------------

.. function:: get_default_url_format()

   Return a format object.

   :rtype: A :ref:`format <Format>` object.

The ``get_default_url_format()`` method gets a copy of the default url format
used when a user defined format isn't specified with :func:`write_url`. The
format is the hyperlink style defined by Excel for the default theme::

    url_format = workbook.get_default_url_format()


workbook.set_calc_mode()
------------------------

.. py:function:: set_calc_mode(mode)

   Set the Excel calculation mode for the workbook.

   :param string mode: The calculation mode string

Set the calculation mode for formulas in the workbook. This is mainly of use
for workbooks with slow formulas where you want to allow the user to calculate
them manually.

The ``mode`` parameter can be:

* ``auto``: The default. Excel will re-calculate formulas when a formula or a
  value affecting the formula changes.

* ``manual``: Only re-calculate formulas when the user requires it. Generally
  by pressing F9.

* ``auto_except_tables``: Excel will automatically re-calculate formulas
  except for tables.


workbook.use_zip64()
--------------------

.. py:function:: use_zip64()

   Allow ZIP64 extensions when writing the xlsx file zip container.

Use ZIP64 extensions when writing the xlsx file zip container to allow files
greater than 4 GB.

.. Note::

   When using the ``use_zip64()`` option the zip file created by the Python
   standard library ``zipfile.py`` may cause Excel to issue a warning about
   repairing the file. This warning is annoying but harmless. The "repaired"
   file will contain all of the data written by XlsxWriter, only the zip
   container will be changed.


workbook.read_only_recommended()
--------------------------------

.. py:function:: read_only_recommended()

   Add a recommendation to open the file in "read-only" mode.

This method can be used to set the Excel "Read-only Recommended" option that
is available when saving a file. This presents the user of the file with an
option to open it in "read-only" mode. This means that any changes to the file
can't be saved back to the same file and must be saved to a new file.  It can
be set as follows::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('file.xlsx')
    worksheet = workbook.add_worksheet()

    workbook.read_only_recommended()

    workbook.close()

Which will raise a dialog like the following when opening the file:

.. image:: _images/read_only.png

================
File: dev/docs/source/working_with_autofilters.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _working_with_autofilters:

Working with Autofilters
========================

An autofilter in Excel is a way of filtering a 2D range of data based on some
simple criteria.

.. image:: _images/autofilter1.png


Applying an autofilter
----------------------

The first step is to apply an autofilter to a cell range in a worksheet using
the :func:`autofilter` method::

    worksheet.autofilter('A1:D11')

As usual you can also use :ref:`Row-Column <cell_notation>` notation::

    worksheet.autofilter(0, 0, 10, 3)  # Same as above.


Filter data in an autofilter
----------------------------

The :func:`autofilter` defines the cell range that the filter applies to and
creates drop-down selectors in the heading row. In order to filter out data it
is necessary to apply some criteria to the columns using either the
:func:`filter_column()` or :func:`filter_column_list()` methods.

The ``filter_column`` method is used to filter columns in a autofilter range
based on simple criteria::

    worksheet.filter_column('A', 'x > 2000')
    worksheet.filter_column('B', 'x > 2000 and x < 5000')

It isn't sufficient to just specify the filter condition. You must also hide
any rows that don't match the filter condition. Rows are hidden using the
:func:`set_row()` ``hidden`` parameter. ``XlsxWriter`` cannot filter rows
automatically since this isn't part of the file format.

The following is an example of how you might filter a data range to match an
autofilter criteria::

    # Set the autofilter.
    worksheet.autofilter('A1:D51')

    # Add the filter criteria. The placeholder "Region" in the filter is
    # ignored and can be any string that adds clarity to the expression.
    worksheet.filter_column(0, 'Region == East')

    # Hide the rows that don't match the filter criteria.
    row = 1
    for row_data in (data):
        region = row_data[0]

        # Check for rows that match the filter.
        if region == 'East':
            # Row matches the filter, display the row as normal.
            pass
        else:
            # We need to hide rows that don't match the filter.
            worksheet.set_row(row, options={'hidden': True})

        worksheet.write_row(row, 0, row_data)

        # Move on to the next worksheet row.
        row += 1


Setting a filter criteria for a column
--------------------------------------

The :func:`filter_column` method can be used to filter columns in a autofilter
range based on simple conditions::

    worksheet.filter_column('A', 'x > 2000')

The ``column`` parameter can either be a zero indexed column number or a string
column name.

The following operators are available for setting the filter criteria::

    Operator
       ==
       !=
       >
       <
       >=
       <=

       and
       or

An expression can comprise a single statement or two statements separated by
the ``and`` and ``or`` operators. For example::

    'x <  2000'
    'x >  2000'
    'x == 2000'
    'x >  2000 and x <  5000'
    'x == 2000 or  x == 5000'

Filtering of blank or non-blank data can be achieved by using a value of
``Blanks`` or ``NonBlanks`` in the expression::

    'x == Blanks'
    'x == NonBlanks'

Excel also allows some simple string matching operations::

    'x == b*'      # begins with b
    'x != b*'      # doesn't begin with b
    'x == *b'      # ends with b
    'x != *b'      # doesn't end with b
    'x == *b*'     # contains b
    'x != *b*'     # doesn't contain b

You can also use ``'*'`` to match any character or number and ``'?'`` to match
any single character or number. No other regular expression quantifier is
supported by Excel's filters. Excel's regular expression characters can be
escaped using ``'~'``.

The placeholder variable ``x`` in the above examples can be replaced by any
simple string. The actual placeholder name is ignored internally so the
following are all equivalent::

    'x     < 2000'
    'col   < 2000'
    'Price < 2000'

A filter condition can only be applied to a column in a range specified by the
:func:`autofilter()` method.


Setting a column list filter
----------------------------

Prior to Excel 2007 it was only possible to have either 1 or 2 filter
conditions such as the ones shown above in the :func:`filter_column` method.

Excel 2007 introduced a new list style filter where it is possible to specify 1
or more 'or' style criteria. For example if your column contained data for the
months of the year you could filter the data based on certain months:

.. image:: _images/autofilter2.png


The :func:`filter_column_list()` method can be used to represent these types of
filters::

    worksheet.filter_column_list('A', ['March', 'April', 'May'])

One or more criteria can be selected::

    worksheet.filter_column_list('A', ['March'])
    worksheet.filter_column_list('B', [100, 110, 120, 130])

To filter blanks as part of the list use `Blanks` as a list item::

    worksheet.filter_column_list('A', ['March', 'April', 'May', 'Blanks'])

As explained above, it isn't sufficient to just specify filters. You must also
hide any rows that don't match the filter condition.


Example
-------

See :ref:`ex_autofilter` for a full example of all these features.

================
File: dev/docs/source/working_with_cell_comments.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _cell_comments:

Working with Cell Comments
==========================

Cell comments are a way of adding notation to cells in Excel. For example::

    worksheet.write('A1', 'Hello')
    worksheet.write_comment('A1', 'This is a comment')

.. image:: _images/comments1.png


Setting Comment Properties
--------------------------

The properties of the cell comment can be modified by passing an optional
dictionary of key/value pairs to control the format of the comment. For
example::

    worksheet.write_comment('C3', 'Hello', {'x_scale': 1.2, 'y_scale': 0.8})

The following options are available::

    author
    visible
    x_scale
    width
    y_scale
    height
    color
    font_name
    font_size
    start_cell
    start_row
    start_col
    x_offset
    y_offset

The options are explained in detail below:

* ``author``: This option is used to indicate who is the author of the cell
  comment. Excel displays the author of the comment in the status bar at the
  bottom of the worksheet. This is usually of interest in corporate
  environments where several people might review and provide comments to a
  workbook::

    worksheet.write_comment('C3', 'Atonement', {'author': 'Ian McEwan'})

  The default author for all cell comments in a worksheet can be set using
  the :func:`set_comments_author` method::

     worksheet.set_comments_author('John Smith')

* ``visible``: This option is used to make a cell comment visible when the
  worksheet is opened. The default behavior in Excel is that comments are
  initially hidden. However, it is also possible in Excel to make individual
  comments or all comments visible. In XlsxWriter individual comments can be
  made visible as follows::

    worksheet.write_comment('C3', 'Hello', {'visible': True})

  It is possible to make all comments in a worksheet visible using the
  :func:`show_comments()` worksheet method. Alternatively, if all of the cell
  comments have been made visible you can hide individual comments::

    worksheet.write_comment('C3', 'Hello', {'visible': False})

* ``x_scale``: This option is used to set the width of the cell comment box
  as a factor of the default width::

    worksheet.write_comment('C3', 'Hello', {'x_scale': 2  })
    worksheet.write_comment('C4', 'Hello', {'x_scale': 4.2})

* ``width``: This option is used to set the width of the cell comment box
  explicitly in pixels::

    worksheet.write_comment('C3', 'Hello', {'width': 200})

* ``y_scale``: This option is used to set the height of the cell comment box
  as a factor of the default height::

    worksheet.write_comment('C3', 'Hello', {'y_scale': 2  })
    worksheet.write_comment('C4', 'Hello', {'y_scale': 4.2})

* ``height``: This option is used to set the height of the cell comment box
  explicitly in pixels::

    worksheet.write_comment('C3', 'Hello', {'height': 200})

* ``color``: This option is used to set the background color of cell comment
  box. You can use one of the named colors recognized by XlsxWriter or a Html
  color. See :ref:`colors`::

    worksheet.write_comment('C3', 'Hello', {'color': 'green'  })
    worksheet.write_comment('C4', 'Hello', {'color': '#CCFFCC'})

* ``font_name``: This option is used to set the font for the comment::

    worksheet.write_comment('C3', 'Hello', {'font_name': 'Courier'})

  The default font is 'Tahoma'.

* ``font_size``: This option is used to set the font size for the comment::

    worksheet.write_comment('C3', 'Hello', {'font_size': 10})

  The  default font size is 8.

* ``start_cell``: This option is used to set the cell in which the comment
  will appear. By default Excel displays comments one cell to the right and
  one cell above the cell to which the comment relates. However, you can
  change this behavior if you wish. In the following example the comment
  which would appear by default in cell ``D2`` is moved to ``E2``::

    worksheet.write_comment('C3', 'Hello', {'start_cell': 'E2'})

* ``start_row``: This option is used to set the row in which the comment will
  appear. See the ``start_cell`` option above. The row is zero indexed::

    worksheet.write_comment('C3', 'Hello', {'start_row': 0})

* ``start_col``: This option is used to set the column in which the comment
  will appear. See the ``start_cell`` option above. The column is zero
  indexed::

    worksheet.write_comment('C3', 'Hello', {'start_col': 4})

* ``x_offset``: This option is used to change the x offset, in pixels, of a
  comment within a cell::

    worksheet.write_comment('C3', comment, {'x_offset': 30})

* ``y_offset``: This option is used to change the y offset, in pixels, of a
  comment within a cell::

    worksheet.write_comment('C3', comment, {'y_offset': 30})


You can apply as many of these options as you require. For a working example of
these options in use see :ref:`ex_comments2`.

.. Note::
   Excel only displays offset cell comments when they are displayed as
   ``visible``. Excel does **not** display hidden cells as displaced
   when you mouse over them. Please note this when using options that adjust
   the position of the cell comment such as ``start_cell``, ``start_row``,
   ``start_col``, ``x_offset`` and ``y_offset``.

.. Note::
   **Row height and comments**. If you specify the height of a row that
   contains a comment then XlsxWriter will adjust the height of the comment
   to maintain the default or user specified dimensions. However, the height
   of a row can also be adjusted automatically by Excel if the text wrap
   property is set or large fonts are used in the cell. This means that
   the height of the row is unknown to the module at run time and thus
   the comment box is stretched with the row. Use the ``set_row()`` method
   to specify the row height explicitly and avoid this problem. See example 8
   of :ref:`ex_comments2`.

================
File: dev/docs/source/working_with_cell_notation.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _cell_notation:

Working with Cell Notation
==========================

XlsxWriter supports two forms of notation to designate the position of cells:
**Row-column** notation and **A1** notation.

Row-column notation uses a zero based index for both row and column while A1
notation uses the standard Excel alphanumeric sequence of column letter and
1-based row. For example::


    (0, 0)      # Row-column notation.
    ('A1')      # The same cell in A1 notation.

    (6, 2)      # Row-column notation.
    ('C7')      # The same cell in A1 notation.

Row-column notation is useful if you are referring to cells programmatically::

    for row in range(0, 5):
        worksheet.write(row, 0, 'Hello')

A1 notation is useful for setting up a worksheet manually and for working with
formulas::

    worksheet.write('H1', 200)
    worksheet.write('H2', '=H1+1')

In general when using the XlsxWriter module you can use A1 notation anywhere
you can use row-column notation. This also applies to methods that take a
range of cells::

    worksheet.merge_range(2, 1, 3, 3, 'Merged Cells', merge_format)
    worksheet.merge_range('B3:D4',    'Merged Cells', merge_format)

XlsxWriter supports Excel's worksheet limits of 1,048,576 rows by 16,384
columns.

.. note::
   * Ranges in A1 notation must be in uppercase, like in Excel.

   * In Excel it is also possible to use R1C1 notation. This is not
     supported by XlsxWriter.


.. _full_row_col:

Row and Column Ranges
---------------------

In Excel you can specify row or column ranges such as ``1:1`` for all of the
first row or ``A:A`` for all of the first column. In XlsxWriter these can be
set by specifying the full cell range for the row or column::

    worksheet.print_area('A1:XFD1')      # Same as 1:1
    worksheet.print_area('A1:A1048576')  # Same as A:A

This is actually how Excel stores ranges such as ``1:1`` and ``A:A``
internally.

These ranges can also be specified using row-column notation, as explained
above::

    worksheet.print_area(0, 0,       0, 16383)  # Same as 1:1
    worksheet.print_area(0, 0, 1048575,     0)  # Same as A:A

To select the entire worksheet range you can specify
``A1:XFD1048576``.


.. _abs_reference:

Relative and Absolute cell references
-------------------------------------

When dealing with Excel cell references it is important to distinguish between
relative and absolute cell references in Excel.

**Relative** cell references change when they are copied while **Absolute**
references maintain fixed row and/or column references. In Excel absolute
references are prefixed by the dollar symbol as shown below::

    'A1'    # Column and row are relative.
    '$A1'   # Column is absolute and row is relative.
    'A$1'   # Column is relative and row is absolute.
    '$A$1'  # Column and row are absolute.

See the Microsoft Office documentation for
`more information on relative and absolute references <https://support.microsoft.com/en-us/office/switch-between-relative-absolute-and-mixed-references-dfec08cd-ae65-4f56-839e-5f0d8d0baca9>`_.

Some functions such as :func:`conditional_format()` may require absolute
references, depending on the range being specified.


Defined Names and Named Ranges
------------------------------

It is also possible to define and use "Defined names/Named ranges" in
workbooks and worksheets, see :func:`define_name`::

    workbook.define_name('Exchange_rate', '=0.96')
    worksheet.write('B3', '=B2*Exchange_rate')

See also :ref:`ex_defined_name`.


.. _cell_utility:

Cell Utility Functions
----------------------

The :func:`XlsxWriter`` ``utility`` module contains several helper functions for
dealing with A1 notation as shown below. These functions can be imported as
follows::

    from xlsxwriter.utility import xl_rowcol_to_cell

    cell = xl_rowcol_to_cell(1, 2)  # C2

See the documentation for :ref:`utility` for more details.


xl_rowcol_to_cell()
~~~~~~~~~~~~~~~~~~~

The :func:`xl_rowcol_to_cell` function converts a zero indexed row and column
cell values to an ``A1`` style string::

    cell = xl_rowcol_to_cell(0, 0)   # A1
    cell = xl_rowcol_to_cell(0, 1)   # B1
    cell = xl_rowcol_to_cell(1, 0)   # A2

The optional parameters ``row_abs`` and ``col_abs`` can be used to indicate
that the row or column is absolute::

    str = xl_rowcol_to_cell(0, 0, col_abs=True)                # $A1
    str = xl_rowcol_to_cell(0, 0, row_abs=True)                # A$1
    str = xl_rowcol_to_cell(0, 0, row_abs=True, col_abs=True)  # $A$1


xl_cell_to_rowcol()
~~~~~~~~~~~~~~~~~~~

The :func:`xl_cell_to_rowcol` function converts an Excel cell reference in ``A1``
notation to a zero based row and column. The function will also handle Excel's
absolute, ``$``, cell notation::

    (row, col) = xl_cell_to_rowcol('A1')    # (0, 0)
    (row, col) = xl_cell_to_rowcol('B1')    # (0, 1)
    (row, col) = xl_cell_to_rowcol('C2')    # (1, 2)
    (row, col) = xl_cell_to_rowcol('$C2')   # (1, 2)
    (row, col) = xl_cell_to_rowcol('C$2')   # (1, 2)
    (row, col) = xl_cell_to_rowcol('$C$2')  # (1, 2)


xl_col_to_name()
~~~~~~~~~~~~~~~~

The :func:`xl_col_to_name` converts a zero based column reference to a string::

    column = xl_col_to_name(0)    # A
    column = xl_col_to_name(1)    # B
    column = xl_col_to_name(702)  # AAA

The optional parameter ``col_abs`` can be used to indicate if the column is
absolute::

    column = xl_col_to_name(0, False)  # A
    column = xl_col_to_name(0, True)   # $A
    column = xl_col_to_name(1, True)   # $B


xl_range()
~~~~~~~~~~

The :func:`xl_range` function converts zero based row and column cell references
to an ``A1:B1`` style range string::

    cell_range = xl_range(0, 0, 9, 0)  # A1:A10
    cell_range = xl_range(1, 2, 8, 2)  # C2:C9
    cell_range = xl_range(0, 0, 3, 4)  # A1:E4
    cell_range = xl_range(0, 0, 0, 0)  # A1


xl_range_abs()
~~~~~~~~~~~~~~

The :func:`xl_range_abs` function converts zero based row and column cell
references to an absolute ``$A$1:$B$1`` style range string::

    cell_range = xl_range_abs(0, 0, 9, 0)  # $A$1:$A$10
    cell_range = xl_range_abs(1, 2, 8, 2)  # $C$2:$C$9
    cell_range = xl_range_abs(0, 0, 3, 4)  # $A$1:$E$4
    cell_range = xl_range_abs(0, 0, 0, 0)  # $A$1

================
File: dev/docs/source/working_with_charts.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _working_with_charts:

Working with Charts
===================

This section explains how to work with some of the options and features of
:ref:`chart_class`.

The majority of the examples in this section are based on a variation of the
following program::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('chart_line.xlsx')
    worksheet = workbook.add_worksheet()

    # Add the worksheet data to be plotted.
    data = [10, 40, 50, 20, 10, 50]
    worksheet.write_column('A1', data)

    # Create a new chart object.
    chart = workbook.add_chart({'type': 'line'})

    # Add a series to the chart.
    chart.add_series({'values': '=Sheet1!$A$1:$A$6'})

    # Insert the chart into the worksheet.
    worksheet.insert_chart('C1', chart)

    workbook.close()

.. image:: _images/chart_working.png

See also :ref:`chart_examples`.

.. _chart_val_cat_axes:

Chart Value and Category Axes
-----------------------------


When working with charts it is important to understand how Excel
differentiates between a chart axis that is used for series categories and a
chart axis that is used for series values.

In the majority of Excel charts the X axis is the **category** axis and each
of the values is evenly spaced and sequential. The Y axis is the **value**
axis and points are displayed according to their value:

.. image:: _images/chart_axes01.png

Excel treats these two types of axis differently and exposes different
properties for each. For example, here are the properties for a category axis:

.. image:: _images/chart_axes02.png

Here are properties for a value axis:

.. image:: _images/chart_axes03.png

As such, some of the `XlsxWriter` axis properties can be set for a value
axis, some can be set for a category axis and some properties can be set for
both. For example ``reverse`` can be set for either category or value axes while the
``min`` and ``max`` properties can only be set for value axes (and Date Axes).
The documentation calls out the type of axis to which properties apply.

For a Bar chart the Category and Value axes are reversed:

.. image:: _images/chart_axes04.png

A Scatter chart (but not a Line chart) has 2 value axes:

.. image:: _images/chart_axes05.png

:ref:`date_category_axes` are a special type of category axis that give them
some of the properties of values axes such as ``min`` and ``max`` when used
with date or time values.

.. _chart_series_options:

Chart Series Options
--------------------

This following sections detail the more complex options of the
:func:`add_series()` Chart method::

    marker
    trendline
    y_error_bars
    x_error_bars
    data_labels
    points
    smooth


.. _chart_series_option_marker:

Chart series option: Marker
---------------------------

The marker format specifies the properties of the markers used to distinguish
series on a chart. In general only Line and Scatter chart types and trendlines
use markers.

The following properties can be set for ``marker`` formats in a chart::

    type
    size
    border
    fill
    pattern
    gradient

The ``type`` property sets the type of marker that is used with a series::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'marker': {'type': 'diamond'},
    })

.. image:: _images/chart_marker1.png
   :scale: 75 %

The following ``type`` properties can be set for ``marker`` formats in a chart.
These are shown in the same order as in the Excel format dialog::

    automatic
    none
    square
    diamond
    triangle
    x
    star
    short_dash
    long_dash
    circle
    plus

The ``automatic`` type is a special case which turns on a marker using the
default marker style for the particular series number::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'marker': {'type': 'automatic'},
    })

If ``automatic`` is on then other marker properties such as size, border or
fill cannot be set.

The ``size`` property sets the size of the marker and is generally used in
conjunction with ``type``::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'marker': {'type': 'diamond', 'size': 7},
    })

Nested ``border`` and ``fill`` properties can also be set for a marker::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'marker': {
            'type': 'square',
            'size': 8,
            'border': {'color': 'black'},
            'fill':   {'color': 'red'},
        },
    })

.. image:: _images/chart_marker2.png
   :scale: 75 %

.. _chart_series_option_trendline:

Chart series option: Trendline
------------------------------

A trendline can be added to a chart series to indicate trends in the data such
as a moving average or a polynomial fit.

The following properties can be set for trendlines in a chart series::

    type
    order               (for polynomial trends)
    period              (for moving average)
    forward             (for all except moving average)
    backward            (for all except moving average)
    name
    line
    intercept           (for exponential, linear and polynomial only)
    display_equation    (for all except moving average)
    display_r_squared   (for all except moving average)

The ``type`` property sets the type of trendline in the series::

    chart.add_series({
        'values':    '=Sheet1!$A$1:$A$6',
        'trendline': {'type': 'linear'},
    })

The available ``trendline`` types are::

    exponential
    linear
    log
    moving_average
    polynomial
    power

A ``polynomial`` trendline can also specify the ``order`` of the polynomial.
The default value is 2::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'trendline': {
            'type': 'polynomial',
            'order': 3,
        },
    })

.. image:: _images/chart_trendline1.png
   :scale: 75 %

A ``moving_average`` trendline can also specify the ``period`` of the moving
average. The default value is 2::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'trendline': {
            'type': 'moving_average',
            'period': 2,
        },
    })


.. image:: _images/chart_trendline2.png
   :scale: 75 %

The ``forward`` and ``backward`` properties set the forecast period of the
trendline::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'trendline': {
            'type': 'polynomial',
            'order': 2,
            'forward': 0.5,
            'backward': 0.5,
        },
    })

The ``name`` property sets an optional name for the trendline that will appear
in the chart legend. If it isn't specified the Excel default name will be
displayed. This is usually a combination of the trendline type and the series
name::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'trendline': {
            'type': 'polynomial',
            'name': 'My trend name',
            'order': 2,
        },
    })


The ``intercept`` property sets the point where the trendline crosses the Y
(value) axis::

    chart.add_series({
        'values': '=Sheet1!$B$1:$B$6',
        'trendline': {'type': 'linear',
                      'intercept': 0.8,
        },
    })


The ``display_equation`` property displays the trendline equation on the
chart::

    chart.add_series({
        'values': '=Sheet1!$B$1:$B$6',
        'trendline': {'type': 'linear',
                      'display_equation': True,
        },
    })

The ``display_r_squared`` property displays the R squared value of the
trendline on the chart::

    chart.add_series({
        'values': '=Sheet1!$B$1:$B$6',
        'trendline': {'type': 'linear',
                      'display_r_squared': True,
        },
    })

Several of these properties can be set in one go::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'trendline': {
            'type': 'polynomial',
            'name': 'My trend name',
            'order': 2,
            'forward': 0.5,
            'backward': 0.5,
            'display_equation': True,
            'line': {
                'color': 'red',
                'width': 1,
                'dash_type': 'long_dash',
            },
        },
    })

.. image:: _images/chart_trendline3.png
   :scale: 75 %

Trendlines cannot be added to series in a stacked chart or pie chart, doughnut
chart, radar chart or (when implemented) to 3D or surface charts.


.. _chart_series_option_error_bars:

Chart series option: Error Bars
-------------------------------

Error bars can be added to a chart series to indicate error bounds in the data.
The error bars can be vertical ``y_error_bars`` (the most common type) or
horizontal ``x_error_bars`` (for Bar and Scatter charts only).

The following properties can be set for error bars in a chart series::

    type
    value        (for all types except standard error and custom)
    plus_values  (for custom only)
    minus_values (for custom only)
    direction
    end_style
    line

The ``type`` property sets the type of error bars in the series::

    chart.add_series({
        'values':       '=Sheet1!$A$1:$A$6',
        'y_error_bars': {'type': 'standard_error'},
    })

.. image:: _images/chart_error_bars1.png
   :scale: 75 %

The available error bars types are available::

    fixed
    percentage
    standard_deviation
    standard_error
    custom

All error bar types, except for ``standard_error`` and ``custom`` must also
have a value associated with it for the error bounds::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'y_error_bars': {
            'type': 'percentage',
            'value': 5,
        },
    })

The ``custom`` error bar type must specify ``plus_values`` and ``minus_values``
which should either by a ``Sheet1!$A$1:$A$6`` type range formula or a list of
values::

     chart.add_series({
         'categories': '=Sheet1!$A$1:$A$6',
         'values':     '=Sheet1!$B$1:$B$6',
         'y_error_bars': {
             'type':         'custom',
             'plus_values':  '=Sheet1!$C$1:$C$6',
             'minus_values': '=Sheet1!$D$1:$D$6',
         },
     })

     # or

     chart.add_series({
         'categories': '=Sheet1!$A$1:$A$6',
         'values':     '=Sheet1!$B$1:$B$6',
         'y_error_bars': {
             'type':         'custom',
             'plus_values':  [1, 1, 1, 1, 1],
             'minus_values': [2, 2, 2, 2, 2],
         },
     })

Note, as in Excel the items in the ``minus_values`` do not need to be negative.

The ``direction`` property sets the direction of the error bars. It should be
one of the following::

    plus   # Positive direction only.
    minus  # Negative direction only.
    both   # Plus and minus directions, The default.

The ``end_style`` property sets the style of the error bar end cap. The options
are 1 (the default) or 0 (for no end cap)::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'y_error_bars': {
            'type': 'fixed',
            'value': 2,
            'end_style': 0,
            'direction': 'minus'
        },
    })

.. image:: _images/chart_error_bars2.png
   :scale: 75 %


.. _chart_series_option_data_labels:

Chart series option: Data Labels
--------------------------------

Data labels can be added to a chart series to indicate the values of the
plotted data points.

The following properties can be set for ``data_labels`` formats in a chart::

    value
    category
    series_name
    position
    leader_lines
    percentage
    separator
    legend_key
    num_format
    font
    border
    fill
    pattern
    gradient
    custom

The ``value`` property turns on the *Value* data label for a series::

    chart.add_series({
        'values':      '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True},
    })

.. image:: _images/chart_data_labels1.png
   :scale: 75 %


By default data labels are displayed in Excel with only the values
shown. However, it is possible to configure other display options, as shown
below.

.. image:: _images/chart_data_labels2.png

The ``category`` property turns on the *Category Name* data label for a series::

    chart.add_series({
        'values':      '=Sheet1!$A$1:$A$6',
        'data_labels': {'category': True},
    })

The ``series_name`` property turns on the *Series Name* data label for a
series::

    chart.add_series({
        'values':      '=Sheet1!$A$1:$A$6',
        'data_labels': {'series_name': True},
    })


Here is an example with all three data label types shown:

.. image:: _images/chart_data_labels3.png
   :scale: 75 %


The ``position`` property is used to position the data label for a series,
relative to the data point::

    chart.add_series({
        'values':      '=Sheet1!$A$1:$A$6',
        'data_labels': {'series_name': True, 'position': 'above'},
    })

.. image:: _images/chart_data_labels5.png
   :scale: 75 %

In Excel the allowable data label positions vary for different chart types.
The allowable positions are:

+-------------+----------+--------+----------+-------+
| Position    | Line,    | Bar,   | Pie,     | Area, |
|             | Scatter, | Column | Doughnut | Radar |
|             | Stock    |        |          |       |
+=============+==========+========+==========+=======+
| center      | Yes      | Yes    | Yes      | Yes*  |
+-------------+----------+--------+----------+-------+
| right       | Yes*     |        |          |       |
+-------------+----------+--------+----------+-------+
| left        | Yes      |        |          |       |
+-------------+----------+--------+----------+-------+
| above       | Yes      |        |          |       |
+-------------+----------+--------+----------+-------+
| below       | Yes      |        |          |       |
+-------------+----------+--------+----------+-------+
| inside_base |          | Yes    |          |       |
+-------------+----------+--------+----------+-------+
| inside_end  |          | Yes    | Yes      |       |
+-------------+----------+--------+----------+-------+
| outside_end |          | Yes*   | Yes      |       |
+-------------+----------+--------+----------+-------+
| best_fit    |          |        | Yes*     |       |
+-------------+----------+--------+----------+-------+

Note: The * indicates the default position for each chart type in Excel, if
a position isn't specified by the user.

The ``percentage`` property is used to turn on the display of data labels as a
*Percentage* for a series. In Excel the ``percentage`` data label option is
only available for Pie and Doughnut chart variants::

    chart.add_series({
        'values':      '=Sheet1!$A$1:$A$6',
        'data_labels': {'percentage': True},
    })

.. image:: _images/chart_data_labels7.png
   :scale: 75 %

The ``leader_lines`` property is used to turn on *Leader Lines* for the data
label of a series::

    chart.add_series({
        'values':      '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True, 'leader_lines': True},
    })

.. Note::
  Even when leader lines are turned on they aren't automatically visible in
  Excel or XlsxWriter. Due to an Excel limitation (or design) leader lines
  only appear if the data label is moved manually or if the data labels are
  very close and need to be adjusted automatically.

The ``separator`` property is used to change the separator between multiple
data label items::

    chart.add_series({
        'values':      '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True, 'category': True,
                        'series_name': True, 'separator': "\n"},
    })

.. image:: _images/chart_data_labels4.png
   :scale: 75 %

The separator value must be one of the following strings::

            ','
            ';'
            '.'
            '\n'
            ' '

The ``legend_key`` property is used to turn on the *Legend Key* for the data
label of a series::

    chart.add_series({
        'values':      '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True, 'legend_key': True},
    })

.. image:: _images/chart_data_labels6.png
   :scale: 75 %

The ``num_format`` property is used to set the number format for the data
labels of a series::

     chart.add_series({
         'values':      '=Sheet1!$A$1:$A$6',
         'data_labels': {'value': True, 'num_format': '#,##0.00'},
     })

.. image:: _images/chart_data_labels8.png
   :scale: 75 %

The number format is similar to the Worksheet Cell Format ``num_format``
apart from the fact that a format index cannot be used. An explicit format
string must be used as shown above. See :func:`set_num_format()` for more
information.

The ``font`` property is used to set the font of the data labels of a series::

     chart.add_series({
         'values': '=Sheet1!$A$1:$A$6',
         'data_labels': {
             'value': True,
             'font': {'name': 'Consolas', 'color': 'red'}
         },
     })

.. image:: _images/chart_data_labels9.png
   :scale: 75 %


The ``font`` property is also used to rotate the data labels of a series::

     chart.add_series({

         'values': '=Sheet1!$A$1:$A$6',
         'data_labels': {
             'value': True,
             'font': {'rotation': 45}
         },
     })

See :ref:`chart_fonts`.

Standard chart formatting such as ``border`` and ``fill`` can also be added to
the data labels::

    chart.add_series({
        'values':     '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True,
                        'border': {'color': 'red'},
                        'fill':   {'color': 'yellow'}},
    })

.. image:: _images/chart_data_labels24.png
   :scale: 75 %

The ``custom`` property is used to set properties for individual data
labels. This is explained in detail in the next section.

.. _chart_series_option_custom_data_labels:

Chart series option: Custom Data Labels
---------------------------------------

The ``custom`` data label property is used to set the properties of individual
data labels in a series. The most common use for this is to set custom text or
number labels::

    custom_labels = [
        {'value': 'Jan'},
        {'value': 'Feb'},
        {'value': 'Mar'},
        {'value': 'Apr'},
        {'value': 'May'},
        {'value': 'Jun'},
    ]

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True, 'custom': custom_labels},
    })

.. image:: _images/chart_data_labels18.png
   :scale: 75 %

As shown in the previous examples th ``custom`` property should be a list of
dicts. Any property dict that is set to ``None`` or not included in the list
will be assigned the default data label value::

    custom_labels = [
        None,
        {'value': 'Feb'},
        {'value': 'Mar'},
        {'value': 'Apr'},
    ]

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True, 'custom': custom_labels},
    })

.. image:: _images/chart_data_labels19.png
   :scale: 75 %

The property elements of the ``custom`` lists should be dicts with the
following allowable keys/sub-properties::

    value
    font
    position
    delete

The ``value`` property should be a string, number or formula string that refers to
a cell from which the value will be taken::

    custom_labels = [
        {'value': '=Sheet1!$C$1'},
        {'value': '=Sheet1!$C$2'},
        {'value': '=Sheet1!$C$3'},
        {'value': '=Sheet1!$C$4'},
        {'value': '=Sheet1!$C$5'},
        {'value': '=Sheet1!$C$6'},
    ]

The ``font`` property is used to set the font of the custom data label of a series::

    custom_labels = [
        {'value': '=Sheet1!$C$1', 'font': {'color': 'red'}},
        {'value': '=Sheet1!$C$2', 'font': {'color': 'red'}},
        {'value': '=Sheet1!$C$3', 'font': {'color': 'red'}},
        {'value': '=Sheet1!$C$4', 'font': {'color': 'red'}},
        {'value': '=Sheet1!$C$5', 'font': {'color': 'red'}},
        {'value': '=Sheet1!$C$6', 'font': {'color': 'red'}},
    ]

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True, 'custom': custom_labels},
    })

See :ref:`chart_fonts` for details on the available font properties.

.. image:: _images/chart_data_labels20.png
   :scale: 75 %

The ``position`` property is used to position the custom data label, such as
"center" or "right". See the ``position`` property for series data labels above.

The ``delete`` property can be used to delete labels in a series. This can be
useful if you want to highlight one or more cells in the series, for example
the maximum and the minimum::

    custom_labels = [
        None,
        {'delete': True},
        {'delete': True},
        {'delete': True},
        {'delete': True},
        None,
    ]

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'data_labels': {'value': True, 'custom': custom_labels},
    })

.. image:: _images/chart_data_labels21.png
   :scale: 75 %

Standard chart formatting such as ``border`` and ``fill`` can also be added to
the custom data labels::

    custom_labels = [
        {'value': 'Jan', 'border': {'color': 'blue'}},
        {'value': 'Feb'},
        {'value': 'Mar'},
        {'value': 'Apr'},
        {'value': 'May'},
        {'value': 'Jun', 'fill':   {'color': 'green'}},
    ]

    chart.add_series({
        'values':     '=Sheet1!$A$1:$A$6',
        'marker': {'type': 'circle'},
        'data_labels': {'value': True,
                        'custom': custom_labels,
                        'border': {'color': 'red'},
                        'fill':   {'color': 'yellow'}},
    })

.. image:: _images/chart_data_labels25.png
   :scale: 75 %


.. _chart_series_option_points:

Chart series option: Points
---------------------------

In general formatting is applied to an entire series in a chart. However, it
is occasionally required to format individual points in a series. In
particular this is required for Pie/Doughnut charts where each segment is
represented by a point.

In these cases it is possible to use the ``points`` property of
:func:`add_series()`::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('chart_pie.xlsx')

    worksheet = workbook.add_worksheet()
    chart = workbook.add_chart({'type': 'pie'})

    data = [
        ['Pass', 'Fail'],
        [90, 10],
    ]

    worksheet.write_column('A1', data[0])
    worksheet.write_column('B1', data[1])

    chart.add_series({
        'categories': '=Sheet1!$A$1:$A$2',
        'values':     '=Sheet1!$B$1:$B$2',
        'points': [
            {'fill': {'color': 'green'}},
            {'fill': {'color': 'red'}},
        ],
    })

    worksheet.insert_chart('C3', chart)

    workbook.close()

.. image:: _images/chart_points1.png
   :scale: 75 %

The ``points`` property takes a list of format options (see the "Chart
Formatting" section below). To assign default properties to points in a series
pass ``None`` values in the array ref::

    # Format point 3 of 3 only.
    chart.add_series({
        'values': '=Sheet1!A1:A3',
        'points': [
            None,
            None,
            {'fill': {'color': '#990000'}},
        ],
    })

    # Format point 1 of 3 only.
    chart.add_series({
        'values': '=Sheet1!A1:A3',
        'points': [
            {'fill': {'color': '#990000'}},
        ],
    })


Chart series option: Smooth
---------------------------

The ``smooth`` option is used to set the smooth property of a line series. It
is only applicable to the ``line`` and ``scatter`` chart types::

    chart.add_series({
        'categories': '=Sheet1!$A$1:$A$6',
        'values':     '=Sheet1!$B$1:$B$6',
        'smooth':     True,
    })


.. _chart_formatting:

Chart Formatting
----------------

The following chart formatting properties can be set for any chart object that
they apply to (and that are supported by XlsxWriter) such as chart lines,
column fill areas, plot area borders, markers, gridlines and other chart
elements::

    line
    border
    fill
    pattern
    gradient

Chart formatting properties are generally set using dicts::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'line':   {'color': 'red'},
    })

.. image:: _images/chart_formatting1.png
   :scale: 75 %

In some cases the format properties can be nested. For example a ``marker`` may
contain ``border`` and ``fill`` sub-properties::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'line':   {'color': 'blue'},
        'marker': {'type': 'square',
                   'size': 5,
                   'border': {'color': 'red'},
                   'fill':   {'color': 'yellow'}
        },
    })

.. image:: _images/chart_formatting2.png
   :scale: 75 %


.. _chart_formatting_line:

Chart formatting: Line
----------------------

The line format is used to specify properties of line objects that appear in a
chart such as a plotted line on a chart or a border.

The following properties can be set for ``line`` formats in a chart::

    none
    color
    width
    dash_type
    transparency

The ``none`` property is used to turn the ``line`` off (it is always on by
default except in Scatter charts). This is useful if you wish to plot a series
with markers but without a line::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'line':   {'none': True},
        'marker': {'type': 'automatic'},
    })

.. image:: _images/chart_formatting3.png
   :scale: 75 %



The ``color`` property can be a :ref:`Color() <Color>` instance, a HTML style
``#RRGGBB`` string or a limited number of named colors, see :ref:`colors`.

Example::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'line':   {'color': '#FF0000'},
    })

    # Or:

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'line':   {'color': Color('#FF9900')},
    })

.. image:: _images/chart_formatting4.png
   :scale: 75 %


The ``width`` property sets the width of the ``line``. It should be specified
in increments of 0.25 of a point as in Excel::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'line':   {'width': 3.25},
    })


The ``dash_type`` property sets the dash style of the line::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'line':   {'dash_type': 'dash_dot'},
    })

.. image:: _images/chart_formatting5.png
   :scale: 75 %

The following ``dash_type`` values are available. They are shown in the order
that they appear in the Excel dialog::

    solid
    round_dot
    square_dot
    dash
    dash_dot
    long_dash
    long_dash_dot
    long_dash_dot_dot

The default line style is ``solid``.

The ``transparency`` property sets the transparency of the line color in the
integer range 1 - 100. The color must be set for transparency to work, it
doesn't work with an automatic/default color::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'line':   {'color': 'yellow', 'transparency': 50},
    })

More than one ``line`` property can be specified at a time::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
         'line': {
             'color': 'red',
             'width': 1.25,
             'dash_type': 'square_dot',
         },
    })


.. _chart_formatting_border:

Chart formatting: Border
------------------------

The ``border`` property is a synonym for ``line``.

It can be used as a descriptive substitute for ``line`` in chart types such as
Bar and Column that have a border and fill style rather than a line style. In
general chart objects with a ``border`` property will also have a fill
property.


.. _chart_formatting_fill:

Chart formatting: Solid Fill
----------------------------

The solid fill format is used to specify filled areas of chart objects such as
the interior of a column or the background of the chart itself.

The following properties can be set for ``fill`` formats in a chart::

    none
    color
    transparency

The ``none`` property is used to turn the ``fill`` property off (it is
generally on by default)::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'fill':   {'none': True},
        'border': {'color': 'black'}
    })

.. image:: _images/chart_fill1.png
   :scale: 75 %

The ``color`` property sets the color of the ``fill`` area::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'fill':   {'color': 'red'}
    })


The available colors are shown in the main XlsxWriter documentation. It is
also possible to set the color of a fill with a Html style ``#RRGGBB`` string
or a limited number of named colors, see :ref:`colors`::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'fill':   {'color': '#FF9900'}
    })

.. image:: _images/chart_fill2.png
   :scale: 75 %


The ``transparency`` property sets the transparency of the solid fill color in
the integer range 1 - 100. The color must be set for transparency to work, it
doesn't work with an automatic/default color::

    chart.set_chartarea({'fill': {'color': 'yellow', 'transparency': 50}})

.. image:: _images/chart_fill3.png
   :scale: 75 %


The ``fill`` format is generally used in conjunction with a ``border`` format
which has the same properties as a ``line`` format::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'fill':   {'color': 'red'},
        'border': {'color': 'black'}
    })

.. image:: _images/chart_fill4.png
   :scale: 75 %

.. _chart_formatting_pattern:

Chart formatting: Pattern Fill
------------------------------

The pattern fill format is used to specify pattern filled areas of chart
objects such as the interior of a column or the background of the chart
itself.

.. image:: _images/chart_pattern.png
   :scale: 75 %

The following properties can be set for ``pattern`` fill formats in a chart::

    pattern:   the pattern to be applied (required)
    fg_color:  the foreground color of the pattern (required)
    bg_color:  the background color (optional, defaults to white)


For example::

    chart.set_plotarea({
        'pattern': {
            'pattern': 'percent_5',
            'fg_color': 'red',
            'bg_color': 'yellow',
        }
    })

The following patterns can be applied:

* ``percent_5``
* ``percent_10``
* ``percent_20``
* ``percent_25``
* ``percent_30``
* ``percent_40``
* ``percent_50``
* ``percent_60``
* ``percent_70``
* ``percent_75``
* ``percent_80``
* ``percent_90``
* ``light_downward_diagonal``
* ``light_upward_diagonal``
* ``dark_downward_diagonal``
* ``dark_upward_diagonal``
* ``wide_downward_diagonal``
* ``wide_upward_diagonal``
* ``light_vertical``
* ``light_horizontal``
* ``narrow_vertical``
* ``narrow_horizontal``
* ``dark_vertical``
* ``dark_horizontal``
* ``dashed_downward_diagonal``
* ``dashed_upward_diagonal``
* ``dashed_horizontal``
* ``dashed_vertical``
* ``small_confetti``
* ``large_confetti``
* ``zigzag``
* ``wave``
* ``diagonal_brick``
* ``horizontal_brick``
* ``weave``
* ``plaid``
* ``divot``
* ``dotted_grid``
* ``dotted_diamond``
* ``shingle``
* ``trellis``
* ``sphere``
* ``small_grid``
* ``large_grid``
* ``small_check``
* ``large_check``
* ``outlined_diamond``
* ``solid_diamond``


The foreground color, ``fg_color``, is a required parameter and can be a Html
style ``#RRGGBB`` string or a limited number of named colors, see
:ref:`colors`.

The background color, ``bg_color``, is optional and defaults to white.

If a pattern fill is used on a chart object it overrides the solid fill
properties of the object.


.. _chart_formatting_gradient:

Chart formatting: Gradient Fill
-------------------------------

The gradient fill format is used to specify gradient filled areas of chart
objects such as the interior of a column or the background of the chart
itself.

.. image:: _images/chart_gradient.png
   :scale: 75 %

The following properties can be set for ``gradient`` fill formats in a chart::

    colors:    a list of colors
    positions: an optional list of positions for the colors
    type:      the optional type of gradient fill
    angle:     the optional angle of the linear fill

The ``colors`` property sets a list of colors that define the ``gradient``::

    chart.set_plotarea({
        'gradient': {'colors': ['#FFEFD1', '#F0EBD5', '#B69F66']}
    })

Excel allows between 2 and 10 colors in a gradient but it is unlikely that
you will require more than 2 or 3.

As with solid or pattern fill it is also possible to set the colors of a
gradient with a Html style ``#RRGGBB`` string or a limited number of named
colors, see :ref:`colors`::

    chart.add_series({
        'values':   '=Sheet1!$A$1:$A$6',
        'gradient': {'colors': ['red', 'green']}
    })

The ``positions`` defines an optional list of positions, between 0 and 100, of
where the colors in the gradient are located. Default values are provided for
``colors`` lists of between 2 and 4 but they can be specified if required::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'gradient': {
            'colors':    ['#DDEBCF', '#156B13'],
            'positions': [10,        90],
        }
    })


The ``type`` property can have one of the following values::

    linear        (the default)
    radial
    rectangular
    path

For example::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'gradient': {
            'colors': ['#DDEBCF', '#9CB86E', '#156B13'],
            'type': 'radial'
        }
    })

If ``type`` isn't specified it defaults to ``linear``.

For a ``linear`` fill the angle of the gradient can also be specified::

    chart.add_series({
        'values': '=Sheet1!$A$1:$A$6',
        'gradient': {'colors': ['#DDEBCF', '#9CB86E', '#156B13'],
                     'angle': 45}
    })

The default angle is 90 degrees.

If gradient fill is used on a chart object it overrides the solid fill and
pattern fill properties of the object.


.. _chart_fonts:

Chart Fonts
-----------

The following font properties can be set for any chart object that they apply
to (and that are supported by XlsxWriter) such as chart titles, axis labels,
axis numbering and data labels::

    name
    size
    bold
    italic
    underline
    rotation
    color

These properties correspond to the equivalent Worksheet cell Format object
properties. See the :ref:`format` section for more details about Format
properties and how to set them.

The following explains the available font properties:


* ``name``: Set the font name::

    chart.set_x_axis({'num_font':  {'name': 'Arial'}})

* ``size``: Set the font size::

    chart.set_x_axis({'num_font':  {'name': 'Arial', 'size': 9}})

* ``bold``: Set the font bold property::

    chart.set_x_axis({'num_font':  {'bold': True}})

* ``italic``: Set the font italic property::

    chart.set_x_axis({'num_font':  {'italic': True}})

* ``underline``: Set the font underline property::

    chart.set_x_axis({'num_font':  {'underline': True}})

* ``rotation``: Set the font rotation, angle, property in the integer
  range -90 to 90 deg, and 270-271 deg::

    chart.set_x_axis({'num_font':  {'rotation': 45}})

  The font rotation angle is useful for displaying axis data such as dates in
  a more compact format.

  There are 2 special case angles outside the range -90 to 90:

  * 270: Stacked text, where the text runs from top to bottom.

  * 271: A special variant of stacked text for East Asian fonts.

* ``color``: Set the font color property. Can be a color index, a color name
  or HTML style RGB color::

    chart.set_x_axis({'num_font': {'color': 'red' }})
    chart.set_y_axis({'num_font': {'color': '#92D050'}})


Here is an example of Font formatting in a Chart program::


    chart.set_title({
        'name': 'Test Results',
        'name_font': {
            'name': 'Calibri',
            'color': 'blue',
        },
    })

    chart.set_x_axis({
        'name': 'Month',
        'name_font': {
            'name': 'Courier New',
            'color': '#92D050'
        },
        'num_font': {
            'name': 'Arial',
            'color': '#00B0F0',
        },
    })

    chart.set_y_axis({
        'name': 'Units',
        'name_font': {
            'name': 'Century',
            'color': 'red'
        },
        'num_font': {
            'bold': True,
            'italic': True,
            'underline': True,
            'color': '#7030A0',
        },
    })

    chart.set_legend({'font': {'bold': 1, 'italic': 1}})

.. image:: _images/chart_font1.png
   :scale: 75 %

.. _chart_layout:

Chart Layout
------------

The position of the chart in the worksheet is controlled by the
:func:`set_size()` method.

It is also possible to change the layout of the following chart sub-objects::

    plotarea
    legend
    title
    x_axis caption
    y_axis caption

Here are some examples::

        chart.set_plotarea({
            'layout': {
                'x':      0.13,
                'y':      0.26,
                'width':  0.73,
                'height': 0.57,
            }
        })

        chart.set_legend({
            'layout': {
                'x':      0.80,
                'y':      0.37,
                'width':  0.12,
                'height': 0.25,
            }
        })

        chart.set_title({
            'name':    'Title',
            'overlay': True,
            'layout': {
                'x': 0.42,
                'y': 0.14,
            }
        })

        chart.set_x_axis({
            'name': 'X axis',
            'name_layout': {
                'x': 0.34,
                'y': 0.85,
            }
        })

See :func:`set_plotarea()`, :func:`set_legend()`, :func:`set_title()` and
:func:`set_x_axis()`,

.. note::

   It is only possible to change the width and height for the ``plotarea``
   and ``legend`` objects. For the other text based objects the width and
   height are changed by the font dimensions.

The layout units must be a float in the range ``0 < x <= 1`` and are expressed
as a percentage of the chart dimensions as shown below:

.. image:: _images/chart_layout.png
   :scale: 75 %

From this the layout units are calculated as follows::

    layout:
        x      = a / W
        y      = b / H
        width  = w / W
        height = h / H

These units are cumbersome and can vary depending on other elements in the
chart such as text lengths. However, these are the units that are required by
Excel to allow relative positioning. Some trial and error is generally
required.

.. note::

   The ``plotarea`` origin is the top left corner in the plotarea itself and
   does not take into account the axes.


.. _date_category_axes:

Date Category Axes
------------------

Date Category Axes are category axes that display time or date information. In
XlsxWriter Date Category Axes are set using the ``date_axis`` option in
:func:`set_x_axis` or :func:`set_y_axis`::

    chart.set_x_axis({'date_axis': True})

In general you should also specify a number format for a date axis although
Excel will usually default to the same format as the data being plotted::

    chart.set_x_axis({
        'date_axis':  True,
        'num_format': 'dd/mm/yyyy',
    })

Excel doesn't normally allow minimum and maximum values to be set for category
axes. However, date axes are an exception. The ``min`` and ``max`` values
should be set as Excel times or dates::

    chart.set_x_axis({
        'date_axis': True,
        'min': date(2013, 1, 2),
        'max': date(2013, 1, 9),
        'num_format': 'dd/mm/yyyy',
    })

For date axes it is also possible to set the type of the major and minor units::

    chart.set_x_axis({
        'date_axis':       True,
        'minor_unit':      4,
        'minor_unit_type': 'months',
        'major_unit':      1,
        'major_unit_type': 'years',
        'num_format':      'dd/mm/yyyy',
    })

See :ref:`ex_chart_date_axis`.

.. _chart_secondary_axes:

Chart Secondary Axes
--------------------

It is possible to add a secondary axis of the same type to a chart by setting
the ``y2_axis`` or ``x2_axis`` property of the series::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('chart_secondary_axis.xlsx')
    worksheet = workbook.add_worksheet()

    data = [
        [2, 3, 4, 5, 6, 7],
        [10, 40, 50, 20, 10, 50],
    ]

    worksheet.write_column('A2', data[0])
    worksheet.write_column('B2', data[1])

    chart = workbook.add_chart({'type': 'line'})

    # Configure a series with a secondary axis.
    chart.add_series({
        'values': '=Sheet1!$A$2:$A$7',
        'y2_axis': True,
    })

    # Configure a primary (default) Axis.
    chart.add_series({
        'values': '=Sheet1!$B$2:$B$7',
    })

    chart.set_legend({'position': 'none'})

    chart.set_y_axis({'name': 'Primary Y axis'})
    chart.set_y2_axis({'name': 'Secondary Y axis'})

    worksheet.insert_chart('D2', chart)

    workbook.close()

.. image:: _images/chart_secondary_axis2.png
   :scale: 75 %

It is also possible to have a secondary, combined, chart either with a shared
or secondary axis, see below.


.. _chart_combined_charts:

Combined Charts
---------------

It is also possible to combine two different chart types, for example a column
and line chart to create a Pareto chart using the Chart :func:`combine()`
method:

.. image:: _images/chart_pareto.png
   :scale: 75 %

The combined charts can share the same Y axis like the following example::

    # Usual setup to create workbook and add data...

    # Create a new column chart. This will use this as the primary chart.
    column_chart = workbook.add_chart({'type': 'column'})

    # Configure the data series for the primary chart.
    column_chart.add_series({
        'name':       '=Sheet1!B1',
        'categories': '=Sheet1!A2:A7',
        'values':     '=Sheet1!B2:B7',
    })

    # Create a new column chart. This will use this as the secondary chart.
    line_chart = workbook.add_chart({'type': 'line'})

    # Configure the data series for the secondary chart.
    line_chart.add_series({
        'name':       '=Sheet1!C1',
        'categories': '=Sheet1!A2:A7',
        'values':     '=Sheet1!C2:C7',
    })

    # Combine the charts.
    column_chart.combine(line_chart)

    # Add a chart title and some axis labels. Note, this is done via the
    # primary chart.
    column_chart.set_title({ 'name': 'Combined chart - same Y axis'})
    column_chart.set_x_axis({'name': 'Test number'})
    column_chart.set_y_axis({'name': 'Sample length (mm)'})

    # Insert the chart into the worksheet
    worksheet.insert_chart('E2', column_chart)


.. image:: _images/chart_combined1.png
   :scale: 75 %


The secondary chart can also be placed on a secondary axis using the methods
shown in the previous section.

In this case it is just necessary to add a ``y2_axis`` parameter to the series
and, if required, add a title using :func:`set_y2_axis()`. The following are
the additions to the previous example to place the secondary chart on the
secondary axis::

    # ...
    line_chart.add_series({
        'name':       '=Sheet1!C1',
        'categories': '=Sheet1!A2:A7',
        'values':     '=Sheet1!C2:C7',
        'y2_axis':    True,
    })

    # Add a chart title and some axis labels.
    # ...
    column_chart.set_y2_axis({'name': 'Target length (mm)'})


.. image:: _images/chart_combined2.png
   :scale: 75 %

The examples above use the concept of a *primary* and *secondary* chart. The
primary chart is the chart that defines the primary X and Y axis. It is also
used for setting all chart properties apart from the secondary data
series. For example the chart title and axes properties should be set via the
primary chart.

See also :ref:`ex_chart_combined` and :ref:`ex_chart_pareto` for more detailed
examples.

There are some limitations on combined charts:

* Only two charts can be combined.
* Pie charts cannot currently be combined.
* Scatter charts cannot currently be used as a primary chart but they can be
  used as a secondary chart.
* Bar charts can only combine secondary charts on a secondary axis. This is
  an Excel limitation.


Chartsheets
-----------

The examples shown above and in general the most common type of charts in Excel
are embedded charts.

However, it is also possible to create "Chartsheets" which are worksheets that
are comprised of a single chart:

.. image:: _images/chartsheet.png

See :ref:`chartsheet` for details.


.. _charts_from_tables:

Charts from Worksheet Tables
----------------------------

Charts can by created from :ref:`Worksheet Tables <tables>`. However, Excel
has a limitation where the data series ``name``, if specified, must refer to a
cell within the table (usually one of the headers).

To workaround this Excel limitation you can specify a user defined name in the
table and refer to that from the chart::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('chart_pie.xlsx')

    worksheet = workbook.add_worksheet()

    data = [
        ['Apple',  60],
        ['Cherry', 30],
        ['Pecan',  10],
    ]

    worksheet.add_table('A1:B4', {'data': data,
                                  'columns': [{'header': 'Types'},
                                             {'header': 'Number'}]}
    )

    chart = workbook.add_chart({'type': 'pie'})

    chart.add_series({
        'name':       '=Sheet1!$A$1',
        'categories': '=Sheet1!$A$2:$A$4',
        'values':     '=Sheet1!$B$2:$B$4',
    })

    worksheet.insert_chart('D2', chart)

    workbook.close()


Chart Limitations
-----------------

The following chart features aren't supported in XlsxWriter:

* 3D charts and controls.
* Bubble, Surface or other chart types not listed in :ref:`chart_class`.


Chart Examples
--------------

See :ref:`chart_examples`.

================
File: dev/docs/source/working_with_colors.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _colors:

Working with Colors
===================

Colors are represented in XlsxWriter using the :ref:`Color`. There are 3 types
of colors that can be used in XlsxWriter:

1. User-defined RGB colors using HTML syntax like ``#RRGGBB``.
2. Predefined named colors like ``Green``, ``Yellow``, and ``Blue``. These are
   shortcuts for RGB colors.
3. Theme colors from the standard palette of 60 colors, such as ``Color(9, 4)``.
   The theme colors are also shown below.

.. image:: _images/doc_color_intro.png

These color variants are explained in more detail in the sections below.

:ref:`Color <Color>` objects can be used throughout the XlsxWriter APIs,
including the following:

- In the :ref:`Format` to set the font color, background color, border
  color and other colors.
- In the :func:`add_chart()` method and sub-properties to set the color of chart
  elements.
- In Conditional Formatting to set the color of cells. See the
  :func:`conditional_format` method.


RGB Colors
----------

XlsxWriter supports the use of RGB colors in the HTML format ``#RRGGBB``. The
range is from ``#000000`` to ``#FFFFFF``::

    from xlsxwriter.color import Color

    color_format = workbook.add_format({"bg_color": Color("#FF7F50")})


Named Colors
------------

XlsxWriter supports a limited number of named colors. The named colors
are shortcuts for RGB colors::

    from xlsxwriter.color import Color

    color_format = workbook.add_format({"bg_color": Color("Green")})


The named colors are:

+------------+----------------+
| Color name | RGB color code |
+============+================+
| Black      | ``#000000``    |
+------------+----------------+
| Blue       | ``#0000FF``    |
+------------+----------------+
| Brown      | ``#800000``    |
+------------+----------------+
| Cyan       | ``#00FFFF``    |
+------------+----------------+
| Gray       | ``#808080``    |
+------------+----------------+
| Green      | ``#008000``    |
+------------+----------------+
| Lime       | ``#00FF00``    |
+------------+----------------+
| Magenta    | ``#FF00FF``    |
+------------+----------------+
| Navy       | ``#000080``    |
+------------+----------------+
| Orange     | ``#FF6600``    |
+------------+----------------+
| Pink       | ``#FF00FF``    |
+------------+----------------+
| Purple     | ``#800080``    |
+------------+----------------+
| Red        | ``#FF0000``    |
+------------+----------------+
| Silver     | ``#C0C0C0``    |
+------------+----------------+
| White      | ``#FFFFFF``    |
+------------+----------------+
| Yellow     | ``#FFFF00``    |
+------------+----------------+


Theme Colors
------------

Theme colors represent the default Excel theme color palette:

.. image:: _images/theme_color_palette.png

The syntax for theme colors in :ref:`Color <Color>` is ``Color(color, shade)``,
where ``color`` is one of the 0-9 values on the top row and ``shade`` is the
variant in the associated column from 0-5. For example, "White, background 1" in
the top left is ``Color(0, 0)``, and "Orange, Accent 6, Darker 50%" in the bottom
right is ``Color(9, 5)``.


Color Strings
-------------

For simplicity and backward compatibility, colors can also be represented as an
HTML color string::

    from xlsxwriter.color import Color

    # Explicit RGB color object.
    color_format = workbook.add_format({"bg_color": Color("#FF7F50")})

    # Implicit RGB color string.
    color_format = workbook.add_format({"bg_color": "#FF7F50"})

The bare strings are parsed and converted to a :ref:`Color <Color>` object
internally.

================
File: dev/docs/source/working_with_conditional_formats.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _working_with_conditional_formats:

Working with Conditional Formatting
===================================

Conditional formatting is a feature of Excel which allows you to apply a format
to a cell or a range of cells based on certain criteria.

For example the following rules are used to highlight cells in the
:ref:`conditional_format.py <ex_cond_format>` example::

    worksheet.conditional_format('B3:K12', {'type':     'cell',
                                            'criteria': '>=',
                                            'value':    50,
                                            'format':   format1})

    worksheet.conditional_format('B3:K12', {'type':     'cell',
                                            'criteria': '<',
                                            'value':    50,
                                            'format':   format2})

Which gives criteria like this:

.. image:: _images/conditional_format3.png

And output which looks like this:

.. image:: _images/conditional_format1.png

It is also possible to create color scales and data bars:

.. image:: _images/conditional_format2.png


The conditional_format() method
-------------------------------

The :func:`conditional_format` worksheet method is used to apply formatting
based on user defined criteria to an XlsxWriter file.

The conditional format can be applied to a single cell or a range of cells. As
usual you can use A1 or Row/Column notation (:ref:`cell_notation`).

With Row/Column notation you must specify all four cells in the range:
``(first_row, first_col, last_row, last_col)``. If you need to refer to a
single cell set the ``last_*`` values equal to the ``first_*`` values. With A1
notation you can refer to a single cell or a range of cells::

    worksheet.conditional_format(0, 0, 4, 1, {...})
    worksheet.conditional_format('B1',       {...})
    worksheet.conditional_format('C1:E5',    {...})

The options parameter in ``conditional_format()`` must be a dictionary
containing the parameters that describe the type and style of the conditional
format. The main parameters are:

* ``type``
* ``format``
* ``criteria``
* ``value``
* ``minimum``
* ``maximum``

Other, less commonly used parameters are:

* ``min_type``
* ``mid_type``
* ``max_type``
* ``min_value``
* ``mid_value``
* ``max_value``
* ``min_color``
* ``mid_color``
* ``max_color``
* ``bar_color``
* ``bar_only``
* ``bar_solid``
* ``bar_negative_color``
* ``bar_border_color``
* ``bar_negative_border_color``
* ``bar_negative_color_same``
* ``bar_negative_border_color_same``
* ``bar_no_border``
* ``bar_direction``
* ``bar_axis_position``
* ``bar_axis_color``
* ``data_bar_2010``
* ``icon_style``
* ``icons``
* ``reverse_icons``
* ``icons_only``
* ``stop_if_true``
* ``multi_range``


Conditional Format Options
--------------------------

The conditional format options that can be used with :func:`conditional_format`
are explained in the following sections.

type
****

The ``type`` option is a required parameter and it has no default value.
Allowable ``type`` values and their associated parameters are:

+---------------+---------------------------------+
| Type          | Parameters                      |
+===============+=================================+
| cell          | criteria                        |
+---------------+---------------------------------+
|               | value                           |
+---------------+---------------------------------+
|               | minimum                         |
+---------------+---------------------------------+
|               | maximum                         |
+---------------+---------------------------------+
|               | format                          |
+---------------+---------------------------------+
| date          | criteria                        |
+---------------+---------------------------------+
|               | value                           |
+---------------+---------------------------------+
|               | minimum                         |
+---------------+---------------------------------+
|               | maximum                         |
+---------------+---------------------------------+
|               | format                          |
+---------------+---------------------------------+
| time_period   | criteria                        |
+---------------+---------------------------------+
|               | format                          |
+---------------+---------------------------------+
| text          | criteria                        |
+---------------+---------------------------------+
|               | value                           |
+---------------+---------------------------------+
|               | format                          |
+---------------+---------------------------------+
| average       | criteria                        |
+---------------+---------------------------------+
|               | format                          |
+---------------+---------------------------------+
| duplicate     | format                          |
+---------------+---------------------------------+
| unique        | format                          |
+---------------+---------------------------------+
| top           | criteria                        |
+---------------+---------------------------------+
|               | value                           |
+---------------+---------------------------------+
|               | format                          |
+---------------+---------------------------------+
| bottom        | criteria                        |
+---------------+---------------------------------+
|               | value                           |
+---------------+---------------------------------+
|               | format                          |
+---------------+---------------------------------+
| blanks        | format                          |
+---------------+---------------------------------+
| no_blanks     | format                          |
+---------------+---------------------------------+
| errors        | format                          |
+---------------+---------------------------------+
| no_errors     | format                          |
+---------------+---------------------------------+
| formula       | criteria                        |
+---------------+---------------------------------+
|               | format                          |
+---------------+---------------------------------+
| 2_color_scale | min_type                        |
+---------------+---------------------------------+
|               | max_type                        |
+---------------+---------------------------------+
|               | min_value                       |
+---------------+---------------------------------+
|               | max_value                       |
+---------------+---------------------------------+
|               | min_color                       |
+---------------+---------------------------------+
|               | max_color                       |
+---------------+---------------------------------+
| 3_color_scale | min_type                        |
+---------------+---------------------------------+
|               | mid_type                        |
+---------------+---------------------------------+
|               | max_type                        |
+---------------+---------------------------------+
|               | min_value                       |
+---------------+---------------------------------+
|               | mid_value                       |
+---------------+---------------------------------+
|               | max_value                       |
+---------------+---------------------------------+
|               | min_color                       |
+---------------+---------------------------------+
|               | mid_color                       |
+---------------+---------------------------------+
|               | max_color                       |
+---------------+---------------------------------+
| data_bar      | min_type                        |
+---------------+---------------------------------+
|               | max_type                        |
+---------------+---------------------------------+
|               | min_value                       |
+---------------+---------------------------------+
|               | max_value                       |
+---------------+---------------------------------+
|               | bar_only                        |
+---------------+---------------------------------+
|               | bar_color                       |
+---------------+---------------------------------+
|               | bar_solid*                      |
+---------------+---------------------------------+
|               | bar_negative_color*             |
+---------------+---------------------------------+
|               | bar_border_color*               |
+---------------+---------------------------------+
|               | bar_negative_border_color*      |
+---------------+---------------------------------+
|               | bar_negative_color_same*        |
+---------------+---------------------------------+
|               | bar_negative_border_color_same* |
+---------------+---------------------------------+
|               | bar_no_border*                  |
+---------------+---------------------------------+
|               | bar_direction*                  |
+---------------+---------------------------------+
|               | bar_axis_position*              |
+---------------+---------------------------------+
|               | bar_axis_color*                 |
+---------------+---------------------------------+
|               | data_bar_2010*                  |
+---------------+---------------------------------+
| icon_set      | icon_style                      |
+---------------+---------------------------------+
|               | reverse_icons                   |
+---------------+---------------------------------+
|               | icons                           |
+---------------+---------------------------------+
|               | icons_only                      |
+---------------+---------------------------------+

.. Note::

   Data bar parameters marked with (*) are only available in Excel 2010 and
   later. Files that use these properties can still be opened in Excel 2007
   but the data bars will be displayed without them.


type: cell
**********

This is the most common conditional formatting type. It is used when a format
is applied to a cell based on a simple criterion.

For example using a single cell and the ``greater than`` criteria::

    worksheet.conditional_format('A1', {'type':     'cell',
                                        'criteria': 'greater than',
                                        'value':     5,
                                        'format':    red_format})

Or, using a range and the ``between`` criteria::

    worksheet.conditional_format('C1:C4', {'type':     'cell',
                                           'criteria': 'between',
                                           'minimum':  20,
                                           'maximum':  30,
                                           'format':   green_format})

Other types are shown below, after the other main options.


criteria:
*********

The ``criteria`` parameter is used to set the criteria by which the cell data
will be evaluated. It has no default value. The most common criteria as
applied to ``{'type': 'cell'}`` are:

+------------------------------+--------+
| ``between``                  |        |
+------------------------------+--------+
| ``not between``              |        |
+------------------------------+--------+
| ``equal to``                 | ``==`` |
+------------------------------+--------+
| ``not equal to``             | ``!=`` |
+------------------------------+--------+
| ``greater than``             | ``>``  |
+------------------------------+--------+
| ``less than``                | ``<``  |
+------------------------------+--------+
| ``greater than or equal to`` | ``>=`` |
+------------------------------+--------+
| ``less than or equal to``    | ``<=`` |
+------------------------------+--------+


You can either use Excel's textual description strings, in the first column
above, or the more common symbolic alternatives.

Additional criteria which are specific to other conditional format types are
shown in the relevant sections below.


value:
******

The ``value`` is generally used along with the ``criteria`` parameter to set
the rule by which the cell data will be evaluated::

    worksheet.conditional_format('A1', {'type':     'cell',
                                        'criteria': 'equal to',
                                        'value':    5,
                                        'format':   red_format})

If the ``type`` is ``cell`` and the ``value`` is a string then it should be
double quoted, as required by Excel::

    worksheet.conditional_format('A1', {'type':     'cell',
                                        'criteria': 'equal to',
                                        'value':    '"Failed"',
                                        'format':   red_format})

The ``value`` property can also be an cell reference::

    worksheet.conditional_format('A1', {'type':     'cell',
                                        'criteria': 'equal to',
                                        'value':    '$C$1',
                                        'format':   red_format})

.. note::

   In general any ``value`` property that refers to a cell reference should
   use an :ref:`absolute reference <abs_reference>`, especially if the
   conditional formatting is applied to a range of values. Without an absolute
   cell reference the conditional format will not be applied correctly by
   Excel, apart from the first cell in the formatted range.


format:
*******

The ``format`` parameter is used to specify the format that will be applied to
the cell when the conditional formatting criterion is met. The format is
created using the :func:`add_format()` method in the same way as cell formats::

    format1 = workbook.add_format({'bold': 1, 'italic': 1})

    worksheet.conditional_format('A1', {'type':     'cell',
                                        'criteria': '>',
                                        'value':    5,
                                        'format':   format1})

.. Note::

   In Excel, a conditional format is superimposed over the existing cell
   format and not all cell format properties can be modified. Properties that
   **cannot** be modified in a conditional format are font name, font size,
   superscript and subscript, diagonal borders, all alignment properties and
   all protection properties.

Excel specifies some default formats to be used with conditional formatting.
These can be replicated using the following XlsxWriter formats::

    # Light red fill with dark red text.
    format1 = workbook.add_format({'bg_color':   '#FFC7CE',
                                   'font_color': '#9C0006'})

    # Light yellow fill with dark yellow text.
    format2 = workbook.add_format({'bg_color':   '#FFEB9C',
                                   'font_color': '#9C6500'})

    # Green fill with dark green text.
    format3 = workbook.add_format({'bg_color':   '#C6EFCE',
                                   'font_color': '#006100'})

See also :ref:`format`.

minimum:
********

The ``minimum`` parameter is used to set the lower limiting value when the
``criteria`` is either ``'between'`` or ``'not between'``::

        worksheet.conditional_format('A1', {'type':     'cell',
                                            'criteria': 'between',
                                            'minimum':  2,
                                            'maximum':  6,
                                            'format':   format1,
                                            })

maximum:
********

The ``maximum`` parameter is used to set the upper limiting value when the
``criteria`` is either ``'between'`` or ``'not between'``. See the previous
example.


type: date
**********

The ``date`` type is similar the ``cell`` type and uses the same criteria and
values. However, the ``value``, ``minimum`` and ``maximum`` properties are
specified as a datetime object as shown in :ref:`working_with_dates_and_time`::


    date = datetime.datetime.strptime('2011-01-01', "%Y-%m-%d")

    worksheet.conditional_format('A1:A4', {'type':     'date',
                                           'criteria': 'greater than',
                                           'value':    date,
                                           'format':   format1})


type: time_period
*****************

The ``time_period`` type is used to specify Excel's "Dates Occurring" style
conditional format::

    worksheet.conditional_format('A1:A4', {'type':     'time_period',
                                           'criteria': 'yesterday',
                                           'format':   format1})

The period is set in the ``criteria`` and can have one of the following values::

        'criteria': 'yesterday',
        'criteria': 'today',
        'criteria': 'last 7 days',
        'criteria': 'last week',
        'criteria': 'this week',
        'criteria': 'next week',
        'criteria': 'last month',
        'criteria': 'this month',
        'criteria': 'next month'


type: text
**********

The ``text`` type is used to specify Excel's "Specific Text" style conditional
format. It is used to do simple string matching using the ``criteria`` and
``value`` parameters::

    worksheet.conditional_format('A1:A4', {'type':     'text',
                                           'criteria': 'containing',
                                           'value':    'foo',
                                           'format':   format1})

The ``criteria`` can have one of the following values::

    'criteria': 'containing',
    'criteria': 'not containing',
    'criteria': 'begins with',
    'criteria': 'ends with',

The ``value`` parameter should be a string or single character.


type: average
*************

The ``average`` type is used to specify Excel's "Average" style conditional
format::

    worksheet.conditional_format('A1:A4', {'type':     'average',
                                           'criteria': 'above',
                                           'format':   format1})

The type of average for the conditional format range is specified by the
``criteria``::

    'criteria': 'above',
    'criteria': 'below',
    'criteria': 'equal or above',
    'criteria': 'equal or below',
    'criteria': '1 std dev above',
    'criteria': '1 std dev below',
    'criteria': '2 std dev above',
    'criteria': '2 std dev below',
    'criteria': '3 std dev above',
    'criteria': '3 std dev below',


type: duplicate
***************

The ``duplicate`` type is used to highlight duplicate cells in a range::

    worksheet.conditional_format('A1:A4', {'type':   'duplicate',
                                           'format': format1})


type: unique
************

The ``unique`` type is used to highlight unique cells in a range::

    worksheet.conditional_format('A1:A4', {'type':   'unique',
                                           'format': format1})


type: top
*********

The ``top`` type is used to specify the top ``n`` values by number or
percentage in a range::

    worksheet.conditional_format('A1:A4', {'type':   'top',
                                           'value':  10,
                                           'format': format1})

The ``criteria`` can be used to indicate that a percentage condition is
required::

    worksheet.conditional_format('A1:A4', {'type':     'top',
                                           'value':    10,
                                           'criteria': '%',
                                           'format':   format1})


type: bottom
************

The ``bottom`` type is used to specify the bottom ``n`` values by number or
percentage in a range.

It takes the same parameters as ``top``, see above.


type: blanks
************

The ``blanks`` type is used to highlight blank cells in a range::

    worksheet.conditional_format('A1:A4', {'type':   'blanks',
                                           'format': format1})


type: no_blanks
***************

The ``no_blanks`` type is used to highlight non blank cells in a range::

    worksheet.conditional_format('A1:A4', {'type':   'no_blanks',
                                           'format': format1})


type: errors
************

The ``errors`` type is used to highlight error cells in a range::

    worksheet.conditional_format('A1:A4', {'type':   'errors',
                                           'format': format1})


type: no_errors
***************

The ``no_errors`` type is used to highlight non error cells in a range::

    worksheet.conditional_format('A1:A4', {'type':   'no_errors',
                                           'format': format1})


type: formula
*************

The ``formula`` type is used to specify a conditional format based on a user
defined formula::


    worksheet.conditional_format('A1:A4', {'type':     'formula',
                                           'criteria': '=$A$1>5',
                                           'format':   format1})

The formula is specified in the ``criteria``.

Formulas must be written with the US style separator/range operator which is a
comma (not semi-colon) and should follow the same rules as
:func:`write_formula`. See :ref:`formula_syntax` for a full explanation::

    # This formula will cause an Excel error on load due to
    # non-English language and use of semi-colons.
    worksheet.conditional_format('A2:C9' ,
        {'type':     'formula',
         'criteria': '=ODER($B2<$C2;UND($B2="";$C2>HEUTE()))',
         'format':   format1
        })

    # This is the correct syntax.
    worksheet.conditional_format('A2:C9' ,
        {'type':     'formula',
         'criteria': '=OR($B2<$C2,AND($B2="",$C2>TODAY()))',
         'format':   format1
        })

Also, any cell or range references in the formula should
be :ref:`absolute references <abs_reference>` if they are applied to the full
range of the conditional format. See the note in the ``value`` section above.


type: 2_color_scale
*******************

The ``2_color_scale`` type is used to specify Excel's "2 Color Scale" style
conditional format::

    worksheet.conditional_format('A1:A12', {'type': '2_color_scale'})

.. image:: _images/conditional_format4.png

This conditional type can be modified with ``min_type``, ``max_type``,
``min_value``, ``max_value``, ``min_color`` and ``max_color``, see below.

type: 3_color_scale
*******************

The ``3_color_scale`` type is used to specify Excel's "3 Color Scale" style
conditional format::

    worksheet.conditional_format('A1:A12', {'type': '3_color_scale'})

This conditional type can be modified with ``min_type``, ``mid_type``,
``max_type``, ``min_value``, ``mid_value``, ``max_value``, ``min_color``,
``mid_color`` and ``max_color``, see below.


type: data_bar
**************

The ``data_bar`` type is used to specify Excel's "Data Bar" style conditional
format::

    worksheet.conditional_format('A1:A12', {'type': 'data_bar'})

This conditional type can be modified with the following parameters, which are
explained in the sections below. These properties were available in the
original xlsx file specification used in Excel 2007::

    min_type
    max_type
    min_value
    max_value
    bar_color
    bar_only

In Excel 2010 additional data bar properties were added such as solid
(non-gradient) bars and control over how negative values are displayed. These
properties can be set using the following parameters::

    bar_solid
    bar_negative_color
    bar_border_color
    bar_negative_border_color
    bar_negative_color_same
    bar_negative_border_color_same
    bar_no_border
    bar_direction
    bar_axis_position
    bar_axis_color
    data_bar_2010

.. image:: _images/conditional_format6.png

Files that use these Excel 2010 properties can still be opened in Excel 2007
but the data bars will be displayed without them.


type: icon_set
**************

The ``icon_set`` type is used to specify a conditional format with a set of
icons such as traffic lights or arrows::

    worksheet.conditional_format('A1:C1', {'type': 'icon_set',
                                           'icon_style': '3_traffic_lights'})

The icon set style is specified by the ``icon_style`` parameter. Valid options are::

    3_arrows
    3_arrows_gray
    3_flags
    3_signs
    3_symbols
    3_symbols_circled
    3_traffic_lights
    3_traffic_lights_rimmed

    4_arrows
    4_arrows_gray
    4_ratings
    4_red_to_black
    4_traffic_lights

    5_arrows
    5_arrows_gray
    5_quarters
    5_ratings

.. image:: _images/conditional_format5.png

The criteria, type and value of each icon can be specified using the ``icon``
array of dicts with optional ``criteria``, ``type`` and ``value`` parameters::

    worksheet.conditional_format(
        'A1:D1',
        {'type': 'icon_set',
         'icon_style': '4_red_to_black',
         'icons': [{'criteria': '>=', 'type': 'number',     'value': 90},
                   {'criteria': '<',  'type': 'percentile', 'value': 50},
                   {'criteria': '<=', 'type': 'percent',    'value': 25}]}
    )


* The icons ``criteria`` parameter should be either ``>=`` or ``<``. The default
  ``criteria`` is ``>=``.

* The icons ``type`` parameter should be one of the following values::

      number
      percentile
      percent
      formula

  The default ``type`` is ``percent``.

* The icons ``value`` parameter can be a value or formula::

      worksheet.conditional_format('A1:D1',
                                   {'type': 'icon_set',
                                    'icon_style': '4_red_to_black',
                                    'icons': [{'value': 90},
                                              {'value': 50},
                                              {'value': 25}]})

Note: The ``icons`` parameters should start with the highest value and with
each subsequent one being lower.
The default ``value`` is ``(n * 100) / number_of_icons``. The lowest number
icon in an icon set has properties defined by Excel. Therefore in a ``n`` icon
set, there is no ``n-1`` hash of parameters.

The order of the icons can be reversed using the ``reverse_icons`` parameter::

        worksheet.conditional_format('A1:C1',
                                     {'type': 'icon_set',
                                      'icon_style': '3_arrows',
                                      'reverse_icons': True})

The icons can be displayed without the cell value using the ``icons_only``
parameter::

        worksheet.conditional_format('A1:C1',
                                     {'type': 'icon_set',
                                      'icon_style': '3_flags',
                                      'icons_only': True})


min_type:
*********

The ``min_type`` and ``max_type`` properties are available when the conditional
formatting type is ``2_color_scale``, ``3_color_scale`` or ``data_bar``. The
``mid_type`` is available for ``3_color_scale``. The properties are used as
follows::

    worksheet.conditional_format('A1:A12', {'type':     '2_color_scale',
                                            'min_type': 'percent',
                                            'max_type': 'percent'})

The available min/mid/max types are::

    min        (for min_type only)
    num
    percent
    percentile
    formula
    max        (for max_type only)


mid_type:
*********

Used for ``3_color_scale``. Same as ``min_type``, see above.


max_type:
*********

Same as ``min_type``, see above.


min_value:
**********

The ``min_value`` and ``max_value`` properties are available when the
conditional formatting type is ``2_color_scale``, ``3_color_scale`` or
``data_bar``. The ``mid_value`` is available for ``3_color_scale``. The
properties are used as follows::

    worksheet.conditional_format('A1:A12', {'type':      '2_color_scale',
                                            'min_value': 10,
                                            'max_value': 90})


mid_value:
**********

Used for ``3_color_scale``. Same as ``min_value``, see above.


max_value:
**********

Same as ``min_value``, see above.


min_color:
**********

The ``min_color`` and ``max_color`` properties are available when the
conditional formatting type is ``2_color_scale``, ``3_color_scale`` or
``data_bar``. The ``mid_color`` is available for ``3_color_scale``. The
properties are used as follows::

    worksheet.conditional_format('A1:A12', {'type':      '2_color_scale',
                                            'min_color': '#C5D9F1',
                                            'max_color': '#538ED5'})

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.


mid_color:
**********

Used for ``3_color_scale``. Same as ``min_color``, see above.


max_color:
**********

Same as ``min_color``, see above.


bar_color:
**********

The ``bar_color`` parameter sets the fill color for data bars::

    worksheet.conditional_format('F3:F14', {'type': 'data_bar',
                                            'bar_color': '#63C384'})

.. image:: _images/conditional_format7.png

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.


bar_only:
*********

The ``bar_only`` property displays a bar data but not the data in the cells::

    worksheet.conditional_format('D3:D14', {'type': 'data_bar',
                                            'bar_only': True})

See the image above.


bar_solid:
**********

The ``bar_solid`` property turns on a solid (non-gradient) fill for data
bars::

    worksheet.conditional_format('H3:H14', {'type': 'data_bar',
                                            'bar_solid': True})

See the image above.

Note, this property is only visible in Excel 2010 and later.


bar_negative_color:
*******************

The ``bar_negative_color`` property sets the color fill for the negative
portion of a data bar::

    worksheet.conditional_format('F3:F14', {'type': 'data_bar',
                                            'bar_negative_color': '#63C384'})

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.

Note, this property is only visible in Excel 2010 and later.

bar_border_color:
*****************

The ``bar_border_color`` property sets the color for the border line of a data
bar::

    worksheet.conditional_format('F3:F14', {'type': 'data_bar',
                                            'bar_border_color': '#63C384'})

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.

Note, this property is only visible in Excel 2010 and later.

bar_negative_border_color:
**************************

The ``bar_negative_border_color`` property sets the color for the border of
the negative portion of a data bar::

    worksheet.conditional_format('F3:F14', {'type': 'data_bar',
                                            'bar_negative_border_color': '#63C384'})

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.

Note, this property is only visible in Excel 2010 and later.


bar_negative_color_same:
************************

The ``bar_negative_color_same`` property sets the fill color for the negative
portion of a data bar to be the same as the fill color for the positive
portion of the data bar::

    worksheet.conditional_format('F3:F14', {'type': 'data_bar',
                                            'bar_negative_color_same': True})

.. image:: _images/conditional_format6.png

Note, this property is only visible in Excel 2010 and later.


bar_negative_border_color_same:
*******************************

The ``bar_negative_border_color_same`` property sets the border color for the
negative portion of a data bar to be the same as the border color for the
positive portion of the data bar::

    worksheet.conditional_format('F3:F14', {'type': 'data_bar',
                                            'bar_negative_border_color_same': True})

See the image above.

Note, this property is only visible in Excel 2010 and later.

bar_no_border:
**************

The ``bar_no_border`` property turns off the border for data bars::

    worksheet.conditional_format('F3:F14', {'type': 'data_bar',
                                            'bar_no_border': True})

Note, this property is only visible in Excel 2010 and later, however the
default in Excel 2007 is to not have a border.


bar_direction:
**************

The ``bar_direction`` property sets the direction for data bars. This property
can be either ``left`` for left-to-right or ``right`` for right-to-left. If
the property isn't set then Excel will adjust the position automatically based
on the context::

    worksheet.conditional_format('J3:J14', {'type': 'data_bar',
                                            'bar_direction': 'right'})

.. image:: _images/conditional_format6.png

Note, this property is only visible in Excel 2010 and later.


bar_axis_position:
******************

The ``bar_axis_position`` property sets the position within the cells for the
axis that is shown in data bars when there are negative values to display. The
property can be either ``middle`` or ``none``. If the property isn't set then
Excel will position the axis based on the range of positive and negative
values::

    worksheet.conditional_format('J3:J14', {'type': 'data_bar',
                                            'bar_axis_position': 'middle'})

Note, this property is only visible in Excel 2010 and later.


bar_axis_color:
***************

The ``bar_axis_color`` property sets the color for the axis that is shown in
data bars when there are negative values to display::

    worksheet.conditional_format('J3:J14', {'type': 'data_bar',
                                            'bar_axis_color': '#0070C0'})

Note, this property is only visible in Excel 2010 and later.


data_bar_2010:
**************

The ``data_bar_2010`` property sets Excel 2010 style data bars even when Excel
2010 specific properties aren't used. This can be used for consistency across
all the data bar formatting in a worksheet::

    worksheet.conditional_format('L3:L14', {'type': 'data_bar',
                                            'data_bar_2010': True})


stop_if_true
************

The ``stop_if_true`` parameter can be used to set the "stop if true" feature
of a conditional formatting rule when more than one rule is applied to a cell
or a range of cells. When this parameter is set then subsequent rules are not
evaluated if the current rule is true::

        worksheet.conditional_format('A1',
                                     {'type': 'cell',
                                      'format': cell_format,
                                      'criteria': '>',
                                      'value': 20,
                                      'stop_if_true': True
                                      })


multi_range:
************

The ``multi_range`` option is used to extend a conditional format over
non-contiguous ranges.

It is possible to apply the conditional format to different cell ranges in a
worksheet using multiple calls to ``conditional_format()``. However, as a
minor optimization it is also possible in Excel to apply the same conditional
format to different non-contiguous cell ranges.

This is replicated in ``conditional_format()`` using the ``multi_range``
option. The range must contain the primary range for the conditional format
and any others separated by spaces.

For example to apply one conditional format to two ranges, ``'B3:K6'`` and
``'B9:K12'``::

    worksheet.conditional_format('B3:K6', {'type': 'cell',
                                           'criteria': '>=',
                                           'value': 50,
                                           'format': format1,
                                           'multi_range': 'B3:K6 B9:K12'})


Conditional Formatting Examples
-------------------------------

Highlight cells greater than an integer value::

    worksheet.conditional_format('A1:F10', {'type':     'cell',
                                            'criteria': 'greater than',
                                            'value':    5,
                                            'format':   format1})

Highlight cells greater than a value in a reference cell::

    worksheet.conditional_format('A1:F10', {'type':     'cell',
                                            'criteria': 'greater than',
                                            'value':    'H1',
                                            'format':   format1})

Highlight cells more recent (greater) than a certain date::

    date = datetime.datetime.strptime('2011-01-01', "%Y-%m-%d")

    worksheet.conditional_format('A1:F10', {'type':     'date',
                                            'criteria': 'greater than',
                                            'value':    date,
                                            'format':   format1})

Highlight cells with a date in the last seven days::

    worksheet.conditional_format('A1:F10', {'type':     'time_period',
                                            'criteria': 'last 7 days',
                                            'format':   format1})

Highlight cells with strings starting with the letter ``b``::

    worksheet.conditional_format('A1:F10', {'type':     'text',
                                            'criteria': 'begins with',
                                            'value':    'b',
                                            'format':   format1})

Highlight cells that are 1 standard deviation above the average for the range::

    worksheet.conditional_format('A1:F10', {'type':   'average',
                                            'format': format1})

Highlight duplicate cells in a range::

    worksheet.conditional_format('A1:F10', {'type':   'duplicate',
                                            'format': format1})

Highlight unique cells in a range::

    worksheet.conditional_format('A1:F10', {'type':   'unique',
                                            'format': format1})

Highlight the top 10 cells::

    worksheet.conditional_format('A1:F10', {'type':   'top',
                                            'value':  10,
                                            'format': format1})

Highlight blank cells::

    worksheet.conditional_format('A1:F10', {'type':   'blanks',
                                            'format': format1})

Set traffic light icons in 3 cells::

    worksheet.conditional_format('B3:D3', {'type': 'icon_set',
                                           'icon_style': '3_traffic_lights'})

See also :ref:`ex_cond_format`.

================
File: dev/docs/source/working_with_data_validation.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _working_with_data_validation:

Working with Data Validation
============================

Data validation is a feature of Excel which allows you to restrict the data
that a user enters in a cell and to display associated help and warning
messages. It also allows you to restrict input to values in a dropdown list.

A typical use case might be to restrict data in a cell to integer values in a
certain range, to provide a help message to indicate the required value and to
issue a warning if the input data doesn't meet the stated criteria. In
XlsxWriter we could do that as follows::

    worksheet.data_validation('B25', {'validate': 'integer',
                                      'criteria': 'between',
                                      'minimum': 1,
                                      'maximum': 100,
                                      'input_title': 'Enter an integer:',
                                      'input_message': 'between 1 and 100'})

.. image:: _images/data_validate1.png

If the user inputs a value that doesn't match the specified criteria an error
message is displayed:

.. image:: _images/data_validate4.png


For more information on data validation see the Microsoft support article
"Description and examples of data validation in Excel":
https://support.microsoft.com/en-us/office/apply-data-validation-to-cells-29fecbcc-d1b9-42c1-9d76-eff3ce5f7249.

The following sections describe how to use the ``data_validation()`` method and
its various options.


data_validation()
-----------------

The :func:`data_validation()` method is used to construct an Excel data
validation.

The data validation can be applied to a single cell or a range of cells. As
usual you can use A1 or Row/Column notation, see :ref:`cell_notation`.

With Row/Column notation you must specify all four cells in the range:
``(first_row, first_col, last_row, last_col)``. If you need to refer to a
single cell set the `last_` values equal to the `first_` values. With A1
notation you can refer to a single cell or a range of cells::

    worksheet.data_validation(0, 0, 4, 1, {...})
    worksheet.data_validation('B1',       {...})
    worksheet.data_validation('C1:E5',    {...})

The options parameter in ``data_validation()`` must be a dictionary containing
the parameters that describe the type and style of the data validation. The
main parameters are:

+-------------------+-------------+------------+
| ``validate``      |             |            |
+-------------------+-------------+------------+
| ``criteria``      |             |            |
+-------------------+-------------+------------+
| ``value``         | ``minimum`` | ``source`` |
+-------------------+-------------+------------+
| ``maximum``       |             |            |
+-------------------+-------------+------------+
| ``ignore_blank``  |             |            |
+-------------------+-------------+------------+
| ``dropdown``      |             |            |
+-------------------+-------------+------------+
| ``input_title``   |             |            |
+-------------------+-------------+------------+
| ``input_message`` |             |            |
+-------------------+-------------+------------+
| ``show_input``    |             |            |
+-------------------+-------------+------------+
| ``error_title``   |             |            |
+-------------------+-------------+------------+
| ``error_message`` |             |            |
+-------------------+-------------+------------+
| ``error_type``    |             |            |
+-------------------+-------------+------------+
| ``show_error``    |             |            |
+-------------------+-------------+------------+
| ``multi_range``   |             |            |
+-------------------+-------------+------------+

These parameters are explained in the following sections. Most of the
parameters are optional, however, you will generally require the three main
options ``validate``, ``criteria`` and ``value``::

    worksheet.data_validation('A1', {'validate': 'integer',
                                     'criteria': '>',
                                     'value': 100})


validate
********

The ``validate`` parameter is used to set the type of data that you wish to
validate::

    worksheet.data_validation('A1', {'validate': 'integer',
                                     'criteria': '>',
                                     'value': 100})

It is always required and it has no default value. Allowable values are::

    integer
    decimal
    list
    date
    time
    length
    custom
    any

* **integer**: restricts the cell to integer values. Excel refers to this as
  'whole number'.
* **decimal**: restricts the cell to decimal values.
* **list**: restricts the cell to a set of user specified values. These can
  be passed in a Python list or as an Excel cell range.
* **date**: restricts the cell to date values specified as a datetime object
  as shown in :ref:`working_with_dates_and_time` or a date formula.
* **time**: restricts the cell to time values specified as a datetime object
  as shown in :ref:`working_with_dates_and_time` or a time formula.
* **length**: restricts the cell data based on an integer string length.
  Excel refers to this as 'Text length'.
* **custom**: restricts the cell based on an external Excel formula that
  returns a ``TRUE/FALSE`` value.
* **any**: is used to specify that the type of data is unrestricted. It is
  mainly used for specifying cell input messages without a data validation.


criteria
********

The ``criteria`` parameter is used to set the criteria by which the data in the
cell is validated. It is almost always required except for the ``list``,
``custom`` and ``any`` validate options. It has no default value::

    worksheet.data_validation('A1', {'validate': 'integer',
                                     'criteria': '>',
                                     'value': 100})


Allowable values are:

+------------------------------+--------+
| ``between``                  |        |
+------------------------------+--------+
| ``not between``              |        |
+------------------------------+--------+
| ``equal to``                 | ``==`` |
+------------------------------+--------+
| ``not equal to``             | ``!=`` |
+------------------------------+--------+
| ``greater than``             | ``>``  |
+------------------------------+--------+
| ``less than``                | ``<``  |
+------------------------------+--------+
| ``greater than or equal to`` | ``>=`` |
+------------------------------+--------+
| ``less than or equal to``    | ``<=`` |
+------------------------------+--------+

You can either use Excel's textual description strings, in the first column
above, or the more common symbolic alternatives. The following are equivalent::

    worksheet.data_validation('A1', {'validate': 'integer',
                                     'criteria': '>',
                                     'value': 100})

    worksheet.data_validation('A1', {'validate': 'integer',
                                     'criteria': 'greater than',
                                     'value': 100})

The ``list``, ``custom`` and ``any`` validate options don't require a
``criteria``. If you specify one it will be ignored::

    worksheet.data_validation('B13', {'validate': 'list',
                                      'source': ['open', 'high', 'close']})

    worksheet.data_validation('B23', {'validate': 'custom',
                                      'value': '=AND(F5=50,G5=60)'})

value, minimum, source
**********************

The ``value`` parameter is used to set the limiting value to which the
``criteria`` is applied. It is always required and it has no default value.
You can also use the synonyms ``minimum`` or ``source`` to make the validation
a little clearer and closer to Excel's description of the parameter::

    # Using 'value'.
    worksheet.data_validation('A1', {'validate': 'integer',
                                     'criteria': 'greater than',
                                     'value': 100})

    # Using 'minimum'.
    worksheet.data_validation('B11', {'validate': 'decimal',
                                      'criteria': 'between',
                                      'minimum': 0.1,
                                      'maximum': 0.5})

    # Using 'source'.
    worksheet.data_validation('B10', {'validate': 'list',
                                      'source': '=$E$4:$G$4'})

    # Using 'source' with a string list.
    worksheet.data_validation('B13', {'validate': 'list',
                                      'source': ['open', 'high', 'close']})


Note, when using the ``list`` validation with a list of strings, like in the
last example above, Excel stores the strings internally as a Comma Separated
Variable string. The total length for this string, including commas, cannot
exceed the Excel limit of 255 characters. For longer sets of data you should
use a range reference like the prior example above. Also any double quotes in
strings like ``'"Hello"'`` must be double quoted like this ``'""Hello""'``.


maximum
*******

The ``maximum`` parameter is used to set the upper limiting value when the
``criteria`` is either ``'between'`` or ``'not between'``::

    worksheet.data_validation('B11', {'validate': 'decimal',
                                      'criteria': 'between',
                                      'minimum': 0.1,
                                      'maximum': 0.5})


ignore_blank
************

The ``ignore_blank`` parameter is used to toggle on and off the 'Ignore blank'
option in the Excel data validation dialog. When the option is on the data
validation is not applied to blank data in the cell. It is on by default::

        worksheet.data_validation('B5', {'validate': 'integer',
                                         'criteria': 'between',
                                         'minimum': 1,
                                         'maximum': 10,
                                         'ignore_blank': False,
                                         })


dropdown
********

The ``dropdown`` parameter is used to toggle on and off the 'In-cell dropdown'
option in the Excel data validation dialog. When the option is on a dropdown
list will be shown for ``list`` validations. It is on by default.


input_title
***********

The ``input_title`` parameter is used to set the title of the input message
that is displayed when a cell is entered. It has no default value and is only
displayed if the input message is displayed. See the ``input_message``
parameter below.

The maximum title length is 32 characters.


input_message
*************

The ``input_message`` parameter is used to set the input message that is
displayed when a cell is entered. It has no default value::

    worksheet.data_validation('B25', {'validate': 'integer',
                                      'criteria': 'between',
                                      'minimum': 1,
                                      'maximum': 100,
                                      'input_title': 'Enter an integer:',
                                      'input_message': 'between 1 and 100'})

The input message generated from the above example is:

.. image:: _images/data_validate3.png

The message can be split over several lines using newlines. The maximum message
length is 255 characters.


show_input
**********

The ``show_input`` parameter is used to toggle on and off the 'Show input
message when cell is selected' option in the Excel data validation dialog.
When the option is off an input message is not displayed even if it has been
set using ``input_message``. It is on by default.


error_title
***********

The ``error_title`` parameter is used to set the title of the error message
that is displayed when the data validation criteria is not met. The default
error title is 'Microsoft Excel'. The maximum title length is 32 characters.


error_message
*************

The ``error_message`` parameter is used to set the error message that is
displayed when a cell is entered. The default error message is "The value you
entered is not valid. A user has restricted values that can be entered into
the cell.". A non-default error message can be displayed as follows::

    worksheet.data_validation('B27', {'validate': 'integer',
                                      'criteria': 'between',
                                      'minimum': 1,
                                      'maximum': 100,
                                      'input_title': 'Enter an integer:',
                                      'input_message': 'between 1 and 100',
                                      'error_title': 'Input value not valid!',
                                      'error_message': 'It should be an integer between 1 and 100'})

Which give the following message:

.. image:: _images/data_validate2.png

The message can be split over several lines using newlines. The maximum message
length is 255 characters.


error_type
**********

The ``error_type`` parameter is used to specify the type of error dialog that
is displayed. There are 3 options::

    'stop'
    'warning'
    'information'

The default is ``'stop'``.


show_error
**********

The ``show_error`` parameter is used to toggle on and off the 'Show error alert
after invalid data is entered' option in the Excel data validation dialog.
When the option is off an error message is not displayed even if it has been
set using ``error_message``. It is on by default.


multi_range
***********

The ``multi_range`` option is used to extend a data validation over
non-contiguous ranges.

It is possible to apply the data validation to different cell ranges in a
worksheet using multiple calls to ``data_validation()``. However, as a
minor optimization it is also possible in Excel to apply the same data
validation to different non-contiguous cell ranges.

This is replicated in ``data_validation()`` using the ``multi_range``
option. The range must contain the primary range for the data validation
and any others separated by spaces.

For example to apply one data validation to two ranges, ``'B3:K6'`` and
``'B9:K12'``::

    worksheet.data_validation('B3:K6', {'validate': 'integer',
                                        'criteria': 'between',
                                        'minimum': 1,
                                        'maximum': 100,
                                        'multi_range': 'B3:K6 B9:K12'})


Data Validation Examples
------------------------

Example 1. Limiting input to an integer greater than a fixed value::

    worksheet.data_validation('A1', {'validate': 'integer',
                                     'criteria': '>',
                                     'value': 0,
                                     })

Example 2. Limiting input to an integer greater than a fixed value where the
value is referenced from a cell::

    worksheet.data_validation('A2', {'validate': 'integer',
                                     'criteria': '>',
                                     'value': '=E3',
                                     })

Example 3. Limiting input to a decimal in a fixed range::

    worksheet.data_validation('A3', {'validate': 'decimal',
                                     'criteria': 'between',
                                     'minimum': 0.1,
                                     'maximum': 0.5,
                                     })

Example 4. Limiting input to a value in a dropdown list::

    worksheet.data_validation('A4', {'validate': 'list',
                                     'source': ['open', 'high', 'close'],
                                     })

Example 5. Limiting input to a value in a dropdown list where the list is
specified as a cell range::

    worksheet.data_validation('A5', {'validate': 'list',
                                     'source': '=$E$4:$G$4',
                                     })

Example 6. Limiting input to a date in a fixed range::

    from datetime import date

    worksheet.data_validation('A6', {'validate': 'date',
                                     'criteria': 'between',
                                     'minimum': date(2013, 1, 1),
                                     'maximum': date(2013, 12, 12),
                                     })

Example 7. Displaying a message when the cell is selected::

    worksheet.data_validation('A7', {'validate': 'integer',
                                     'criteria': 'between',
                                     'minimum': 1,
                                     'maximum': 100,
                                     'input_title': 'Enter an integer:',
                                     'input_message': 'between 1 and 100',
                                     })

See also :ref:`ex_data_valid`.

================
File: dev/docs/source/working_with_data.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _working_with_data:

Working with and Writing Data
=============================

The following sections explain how to write various types of data to an Excel
worksheet using XlsxWriter.

.. _writing_cells:

Writing data to a worksheet cell
--------------------------------

The ``worksheet`` :func:`write` method is the most common means of writing
Python data to cells based on its type::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('write_data.xlsx')
    worksheet = workbook.add_worksheet()

    worksheet.write(0, 0, 1234)     # Writes an int
    worksheet.write(1, 0, 1234.56)  # Writes a float
    worksheet.write(2, 0, 'Hello')  # Writes a string
    worksheet.write(3, 0, None)     # Writes None
    worksheet.write(4, 0, True)     # Writes a bool

    workbook.close()


.. image:: _images/write_data1.png

The ``write()`` method uses the ``type()`` of the data to determine which
specific method to use for writing the data. These methods then map some basic
Python types to corresponding Excel types. The mapping is as follows:

======================   ==============   =====================================
Python type              Excel type       Worksheet methods
======================   ==============   =====================================
``int``                  Number           :func:`write`, :func:`write_number`
``long``
``float``
``Decimal``
``Fraction``
``basestring``           String           :func:`write`, :func:`write_string`
``str``
``unicode``
``None``                 String (blank)   :func:`write`, :func:`write_blank`
``datetime.date``        Number           :func:`write`, :func:`write_datetime`
``datetime.datetime``
``datetime.time``
``datetime.timedelta``
``bool``                 Boolean          :func:`write`, :func:`write_boolean`
======================   ==============   =====================================

The ``write()`` method also handles a few other Excel types that are
encoded as Python strings in XlsxWriter:

======================   ==============   =====================================
Pseudo-type              Excel type       Worksheet methods
======================   ==============   =====================================
formula string           Formula          :func:`write`, :func:`write_formula`
url string               URL              :func:`write`, :func:`write_url`
======================   ==============   =====================================

It should be noted that Excel has a very limited set of types to map to. The
Python types that the ``write()`` method can handle can be extended as
explained in the :ref:`writing_user_types` section below.

.. _writing_unicode:

Writing unicode data
---------------------

Unicode data in Excel is encoded as UTF-8. XlsxWriter also supports writing
UTF-8 data. This generally requires that your source file is UTF-8 encoded::

    worksheet.write('A1', 'Some UTF-8 text')

.. image:: _images/worksheet02.png

See :ref:`ex_unicode` for a more complete example.

Alternatively, you can read data from an encoded file, convert it to UTF-8
during reading and then write the data to an Excel file. See
:ref:`ex_unicode_polish_utf8` and :ref:`ex_unicode_shift_jis`.


.. _writing_lists:

Writing lists of data
---------------------

Writing compound data types such as lists with XlsxWriter is done the same way
it would be in any other Python program: with a loop. The Python
:func:`enumerate` function is also very useful in this context::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('write_list.xlsx')
    worksheet = workbook.add_worksheet()

    my_list = [1, 2, 3, 4, 5]

    for row_num, data in enumerate(my_list):
        worksheet.write(row_num, 0, data)

    workbook.close()

.. image:: _images/write_list1.png

Or if you wanted to write this horizontally as a row::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('write_list.xlsx')
    worksheet = workbook.add_worksheet()

    my_list = [1, 2, 3, 4, 5]

    for col_num, data in enumerate(my_list):
        worksheet.write(0, col_num, data)

    workbook.close()

.. image:: _images/write_list2.png

For a list of lists structure you would use two loop levels::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('write_list.xlsx')
    worksheet = workbook.add_worksheet()

    my_list = [[1, 1, 1, 1, 1],
               [2, 2, 2, 2, 1],
               [3, 3, 3, 3, 1],
               [4, 4, 4, 4, 1],
               [5, 5, 5, 5, 1]]

    for row_num, row_data in enumerate(my_list):
        for col_num, col_data in enumerate(row_data):
            worksheet.write(row_num, col_num, col_data)

    workbook.close()

.. image:: _images/write_list3.png


The :ref:`worksheet <worksheet>` class has two utility functions called
:func:`write_row` and :func:`write_column` which are basically a loop around
the :func:`write` method::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('write_list.xlsx')
    worksheet = workbook.add_worksheet()

    my_list = [1, 2, 3, 4, 5]

    worksheet.write_row(0, 1, my_list)
    worksheet.write_column(1, 0, my_list)

    workbook.close()


.. image:: _images/write_list4.png


.. _writing_dicts:

Writing dicts of data
---------------------

Unlike lists there is no single simple way to write a Python dictionary to an
Excel worksheet using Xlsxwriter. The method will depend of the structure of
the data in the dictionary. Here is a simple example for a simple data
structure::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('write_dict.xlsx')
    worksheet = workbook.add_worksheet()

    my_dict = {'Bob': [10, 11, 12],
               'Ann': [20, 21, 22],
               'May': [30, 31, 32]}

    col_num = 0
    for key, value in my_dict.items():
        worksheet.write(0, col_num, key)
        worksheet.write_column(1, col_num, value)
        col_num += 1

    workbook.close()

.. image:: _images/write_dict1.png


.. _writing_dataframes:

Writing dataframes
------------------

The best way to deal with dataframes or complex data structure is to use
Python `Pandas <https://pandas.pydata.org/>`_. Pandas is a Python data analysis
library. It can read, filter and re-arrange small and large data sets and
output them in a range of formats including Excel.

To use XlsxWriter with Pandas you specify it as the Excel writer *engine*::

    import pandas as pd

    # Create a Pandas dataframe from the data.
    df = pd.DataFrame({'Data': [10, 20, 30, 20, 15, 30, 45]})

    # Create a Pandas Excel writer using XlsxWriter as the engine.
    writer = pd.ExcelWriter('pandas_simple.xlsx', engine='xlsxwriter')

    # Convert the dataframe to an XlsxWriter Excel object.
    df.to_excel(writer, sheet_name='Sheet1')

    # Close the Pandas Excel writer and output the Excel file.
    writer.close()

The output from this would look like the following:

.. image:: _images/pandas_simple.png

For more information on using Pandas with XlsxWriter see :ref:`ewx_pandas`.


.. _writing_user_types:

Writing user defined types
--------------------------

As shown in the first section above, the worksheet :func:`write` method
maps the main Python data types to Excel's data types. If you want to write an
unsupported type then you can either avoid ``write()`` and map the user type
in your code to one of the more specific write methods or you can extend it
using the :func:`add_write_handler` method. This can be, occasionally, more
convenient then adding a lot of if/else logic to your code.

As an example, say you wanted to modify ``write()`` to automatically write
:mod:`uuid` types as strings. You would start by creating a function that
takes the uuid, converts it to a string and then writes it using
:func:`write_string`::

    def write_uuid(worksheet, row, col, uuid, cell_format=None):
        return worksheet.write_string(row, col, str(uuid), cell_format)

You could then add a handler that matches the ``uuid`` type and calls your
user defined function::

    #                           match,     action()
    worksheet.add_write_handler(uuid.UUID, write_uuid)

Then you can use ``write()`` without further modification::

    my_uuid = uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')

    # Write the UUID. This would raise a TypeError without the handler.
    worksheet.write('A1', my_uuid)

.. image:: _images/user_types4.png

Multiple callback functions can be added using :func:`add_write_handler()` but
only one callback action is allowed per type. However, it is valid to use the
same callback function for different types::

    worksheet.add_write_handler(int,   test_number_range)
    worksheet.add_write_handler(float, test_number_range)


.. _writing_user_types2:

How the write handler feature works
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :func:`write` method is mainly a large ``if()`` statement that checks the
``type()`` of the input value and calls the appropriate worksheet method to
write the data. The :func:`add_write_handler` method works by injecting
additional type checks and associated actions into this ``if()`` statement.

Here is a simplified version of the ``write()`` method::

    def write(self, row, col, *args):

        # The first arg should be the token for all write calls.
        token = args[0]

        # Get the token type.
        token_type = type(token)

        # Check for any user defined type handlers with callback functions.
        if token_type in self.write_handlers:
            write_handler = self.write_handlers[token_type]
            function_return = write_handler(self, row, col, *args)

            # If the return value is None then the callback has returned
            # control to this function and we should continue as
            # normal. Otherwise we return the value to the caller and exit.
            if function_return is None:
                pass
            else:
                return function_return

        # Check for standard Python types, if we haven't returned already.
        if token_type is bool:
            return self.write_boolean(row, col, *args)

        # Etc. ...


.. _writing_user_types3:

The syntax of write handler functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Functions used in the :func:`add_write_handler` method should have the
following method signature/parameters::

    def my_function(worksheet, row, col, token, cell_format=None):
        return worksheet.write_string(row, col, token, cell_format)

The function will be passed a :ref:`worksheet <worksheet>` instance, an
integer ``row`` and ``col`` value, a ``token`` that matches the type added to
:func:`add_write_handler` and some additional parameters. Usually the
additional parameter(s) will only be a cell :ref:`format <format>`
instance. However, if you need to handle other additional parameters, such as
those passed to :func:`write_url` then you can have more generic handling
like this::

    def my_function(worksheet, row, col, token, *args):
        return worksheet.write_string(row, col, token, *args)

Note, you don't have to explicitly handle ``A1`` style cell ranges. These will
be converted to row and column values prior to your function being called.

You can also make use of the ``row`` and ``col`` parameters to control the
logic of the function. Say for example you wanted to hide/replace user
passwords with '\*\*\*\*' when writing string data. If your data was
structured so that the password data was in the second column, apart from the
header row, you could write a handler function like this::

    def hide_password(worksheet, row, col, string, cell_format=None):
        if col == 1 and row > 0:
            return worksheet.write_string(row, col, '****', cell_format)
        else:
            return worksheet.write_string(row, col, string, cell_format)

.. image:: _images/user_types5.png


.. _writing_user_types4:

The return value of write handler functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Functions used in the :func:`add_write_handler` method should return one of
the following values:

* ``None``: to indicate that control is return to the parent :func:`write`
  method to continue as normal. This is used if your handler function logic
  decides that you don't need to handle the matched token.
* The return value of the called ``write_xxx()`` function. This is generally 0
  for no error and a negative number for errors. This causes an immediate
  return from the calling ``write()`` method with the return value that was
  passed back.

For example, say you wanted to ignore ``NaN`` values in your data since Excel
doesn't support them. You could create a handler function like the following
that matched against floats and which wrote a blank cell if it was a ``NaN``
or else just returned to ``write()`` to continue as normal::

    def ignore_nan(worksheet, row, col, number, cell_format=None):
        if math.isnan(number):
            return worksheet.write_blank(row, col, None, cell_format)
        else:
            # Return control to the calling write() method.
            return None

If you wanted to just drop the ``NaN`` values completely and not add any
formatting to the cell you could just return 0, for no error::

    def ignore_nan(worksheet, row, col, number, cell_format=None):
        if math.isnan(number):
            return 0
        else:
            # Return control to the calling write() method.
            return None

Write handler examples
~~~~~~~~~~~~~~~~~~~~~~

See the following, more complete, examples of handling user data types:

* :ref:`ex_user_type1`
* :ref:`ex_user_type2`
* :ref:`ex_user_type3`

================
File: dev/docs/source/working_with_dates_and_time.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _working_with_dates_and_time:

Working with Dates and Time
===========================

Dates and times in Excel are represented by real numbers, for example "Jan 1
2013 12:00 PM" is represented by the number 41275.5.

The integer part of the number stores the number of days since the epoch and
the fractional part stores the percentage of the day.

A date or time in Excel is just like any other number. To display the number as
a date you must apply an Excel number format to it. Here are some examples:

.. code-block:: python

    import xlsxwriter

    workbook = xlsxwriter.Workbook('date_examples.xlsx')
    worksheet = workbook.add_worksheet()

    # Widen column A for extra visibility.
    worksheet.set_column('A:A', 30)

    # A number to convert to a date.
    number = 41333.5

    # Write it as a number without formatting.
    worksheet.write('A1', number)                # 41333.5

    format2 = workbook.add_format({'num_format': 'dd/mm/yy'})
    worksheet.write('A2', number, format2)       # 28/02/13

    format3 = workbook.add_format({'num_format': 'mm/dd/yy'})
    worksheet.write('A3', number, format3)       # 02/28/13

    format4 = workbook.add_format({'num_format': 'd-m-yyyy'})
    worksheet.write('A4', number, format4)       # 28-2-2013

    format5 = workbook.add_format({'num_format': 'dd/mm/yy hh:mm'})
    worksheet.write('A5', number, format5)       # 28/02/13 12:00

    format6 = workbook.add_format({'num_format': 'd mmm yyyy'})
    worksheet.write('A6', number, format6)       # 28 Feb 2013

    format7 = workbook.add_format({'num_format': 'mmm d yyyy hh:mm AM/PM'})
    worksheet.write('A7', number, format7)       # Feb 28 2013 12:00 PM

    workbook.close()

.. image:: _images/working_with_dates_and_times01.png

To make working with dates and times a little easier the XlsxWriter module
provides a :func:`write_datetime` method to write dates in standard library
:mod:`datetime` format.

Specifically it supports datetime objects of type :class:`datetime.datetime`,
:class:`datetime.date`, :class:`datetime.time` and :class:`datetime.timedelta`.

There are many way to create datetime objects, for example the
:meth:`datetime.datetime.strptime` method::

    date_time = datetime.datetime.strptime('2013-01-23', '%Y-%m-%d')

See the :mod:`datetime` documentation for other date/time creation methods.

As explained above you also need to create and apply a number format to format
the date/time::

    date_format = workbook.add_format({'num_format': 'd mmmm yyyy'})
    worksheet.write_datetime('A1', date_time, date_format)

    # Displays "23 January 2013"

Here is a longer example that displays the same date in a several different
formats:

.. code-block:: python

    from datetime import datetime
    import xlsxwriter

    # Create a workbook and add a worksheet.
    workbook = xlsxwriter.Workbook('datetimes.xlsx')
    worksheet = workbook.add_worksheet()
    bold = workbook.add_format({'bold': True})

    # Expand the first columns so that the dates are visible.
    worksheet.set_column('A:B', 30)

    # Write the column headers.
    worksheet.write('A1', 'Formatted date', bold)
    worksheet.write('B1', 'Format', bold)

    # Create a datetime object to use in the examples.

    date_time = datetime.strptime('2013-01-23 12:30:05.123',
                                  '%Y-%m-%d %H:%M:%S.%f')

    # Examples date and time formats.
    date_formats = (
        'dd/mm/yy',
        'mm/dd/yy',
        'dd m yy',
        'd mm yy',
        'd mmm yy',
        'd mmmm yy',
        'd mmmm yyy',
        'd mmmm yyyy',
        'dd/mm/yy hh:mm',
        'dd/mm/yy hh:mm:ss',
        'dd/mm/yy hh:mm:ss.000',
        'hh:mm',
        'hh:mm:ss',
        'hh:mm:ss.000',
    )

    # Start from first row after headers.
    row = 1

    # Write the same date and time using each of the above formats.
    for date_format_str in date_formats:

        # Create a format for the date or time.
        date_format = workbook.add_format({'num_format': date_format_str,
                                          'align': 'left'})

        # Write the same date using different formats.
        worksheet.write_datetime(row, 0, date_time, date_format)

        # Also write the format string for comparison.
        worksheet.write_string(row, 1, date_format_str)

        row += 1

    workbook.close()

.. image:: _images/working_with_dates_and_times02.png


Default Date Formatting
-----------------------

In certain circumstances you may wish to apply a default date format when
writing datetime objects, for example, when handling a row of data with
:func:`write_row`.

In these cases it is possible to specify a default date format string using the
:func:`Workbook` constructor ``default_date_format`` option::

    workbook = xlsxwriter.Workbook('datetimes.xlsx', {'default_date_format':
                                                      'dd/mm/yy'})
    worksheet = workbook.add_worksheet()
    date_time = datetime.now()
    worksheet.write_datetime(0, 0, date_time)  # Formatted as 'dd/mm/yy'

    workbook.close()


.. _timezone_handling:

Timezone Handling
-----------------

Excel doesn't support timezones in datetimes/times so there isn't any fail-safe
way that XlsxWriter can map a Python timezone aware datetime into an Excel
datetime. As such the user should handle the timezones in some way that makes
sense according to their requirements. Usually this will require some
conversion to a timezone adjusted time and the removal of the ``tzinfo`` from
the datetime object so that it can be passed to :func:`write_datetime`::

    utc_datetime = datetime(2016, 9, 23, 14, 13, 21, tzinfo=utc)
    naive_datetime = utc_datetime.replace(tzinfo=None)

    worksheet.write_datetime(row, 0, naive_datetime, date_format)

Alternatively the :func:`Workbook` constructor option ``remove_timezone`` can
be used to strip the timezone from datetime values passed to
:func:`write_datetime`. The default is ``False``. To enable this option use::

    workbook = xlsxwriter.Workbook(filename, {'remove_timezone': True})

When :ref:`ewx_pandas` you can pass the argument as follows::

    writer = pd.ExcelWriter('pandas_example.xlsx',
                            engine='xlsxwriter',
                            options={'remove_timezone': True})

================
File: dev/docs/source/working_with_formulas.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _working_with_formulas:

Working with Formulas
=====================

In general a formula in Excel can be used directly in the
:func:`write_formula` method::

    worksheet.write_formula('A1', '=10*B1 + C1')

.. image:: _images/working_with_formulas1.png

However, there are a few potential issues and differences that the user should
be aware of. These are explained in the following sections.


.. _formula_syntax:

Non US Excel functions and syntax
---------------------------------

Excel stores formulas in the format of the US English version, regardless
of the language or locale of the end-user's version of Excel. Therefore all
formula function names written using XlsxWriter must be in English::

    worksheet.write_formula('A1', '=SUM(1, 2, 3)')    # OK
    worksheet.write_formula('A2', '=SOMME(1, 2, 3)')  # French. Error on load.

Also, formulas must be written with the US style separator/range operator
which is a comma (not semi-colon). Therefore a formula with multiple values
should be written as follows::

    worksheet.write_formula('A1', '=SUM(1, 2, 3)')   # OK
    worksheet.write_formula('A2', '=SUM(1; 2; 3)')   # Semi-colon. Error on load.

If you have a non-English version of Excel you can use the following
multi-lingual `formula translator <https://en.excel-translator.de/language/>`_
to help you convert the formula. It can also replace semi-colons with commas.

.. _formula_result:

Formula Results
---------------

XlsxWriter doesn't calculate the result of a formula and instead stores the
value 0 as the formula result. It then sets a global flag in the XLSX file to
say that all formulas and functions should be recalculated when the file is
opened.

This is the method recommended in the Excel documentation and in general it
works fine with spreadsheet applications. However, applications that don't
have a facility to calculate formulas will only display the 0
results. Examples of such applications are Excel Viewer, PDF Converters, and
some mobile device applications.

If required, it is also possible to specify the calculated result of the
formula using the optional ``value`` parameter for :func:`write_formula`::

    worksheet.write_formula('A1', '=2+2', num_format, 4)

The ``value`` parameter can be a number, a string, a bool or one of the
following Excel error codes::

    #DIV/0!
    #N/A
    #NAME?
    #NULL!
    #NUM!
    #REF!
    #VALUE!

It is also possible to specify the calculated result of an array formula
created with :func:`write_array_formula`::

    # Specify the result for a single cell range.
    worksheet.write_array_formula('A1:A1', '{=SUM(B1:C1*B2:C2)}', cell_format, 2005)

However, using this parameter only writes a single value to the upper left
cell in the result array. For a multi-cell array formula where the results are
required, the other result values can be specified by using ``write_number()``
to write to the appropriate cell::

    # Specify the results for a multi cell range.
    worksheet.write_array_formula('A1:A3', '{=TREND(C1:C3,B1:B3)}', cell_format, 15)
    worksheet.write_number('A2', 12, cell_format)
    worksheet.write_number('A3', 14, cell_format)


.. _formula_dynamic_arrays:

Dynamic Array support
---------------------

Excel introduced the concept of "Dynamic Arrays" and new functions that use
them in Office 365. The new functions are:

- ``BYCOL()``
- ``BYROW()``
- ``CHOOSECOLS()``
- ``CHOOSEROWS()``
- ``DROP()``
- ``EXPAND()``
- ``FILTER()``
- ``HSTACK()``
- ``MAKEARRAY()``
- ``MAP()``
- ``RANDARRAY()``
- ``REDUCE()``
- ``SCAN()``
- ``SEQUENCE()``
- ``SORT()``
- ``SORTBY()``
- ``SWITCH()``
- ``TAKE()``
- ``TEXTSPLIT()``
- ``TOCOL()``
- ``TOROW()``
- ``UNIQUE()``
- ``VSTACK()``
- ``WRAPCOLS()``
- ``WRAPROWS()``
- ``XLOOKUP()``

The following special case functions were also added with Dynamic Arrays:

- ``SINGLE()`` - Explained below in :ref:`formula_intersection_operator`.
- ``ANCHORARRAY()`` - Explained below in :ref:`formula_spill_operator`.
- ``LAMBDA()`` and ``LET()`` - Explained below in :ref:`formula_lambda`.

Dynamic arrays are ranges of return values that can change in size based on
the results. For example, a function such as ``FILTER()`` returns an array of
values that can vary in size depending on the filter results. This is
shown in the snippet below from :ref:`ex_dynamic_arrays`::

    worksheet1.write('F2', '=FILTER(A1:D17,C1:C17=K2)')

Which gives the results shown in the image below. The dynamic range here is
"F2:I5" but it could be different based on the filter criteria.

.. image:: _images/dynamic_arrays02.png


It is also possible to get dynamic array behavior with older Excel
functions. For example, the Excel function ``=LEN(A1)`` applies to a single
cell and returns a single value but it is also possible to apply it to a range
of cells and return a range of values using an array formula like
``{=LEN(A1:A3)}``. This type of "static" array behavior is called a CSE
(Ctrl+Shift+Enter) formula. With the introduction of dynamic arrays in Excel
365 you can now write this function as ``=LEN(A1:A3)`` and get a dynamic range
of return values. In XlsxWriter you can use the :func:`write_array_formula`
worksheet method to get a static/CSE range and
:func:`write_dynamic_array_formula` to get a dynamic range. For example::

    worksheet.write_dynamic_array_formula('B1:B3', '=LEN(A1:A3)')

Which gives the following result:

.. image:: _images/intersection03.png

The difference between the two types of array functions is explained in the
Microsoft documentation on `Dynamic array formulas vs. legacy CSE array
formulas
<https://support.microsoft.com/en-us/office/dynamic-array-formulas-vs-legacy-cse-array-formulas-ca421f1b-fbb2-4c99-9924-df571bd4f1b4>`_. Note
the use of the word "legacy" here. This, and the documentation itself, is a
clear indication of the future importance of dynamic arrays in Excel.

For a wider and more general introduction to dynamic arrays see the following:
`Dynamic array formulas in Excel
<https://exceljet.net/articles/dynamic-array-formulas-in-excel>`_.

.. _formula_intersection_operator:

Dynamic Arrays - The Implicit Intersection Operator "@"
-------------------------------------------------------

The Implicit Intersection Operator, "@", is used by Excel 365 to indicate a
position in a formula that is implicitly returning a single value when a range
or an array could be returned.

We can see how this operator works in practice by considering the formula we
used in the last section: ``=LEN(A1:A3)``. In Excel versions without support
for dynamic arrays, i.e. prior to Excel 365, this formula would operate on a
single value from the input range and return a single value, like this:

.. image:: _images/intersection01.png

There is an implicit conversion here of the range of input values, "A1:A3", to
a single value "A1". Since this was the default behavior of older versions of
Excel this conversion isn't highlighted in any way. But if you open the same
file in Excel 365 it will appear as follows:

.. image:: _images/intersection02.png

The result of the formula is the same (this is important to note) and it still
operates on, and returns, a single value. However the formula now contains a
"@" operator to show that it is implicitly using a single value from the given
range.

Finally, if you entered this formula in Excel 365, or with
:func:`write_dynamic_array_formula` in XlsxWriter, it would operate on the
entire range and return an array of values:

.. image:: _images/intersection03.png

If you are encountering the Implicit Intersection Operator "@" for the first
time then it is probably from a point of view of "why is Excel/XlsxWriter
putting @s in my formulas". In practical terms if you encounter this operator,
and you don't intend it to be there, then you should probably write the
formula as a CSE or dynamic array function using :func:`write_array_formula`
or :func:`write_dynamic_array_formula` (see the previous section on
:ref:`formula_dynamic_arrays`).

A full explanation of this operator is shown in the Microsoft documentation on
the `Implicit intersection operator: @
<https://support.microsoft.com/en-us/office/implicit-intersection-operator-ce3be07b-0101-4450-a24e-c1c999be2b34?ui=en-us&rs=en-us&ad=us>`_.

One important thing to note is that the "@" operator isn't stored with the
formula. It is just displayed by Excel 365 when reading "legacy"
formulas. However, it is possible to write it to a formula, if necessary,
using ``SINGLE()`` or ``_xlfn.SINGLE()``. The unusual cases where this may be
necessary are shown in the linked document in the previous paragraph.

.. _formula_spill_operator:

Dynamic Arrays - The Spilled Range Operator "#"
-----------------------------------------------

In the section above on :ref:`formula_dynamic_arrays` we saw that dynamic
array formulas can return variable sized ranges of results. The Excel
documentation refers to this as a "Spilled" range/array from the idea that the
results spill into the required number of cells. This is explained in the
Microsoft documentation on `Dynamic array formulas and spilled array behavior
<https://support.microsoft.com/en-us/office/dynamic-array-formulas-and-spilled-array-behavior-205c6b06-03ba-4151-89a1-87a7eb36e531>`_.

Since a spilled range is variable in size a new operator is required to refer
to the range. This operator is the `Spilled range operator
<https://support.microsoft.com/en-us/office/spilled-range-operator-3dd5899f-bca2-4b9d-a172-3eae9ac22efd>`_
and it is represented by "#". For example, the range ``F2#`` in the image
below is used to refer to a dynamic array returned by ``UNIQUE()`` in the cell
``F2``. This example is taken from the XlsxWriter program :ref:`ex_dynamic_arrays`.

.. image:: _images/spill01.png

Unfortunately, Excel doesn't store the formula like this and in XlsxWriter you
need to use the explicit function ``ANCHORARRAY()`` to refer to a spilled
range. The example in the image above was generated using the following::

    worksheet9.write('J2', '=COUNTA(ANCHORARRAY(F2))')  # Same as '=COUNTA(F2#)' in Excel.


.. _formula_lambda:

The Excel 365 LAMBDA() function
-------------------------------

Recent versions of Excel 365 have introduced a powerful new
function/feature called ``LAMBDA()``. This is similar to the `lambda
<https://docs.python.org/3/howto/functional.html#small-functions-and-the-lambda-expression>`_
function in Python (and other languages).

Consider the following Excel example which converts the variable ``temp`` from Fahrenheit to Celsius::

    LAMBDA(temp, (5/9) * (temp-32))

This could be called in Excel with an argument::

    =LAMBDA(temp, (5/9) * (temp-32))(212)

Or assigned to a defined name and called as a user defined function::

    =ToCelsius(212)

This is similar to this example in Python::

    >>> to_celsius = lambda temp: (5.0/9.0) * (temp-32)
    >>> to_celsius(212)
    100.0

A XlsxWriter program that replicates the Excel is shown in :ref:`ex_lambda`.

The formula is written as follows::

    worksheet.write('A2', '=LAMBDA(_xlpm.temp, (5/9) * (_xlpm.temp-32))(32)')

Note, that the parameters in the ``LAMBDA()`` function must have a "_xlpm."
prefix for compatibility with how the formulas are stored in Excel. These
prefixes won't show up in the formula, as shown in the image.

.. image:: _images/lambda01.png

The ``LET()`` function is often used in conjunction with ``LAMBDA()`` to assign
names to calculation results.


.. _formula_future:

Formulas added in Excel 2010 and later
--------------------------------------

Excel 2010 and later added functions which weren't defined in the original
file specification. These functions are referred to by Microsoft as *future*
functions. Examples of these functions are ``ACOT``, ``CHISQ.DIST.RT`` ,
``CONFIDENCE.NORM``, ``STDEV.P``, ``STDEV.S`` and ``WORKDAY.INTL``.

When written using ``write_formula()`` these functions need to be fully
qualified with a ``_xlfn.`` (or other) prefix as they are shown the list
below. For example::

    worksheet.write_formula('A1', '=_xlfn.STDEV.S(B1:B10)')

These functions will appear without the prefix in Excel:

.. image:: _images/working_with_formulas2.png

Alternatively, you can enable the ``use_future_functions`` option in the
:func:`Workbook` constructor, which will add the prefix as required::

    workbook = Workbook('write_formula.xlsx', {'use_future_functions': True})

    # ...

    worksheet.write_formula('A1', '=STDEV.S(B1:B10)')

If the formula already contains a ``_xlfn.`` prefix, on any function, then the
formula will be ignored and won't be expanded any further.

.. Note::

   Enabling the `use_future_functions` option adds an overhead to all formula
   processing in XlsxWriter. If your application has a lot of formulas or is
   performance sensitive then it is best to use the explicit ``_xlfn.`` prefix
   instead.


The following list is taken from
`MS XLSX extensions documentation on future functions <https://learn.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/5d1b6d44-6fc1-4ecd-8fef-0b27406cc2bf>`_.

* ``_xlfn.ACOTH``
* ``_xlfn.ACOT``
* ``_xlfn.AGGREGATE``
* ``_xlfn.ARABIC``
* ``_xlfn.ARRAYTOTEXT``
* ``_xlfn.BASE``
* ``_xlfn.BETA.DIST``
* ``_xlfn.BETA.INV``
* ``_xlfn.BINOM.DIST.RANGE``
* ``_xlfn.BINOM.DIST``
* ``_xlfn.BINOM.INV``
* ``_xlfn.BITAND``
* ``_xlfn.BITLSHIFT``
* ``_xlfn.BITOR``
* ``_xlfn.BITRSHIFT``
* ``_xlfn.BITXOR``
* ``_xlfn.CEILING.MATH``
* ``_xlfn.CEILING.PRECISE``
* ``_xlfn.CHISQ.DIST.RT``
* ``_xlfn.CHISQ.DIST``
* ``_xlfn.CHISQ.INV.RT``
* ``_xlfn.CHISQ.INV``
* ``_xlfn.CHISQ.TEST``
* ``_xlfn.COMBINA``
* ``_xlfn.CONCAT``
* ``_xlfn.CONFIDENCE.NORM``
* ``_xlfn.CONFIDENCE.T``
* ``_xlfn.COTH``
* ``_xlfn.COT``
* ``_xlfn.COVARIANCE.P``
* ``_xlfn.COVARIANCE.S``
* ``_xlfn.CSCH``
* ``_xlfn.CSC``
* ``_xlfn.DAYS``
* ``_xlfn.DECIMAL``
* ``ECMA.CEILING``
* ``_xlfn.ERF.PRECISE``
* ``_xlfn.ERFC.PRECISE``
* ``_xlfn.EXPON.DIST``
* ``_xlfn.F.DIST.RT``
* ``_xlfn.F.DIST``
* ``_xlfn.F.INV.RT``
* ``_xlfn.F.INV``
* ``_xlfn.F.TEST``
* ``_xlfn.FILTERXML``
* ``_xlfn.FLOOR.MATH``
* ``_xlfn.FLOOR.PRECISE``
* ``_xlfn.FORECAST.ETS.CONFINT``
* ``_xlfn.FORECAST.ETS.SEASONALITY``
* ``_xlfn.FORECAST.ETS.STAT``
* ``_xlfn.FORECAST.ETS``
* ``_xlfn.FORECAST.LINEAR``
* ``_xlfn.FORMULATEXT``
* ``_xlfn.GAMMA.DIST``
* ``_xlfn.GAMMA.INV``
* ``_xlfn.GAMMALN.PRECISE``
* ``_xlfn.GAMMA``
* ``_xlfn.GAUSS``
* ``_xlfn.HYPGEOM.DIST``
* ``_xlfn.IFNA``
* ``_xlfn.IFS``
* ``_xlfn.IMAGE``
* ``_xlfn.IMCOSH``
* ``_xlfn.IMCOT``
* ``_xlfn.IMCSCH``
* ``_xlfn.IMCSC``
* ``_xlfn.IMSECH``
* ``_xlfn.IMSEC``
* ``_xlfn.IMSINH``
* ``_xlfn.IMTAN``
* ``_xlfn.ISFORMULA``
* ``_xlfn.ISOMITTED``
* ``_xlfn.ISOWEEKNUM``
* ``_xlfn.LET``
* ``_xlfn.LOGNORM.DIST``
* ``_xlfn.LOGNORM.INV``
* ``_xlfn.MAXIFS``
* ``_xlfn.MINIFS``
* ``_xlfn.MODE.MULT``
* ``_xlfn.MODE.SNGL``
* ``_xlfn.MUNIT``
* ``_xlfn.NEGBINOM.DIST``
* ``NETWORKDAYS.INTL``
* ``_xlfn.NORM.DIST``
* ``_xlfn.NORM.INV``
* ``_xlfn.NORM.S.DIST``
* ``_xlfn.NORM.S.INV``
* ``_xlfn.NUMBERVALUE``
* ``_xlfn.PDURATION``
* ``_xlfn.PERCENTILE.EXC``
* ``_xlfn.PERCENTILE.INC``
* ``_xlfn.PERCENTRANK.EXC``
* ``_xlfn.PERCENTRANK.INC``
* ``_xlfn.PERMUTATIONA``
* ``_xlfn.PHI``
* ``_xlfn.POISSON.DIST``
* ``_xlfn.QUARTILE.EXC``
* ``_xlfn.QUARTILE.INC``
* ``_xlfn.QUERYSTRING``
* ``_xlfn.RANK.AVG``
* ``_xlfn.RANK.EQ``
* ``_xlfn.RRI``
* ``_xlfn.SECH``
* ``_xlfn.SEC``
* ``_xlfn.SHEETS``
* ``_xlfn.SHEET``
* ``_xlfn.SKEW.P``
* ``_xlfn.STDEV.P``
* ``_xlfn.STDEV.S``
* ``_xlfn.T.DIST.2T``
* ``_xlfn.T.DIST.RT``
* ``_xlfn.T.DIST``
* ``_xlfn.T.INV.2T``
* ``_xlfn.T.INV``
* ``_xlfn.T.TEST``
* ``_xlfn.TEXTAFTER``
* ``_xlfn.TEXTBEFORE``
* ``_xlfn.TEXTJOIN``
* ``_xlfn.UNICHAR``
* ``_xlfn.UNICODE``
* ``_xlfn.VALUETOTEXT``
* ``_xlfn.VAR.P``
* ``_xlfn.VAR.S``
* ``_xlfn.WEBSERVICE``
* ``_xlfn.WEIBULL.DIST``
* ``WORKDAY.INTL``
* ``_xlfn.XMATCH``
* ``_xlfn.XOR``
* ``_xlfn.Z.TEST``

The dynamic array functions shown in the :ref:`formula_dynamic_arrays` section
above are also future functions:

* ``_xlfn.ANCHORARRAY``
* ``_xlfn.BYCOL``
* ``_xlfn.BYROW``
* ``_xlfn.CHOOSECOLS``
* ``_xlfn.CHOOSEROWS``
* ``_xlfn.DROP``
* ``_xlfn.EXPAND``
* ``_xlfn._xlws.FILTER``
* ``_xlfn.HSTACK``
* ``_xlfn.LAMBDA``
* ``_xlfn.MAKEARRAY``
* ``_xlfn.MAP``
* ``_xlfn.RANDARRAY``
* ``_xlfn.REDUCE``
* ``_xlfn.SCAN``
* ``_xlfn.SINGLE``
* ``_xlfn.SEQUENCE``
* ``_xlfn._xlws.SORT``
* ``_xlfn.SORTBY``
* ``_xlfn.SWITCH``
* ``_xlfn.TAKE``
* ``_xlfn.TEXTSPLIT``
* ``_xlfn.TOCOL``
* ``_xlfn.TOROW``
* ``_xlfn.UNIQUE``
* ``_xlfn.VSTACK``
* ``_xlfn.WRAPCOLS``
* ``_xlfn.WRAPROWS``
* ``_xlfn.XLOOKUP``


However, since these functions are part of a powerful new feature in Excel,
and likely to be very important to end users, they are converted automatically
from their shorter version to the explicit future function version by
XlsxWriter, even without the ``use_future_function`` option. If you need to
override the automatic conversion you can use the explicit versions with the
prefixes shown above.

.. _formula_tables:

Using Tables in Formulas
------------------------

Worksheet tables can be added with XlsxWriter using the :func:`add_table()`
method::

    worksheet.add_table('B3:F7', {options})

By default tables are named ``Table1``, ``Table2``, etc., in the order that
they are added. However it can also be set by the user using the ``name`` parameter::

    worksheet.add_table('B3:F7', {'name': 'SalesData'})

When used in a formula a table name such as ``TableX`` should be referred to
as ``TableX[]`` (like a Python list)::

    worksheet.write_formula('A5', '=VLOOKUP("Sales", Table1[], 2, FALSE')

.. _formula_errors:

Dealing with formula errors
---------------------------

If there is an error in the syntax of a formula it is usually displayed in
Excel as ``#NAME?``. Alternatively you may get a warning from Excel when the
file is loaded. If you encounter an error like this you can debug it as
follows:

#. Ensure the formula is valid in Excel by copying and pasting it into a
   cell. Note, this should be done in Excel and not other applications such as
   OpenOffice or LibreOffice since they may have slightly different syntax.

#. Ensure the formula is using comma separators instead of semi-colons, see
   :ref:`formula_syntax` above.

#. Ensure the formula is in English, see :ref:`formula_syntax` above.

#. Ensure that the formula doesn't contain an Excel 2010+ future function as
   listed above (:ref:`formula_future`). If it does then ensure that the
   correct prefix is used.

#. If the function loads in Excel but appears with one or more ``@`` symbols
   added then it is probably an array function and should be written using
   :func:`write_array_formula` or :func:`write_dynamic_array_formula` (see the
   sections above on :ref:`formula_dynamic_arrays` and
   :ref:`formula_intersection_operator`).

Finally if you have completed all the previous steps and still get a
``#NAME?`` error you can examine a valid Excel file to see what the correct
syntax should be. To do this you should create a valid formula in Excel and
save the file. You can then examine the XML in the unzipped file.

The following shows how to do that using Linux ``unzip`` and `libxml's xmllint
<https://gnome.pages.gitlab.gnome.org/libxml2/xmllint.html>`_ to format the XML for clarity::

    $ unzip myfile.xlsx -d myfile
    $ xmllint --format myfile/xl/worksheets/sheet1.xml | grep '</f>'

            <f>SUM(1, 2, 3)</f>

================
File: dev/docs/source/working_with_macros.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _macros:

Working with VBA Macros
=======================

This section explains how to add a VBA file containing functions or macros to an XlsxWriter file.

.. image:: _images/macros.png


The Excel XLSM file format
--------------------------

An Excel ``xlsm`` file is exactly the same as an ``xlsx`` file except that it
contains an additional ``vbaProject.bin`` file which contains functions and/or
macros. Excel uses a different extension to differentiate between the two file
formats since files containing macros are usually subject to additional
security checks.


How VBA macros are included in XlsxWriter
-----------------------------------------

The ``vbaProject.bin`` file is a binary OLE COM container. This was the format
used in older ``xls`` versions of Excel prior to Excel 2007. Unlike all of the
other components of an xlsx/xlsm file the data isn't stored in XML
format. Instead the functions and macros as stored as a pre-parsed binary
format. As such it wouldn't be feasible to define macros and create a
``vbaProject.bin`` file from scratch (at least not in the remaining lifespan
and interest levels of the author).

Instead a workaround is used to extract ``vbaProject.bin`` files from existing
xlsm files and then add these to XlsxWriter files.


The vba_extract.py utility
--------------------------

The ``vba_extract.py`` utility is used to extract the ``vbaProject.bin`` binary
from an Excel 2007+ xlsm file. The utility is included in the XlsxWriter
examples directory and is also installed as a standalone executable file::

    $ vba_extract.py macro_file.xlsm
    Extracted: vbaProject.bin

If the VBA project is signed, ``vba_extract.py`` also extracts the
``vbaProjectSignature.bin`` file from the xlsm file.


Adding the VBA macros to a XlsxWriter file
------------------------------------------

Once the ``vbaProject.bin`` file has been extracted it can be added to the
XlsxWriter workbook using the :func:`add_vba_project` method::

    workbook.add_vba_project('./vbaProject.bin')

If the VBA file contains functions you can then refer to them in calculations
using :func:`write_formula`::

    worksheet.write_formula('A1', '=MyMortgageCalc(200000, 25)')

Excel files that contain functions and macros should use an ``xlsm`` extension
or else Excel will complain and possibly not open the file::

    workbook = xlsxwriter.Workbook('macros.xlsm')

It is also possible to assign a macro to a button that is inserted into a
worksheet using the :func:`insert_button` method::

    import xlsxwriter

    # Note the file extension should be .xlsm.
    workbook = xlsxwriter.Workbook('macros.xlsm')
    worksheet = workbook.add_worksheet()

    worksheet.set_column('A:A', 30)

    # Add the VBA project binary.
    workbook.add_vba_project('./vbaProject.bin')

    # Show text for the end user.
    worksheet.write('A3', 'Press the button to say hello.')

    # Add a button tied to a macro in the VBA project.
    worksheet.insert_button('B3', {'macro':   'say_hello',
                                   'caption': 'Press Me',
                                   'width':   80,
                                   'height':  30})

    workbook.close()

It may be necessary to specify a more explicit macro name prefixed by the
workbook VBA name as follows::

    worksheet.insert_button('B3', {'macro': 'ThisWorkbook.say_hello'})

See :ref:`ex_macros` from the examples directory for a working example.

.. Note::
   Button is the only VBA Control supported by Xlsxwriter. Due to the large
   effort in implementation (1+ man months) it is unlikely that any other form
   elements will be added in the future.


Setting the VBA codenames
-------------------------

VBA macros generally refer to workbook and worksheet objects. If the VBA
codenames aren't specified then XlsxWriter will use the Excel defaults of
``ThisWorkbook`` and ``Sheet1``, ``Sheet2`` etc.

If the macro uses other codenames you can set them using the workbook and
worksheet ``set_vba_name()`` methods as follows::

      # Note: set codename for workbook and any worksheets.
      workbook.set_vba_name('MyWorkbook')
      worksheet1.set_vba_name('MySheet1')
      worksheet2.set_vba_name('MySheet2')

You can find the names that are used in the VBA editor or by unzipping the
``xlsm`` file and grepping the files. The following shows how to do that using
`libxml's xmllint <https://gnome.pages.gitlab.gnome.org/libxml2/xmllint.html>`_
to format the XML for clarity::


    $ unzip myfile.xlsm -d myfile
    $ xmllint --format `find myfile -name "*.xml" | xargs` | grep "Pr.*codeName"

      <workbookPr codeName="MyWorkbook" defaultThemeVersion="124226"/>
      <sheetPr codeName="MySheet"/>


.. Note::

   This step is particularly important for macros created with non-English
   versions of Excel.


Adding a VBA macro signature file to an XlsxWriter file
---------------------------------------------------------

VBA macros can be signed in Excel to allow for blocking execution of unsigned
macros in certain environments.

The ``vba_extract.py`` utility can be used to extract the ``vbaProject.bin`` and
``vbaProjectSignature.bin`` files from an existing xlsm file with signed macros.

To add these files to the XlsxWriter workbook using the
:func:`add_signed_vba_project` method::

    workbook.add_signed_vba_project("./vbaProject.bin", "./vbaProjectSignature.bin");


What to do if it doesn't work
-----------------------------

The XlsxWriter test suite contains several tests to ensure that this feature
works and there is a working example as shown above. However, there is no
guarantee that it will work in all cases. Some effort may be required and some
knowledge of VBA will certainly help. If things don't work out here are some
things to try:

#. Start with a simple macro file, ensure that it works and then add complexity.

#. Check the code names that macros use to refer to the workbook and
   worksheets (see the previous section above). In general VBA uses a code
   name of ``ThisWorkbook`` to refer to the current workbook and the sheet
   name (such as ``Sheet1``) to refer to the worksheets. These are the
   defaults used by XlsxWriter. If the macro uses other names, or the macro
   was extracted from an non-English language version of Excel, then you can
   specify these using the workbook and worksheet :func:`set_vba_name`
   methods::

      # Note: set codename for workbook and any worksheets.
      workbook.set_vba_name('MyWorkbook')
      worksheet1.set_vba_name('MySheet1')
      worksheet2.set_vba_name('MySheet2')

#. Try to extract the macros from an Excel 2007 file. The method should work
   with macros from later versions (it was also tested with Excel 2010
   macros). However there may be features in the macro files of more recent
   version of Excel that aren't backward compatible.

================
File: dev/docs/source/working_with_memory.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _memory_perf:

Working with Memory and Performance
===================================

By default XlsxWriter holds all cell data in memory. This is to allow future
features when formatting is applied separately from the data.

The effect of this is that XlsxWriter can consume a lot of memory and it is
possible to run out of memory when creating large files.

Fortunately, this memory usage can be reduced almost completely by using the
:func:`Workbook` ``'constant_memory'`` property::

    workbook = xlsxwriter.Workbook(filename, {'constant_memory': True})

The optimization works by flushing each row after a subsequent row is written.
In this way the largest amount of data held in memory for a worksheet is the
amount of data required to hold a single row of data.

Since each new row flushes the previous row, data must be written in sequential
row order when ``'constant_memory'`` mode is on::

    # Ok. With 'constant_memory' you must write data in row by column order.
    for row in range(0, row_max):
        for col in range(0, col_max):
            worksheet.write(row, col, some_data)

    # Not ok. With 'constant_memory' this will only write the first column of data.
    for col in range(0, col_max):
        for row in range(0, row_max):
            worksheet.write(row, col, some_data)

Another optimization that is used to reduce memory usage is that cell strings
aren't stored in an Excel structure call "shared strings" and instead are
written "in-line". This is a documented Excel feature that is supported by
most spreadsheet applications.

The trade-off when using ``'constant_memory'`` mode is that you won't be able
to take advantage of any new features that manipulate cell data after it is
written. Currently the :func:`add_table()` method doesn't work in this mode
and :func:`merge_range()` and :func:`set_row()` only work for the current row.


Performance Figures
-------------------

The performance figures below show execution time and memory usage for
worksheets of size ``N`` rows x 50 columns with a 50/50 mixture of strings and
numbers. The figures are taken from an arbitrary, mid-range, machine. Specific
figures will vary from machine to machine but the trends should be the same.

XlsxWriter in normal operation mode: the execution time and memory usage
increase more or less linearly with the number of rows:

+-------+---------+----------+----------------+
| Rows  | Columns | Time (s) | Memory (bytes) |
+=======+=========+==========+================+
| 200   | 50      | 0.43     | 2346728        |
+-------+---------+----------+----------------+
| 400   | 50      | 0.84     | 4670904        |
+-------+---------+----------+----------------+
| 800   | 50      | 1.68     | 8325928        |
+-------+---------+----------+----------------+
| 1600  | 50      | 3.39     | 17855192       |
+-------+---------+----------+----------------+
| 3200  | 50      | 6.82     | 32279672       |
+-------+---------+----------+----------------+
| 6400  | 50      | 13.66    | 64862232       |
+-------+---------+----------+----------------+
| 12800 | 50      | 27.60    | 128851880      |
+-------+---------+----------+----------------+

XlsxWriter in ``constant_memory`` mode: the execution time still increases
linearly with the number of rows but the memory usage remains small and
constant:

+-------+---------+----------+----------------+
| Rows  | Columns | Time (s) | Memory (bytes) |
+=======+=========+==========+================+
| 200   | 50      | 0.37     | 62208          |
+-------+---------+----------+----------------+
| 400   | 50      | 0.74     | 62208          |
+-------+---------+----------+----------------+
| 800   | 50      | 1.46     | 62208          |
+-------+---------+----------+----------------+
| 1600  | 50      | 2.93     | 62208          |
+-------+---------+----------+----------------+
| 3200  | 50      | 5.90     | 62208          |
+-------+---------+----------+----------------+
| 6400  | 50      | 11.84    | 62208          |
+-------+---------+----------+----------------+
| 12800 | 50      | 23.63    | 62208          |
+-------+---------+----------+----------------+

In ``constant_memory`` mode the performance should be approximately the same
as normal mode.

These figures were generated using programs in the ``dev/performance``
directory of the XlsxWriter repo.

================
File: dev/docs/source/working_with_object_positioning.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _object_position:

Working with Object Positioning
===============================

XlsxWriter positions worksheet objects such as images, charts and textboxes in
worksheets by calculating precise coordinates based on the object size, it's
DPI (for images) and any scaling that the user specifies. It also takes into
account the heights and widths of the rows and columns that the object
crosses. In this way objects maintain their original sizes even if the rows or
columns underneath change size or are hidden.

For example::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('image.xlsx')
    worksheet = workbook.add_worksheet()

    # Original image.
    worksheet.insert_image('B2', 'logo.png')

    # Same size as original, despite row/col changes.
    worksheet.insert_image('E8', 'logo.png')

    # Make column F narrower.
    worksheet.set_column('F:F', 2)

    # Hide row 10 (zero indexed).
    worksheet.set_row(9, None, None, {'hidden': True})

    workbook.close()

.. image:: _images/object_position1.png

As can be seen the inserted image sizes are the same even though the second
image crosses changed rows and columns.

However, there are two cases where the image scale may change with row or
columns changes. These are explained in the next two sections.

.. _object_position_auto_row_height:

Object scaling due to automatic row height adjustment
-----------------------------------------------------

The scaling of a image may be affected if is crosses a row that has its
default height changed due to a font that is larger than the default font size
or that has text wrapping turned on. In these cases Excel will automatically
calculate a row height based on the text when it loads the file. Since this
row height isn't available to XlsxWriter when it creates the file the object
may appear as if it is sized incorrectly. For example::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('image.xlsx')
    worksheet = workbook.add_worksheet()
    wrap_format = workbook.add_format({'text_wrap': True})

    worksheet.write('A9', 'Some text that wraps', wrap_format)

    worksheet.insert_image('B2', 'logo.png')
    worksheet.insert_image('B8', 'logo.png')

    workbook.close()

.. image:: _images/object_position2.png

As can be seen the second inserted image is distorted, compared to the first,
due to the row being scaled automatically. To avoid this you should explicitly
set the height of the row using ``set_row()`` if it crosses an inserted
object.

Object Positioning with Cell Moving and Sizing
----------------------------------------------

Excel supports three options for "Object Positioning" within a worksheet:

.. image:: _images/object_position3.png


Image, chart and textbox objects in XlsxWriter emulate these options using the
``object_position`` parameter::

    worksheet.insert_image('B3', 'python.png', {'object_position': 1})

Where ``object_position`` has one of the following allowable values:

1. Move and size with cells.
2. Move but donâ€™t size with cells.
3. Donâ€™t move or size with cells.
4. Same as Option 1 to "move and size with cells" except XlsxWriter applies
   hidden cells after the object is inserted.

Option 4 appears in Excel as Option 1. However, the worksheet object is sized
to take hidden rows or columns into account. This allows the user to hide an
image in a cell, possibly as part of an autofilter. For example::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('image.xlsx')
    worksheet = workbook.add_worksheet()

    worksheet.insert_image('B2', 'logo.png')
    worksheet.insert_image('B9', 'logo.png', {'object_position': 4})

    # Hide some rows.
    for row in range(1, 13):
        worksheet.set_row(row, None, None, {'hidden': True})

    workbook.close()

.. image:: _images/object_position4.png

In this example the first inserted image is visible over the hidden rows
whilst the second image is hidden with the rows. Unhiding the rows in Excel
would reveal the second image.

Image sizing and DPI
--------------------

When an image is imported into Excel the DPI (dots per inch) resolution of the
image is taken into account. Excel sizes the image according to a base DPI
of 96. Therefore an image with a DPI of 72 may appear slightly larger when
imported into Excel while an image with a DPI of 200 may appear twice as
small. XlsxWriter also reads the DPI of the images that the user inserts into
a worksheet and stores the image dimensions in the same way that Excel
does. If it cannot determine the DPI of the image it uses a default of 96.

Reporting issues with image insertion
-------------------------------------

A lot of work has gone into ensuring that XlsxWriter inserts images into
worksheets in exactly the same way that Excel does, even though the required
calculations and units are arcane. There are over 80 test cases that check
image insertion against files created in Excel to ensure that XlsxWriter's
handling of images is correct.

As such, before reporting any issues with image handling in XlsxWriter please
check how the same image is handled in Excel (not OpenOffice, LibreOffice or
other third party applications). If you do report an issue please use the
XlsxWriter
`Issue tracker is on GitHub <https://github.com/jmcnamara/XlsxWriter/issues>`_
and attach the image that demonstrates the issue.

================
File: dev/docs/source/working_with_outlines.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _outlines:

Working with Outlines and Grouping
==================================

Excel allows you to group rows or columns so that they can be hidden or
displayed with a single mouse click. This feature is referred to as outlines
and grouping.

Outlines can reduce complex data down to a few salient sub-totals or
summaries. For example the following is a worksheet with three outlines.

.. image:: _images/outline1.png

Rows 2 to 11 are grouped at level 1 and rows 2 to 5 and 7 to 10 are grouped at
level 2. The lines at the left hand side are called "outline level" bars and
the level is shown by the small numeral above the outline.

Clicking the minus sign on each of the level 2 outlines will collapse and hide
the data as shown below.

.. image:: _images/outline5.png

The minus sign changes to a plus sign to indicate that the data in the outline
is hidden. This shows the usefulness of outlines: with 2 mouse clicks we have
reduced the amount of visual data down to 2 sub-totals and the overall total.

Finally, clicking on the minus sign on the level 1 outline will collapse the
remaining rows as follows:

.. image:: _images/outline6.png


Outlines and Grouping in XlsxWriter
-----------------------------------

Grouping in ``XlsxWriter`` is achieved by setting the outline level via the
:func:`set_row()` and :func:`set_column()` worksheet methods::

    worksheet.set_row(row, height, cell_format, options)
    worksheet.set_column(first_col, last_col, width, cell_format, options)

Adjacent row or columns with the same outline level are grouped together into a
single outline.

The ``'options'`` parameter is a dictionary with the following possible keys:

* ``'hidden'``
* ``'level'``
* ``'collapsed'``

Options can be set as follows::

    worksheet.set_row(0, 20, cell_format, {'hidden': True})

    # Or use defaults for other properties and set the options only.
    worksheet.set_row(0, None, None, {'hidden': True})

The following example sets an outline level of 1 for rows 1 to 4
(zero-indexed) and columns B to G. The parameters ``height`` and
``cell_format`` are assigned default values::

    worksheet.set_row(1, None, None, {'level': 1})
    worksheet.set_row(2, None, None, {'level': 1})
    worksheet.set_row(3, None, None, {'level': 1})
    worksheet.set_row(4, None, None, {'level': 1})

    worksheet.set_column('B:G', None, None, {'level': 1})

.. image:: _images/outline3.png

Rows and columns can be collapsed by setting the ``hidden`` flag for the hidden
rows/columns and setting the ``collapsed`` flag for the row/column that has
the collapsed ``'+'`` symbol::

    worksheet.set_row(1, None, None, {'level': 1, 'hidden': True})
    worksheet.set_row(2, None, None, {'level': 1, 'hidden': True})
    worksheet.set_row(3, None, None, {'level': 1, 'hidden': True})
    worksheet.set_row(4, None, None, {'level': 1, 'hidden': True})
    worksheet.set_row(5, None, None, {'collapsed': True})

    worksheet.set_column('B:G', None, None, {'level': 1, 'hidden': True})
    worksheet.set_column('H:H', None, None, {'collapsed': True})

.. image:: _images/outline7.png

Excel allows up to 7 outline levels. Therefore the ``level`` parameter should
be in the range ``0 <= level <= 7``.

.. image:: _images/outline4.png

For a more complete examples see :ref:`ex_outline1` and :ref:`ex_outline2`.

Some additional outline properties can be set via the :func:`outline_settings`
worksheet method.

================
File: dev/docs/source/working_with_pandas.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ewx_pandas:

Working with Pandas and XlsxWriter
==================================

Python `Pandas <https://pandas.pydata.org/>`_ is a Python data analysis
library. It can read, filter and re-arrange small and large data sets and
output them in a range of formats including Excel.

Pandas writes Excel xlsx files using either `openpyxl
<https://pypi.org/project/openpyxl/>`_ or XlsxWriter.


Using XlsxWriter with Pandas
----------------------------

To use XlsxWriter with Pandas you specify it as the Excel writer *engine*::

    import pandas as pd

    # Create a Pandas dataframe from the data.
    df = pd.DataFrame({'Data': [10, 20, 30, 20, 15, 30, 45]})

    # Create a Pandas Excel writer using XlsxWriter as the engine.
    writer = pd.ExcelWriter('pandas_simple.xlsx', engine='xlsxwriter')

    # Convert the dataframe to an XlsxWriter Excel object.
    df.to_excel(writer, sheet_name='Sheet1')

    # Close the Pandas Excel writer and output the Excel file.
    writer.close()

The output from this would look like the following:

.. image:: _images/pandas_simple.png

See the full example at :ref:`ex_pandas_simple`.


Accessing XlsxWriter from Pandas
--------------------------------

In order to apply XlsxWriter features such as Charts, Conditional Formatting
and Column Formatting to the Pandas output we need to access the underlying
:ref:`workbook <Workbook>` and :ref:`worksheet <Worksheet>` objects. After
that we can treat them as normal XlsxWriter objects.

Continuing on from the above example we do that as follows::

    import pandas as pd

    # Create a Pandas dataframe from the data.
    df = pd.DataFrame({'Data': [10, 20, 30, 20, 15, 30, 45]})

    # Create a Pandas Excel writer using XlsxWriter as the engine.
    writer = pd.ExcelWriter('pandas_simple.xlsx', engine='xlsxwriter')

    # Convert the dataframe to an XlsxWriter Excel object.
    df.to_excel(writer, sheet_name='Sheet1')

    # Get the xlsxwriter objects from the dataframe writer object.
    workbook  = writer.book
    worksheet = writer.sheets['Sheet1']

This is equivalent to the following code when using XlsxWriter on its own::

    workbook  = xlsxwriter.Workbook('filename.xlsx')
    worksheet = workbook.add_worksheet()

The Workbook and Worksheet objects can then be used to access other XlsxWriter
features, see below.


Adding Charts to Dataframe output
---------------------------------

Once we have the Workbook and Worksheet objects, as shown in the previous
section, we we can use them to apply other features such as adding a chart::

    # Get the xlsxwriter objects from the dataframe writer object.
    workbook  = writer.book
    worksheet = writer.sheets['Sheet1']

    # Create a chart object.
    chart = workbook.add_chart({'type': 'column'})

    # Get the dimensions of the dataframe.
    (max_row, max_col) = df.shape

    # Configure the series of the chart from the dataframe data.
    chart.add_series({'values': ['Sheet1', 1, 1, max_row, 1]})

    # Insert the chart into the worksheet.
    worksheet.insert_chart(1, 3, chart)

The output would look like this:

.. image:: _images/pandas_chart.png

See the full example at :ref:`ex_pandas_chart`.


Adding Conditional Formatting to Dataframe output
-------------------------------------------------

Another option is to apply a conditional format like this::

    # Apply a conditional format to the required cell range.
    worksheet.conditional_format(1, max_col, max_row, max_col,
                                 {'type': '3_color_scale'})

Which would give:

.. image:: _images/pandas_conditional.png

See the full example at :ref:`ex_pandas_conditional` and the section of the
docs on :ref:`working_with_conditional_formats`.


Formatting of the Dataframe output
----------------------------------

XlsxWriter and Pandas provide very little support for formatting the output
data from a dataframe apart from default formatting such as the header and
index cells and any cells that contain dates or datetimes. In addition it
isn't possible to format any cells that already have a default format applied.

If you require very controlled formatting of the dataframe output then you
would probably be better off using Xlsxwriter directly with raw data taken
from Pandas. However, some formatting options are available.

For example it is possible to set the default date and datetime formats via
the Pandas interface::

    writer = pd.ExcelWriter("pandas_datetime.xlsx",
                            engine='xlsxwriter',
                            datetime_format='mmm d yyyy hh:mm:ss',
                            date_format='mmmm dd yyyy')

Which would give:

.. image:: _images/pandas_datetime.png

See the full example at :ref:`ex_pandas_datetime`.

It is possible to format any other, non date/datetime column data using
:func:`set_column()`::

    # Add some cell formats.
    format1 = workbook.add_format({'num_format': '#,##0.00'})
    format2 = workbook.add_format({'num_format': '0%'})

    # Set the column width and format.
    worksheet.set_column(1, 1, 18, format1)

    # Set the format but not the column width.
    worksheet.set_column(2, 2, None, format2)

.. image:: _images/pandas_column_formats.png

See the full example at :ref:`ex_pandas_column_formats`.


Formatting of the Dataframe headers
-----------------------------------

Pandas writes the dataframe header with a default cell format. Since it is a
cell format it cannot be overridden using :func:`set_row()`. If you wish to
use your own format for the headings then the best approach is to turn off the
automatic header from Pandas and write your own. For example::

    # Turn off the default header and skip one row to allow us to insert a
    # user defined header.
    df.to_excel(writer, sheet_name='Sheet1', startrow=1, header=False)

    # Get the xlsxwriter workbook and worksheet objects.
    workbook  = writer.book
    worksheet = writer.sheets['Sheet1']

    # Add a header format.
    header_format = workbook.add_format({
        'bold': True,
        'text_wrap': True,
        'valign': 'top',
        'fg_color': '#D7E4BC',
        'border': 1})

    # Write the column headers with the defined format.
    for col_num, value in enumerate(df.columns.values):
        worksheet.write(0, col_num + 1, value, header_format)

.. image:: _images/pandas_header_format.png

See the full example at :ref:`ex_pandas_header_format`.

Adding a Dataframe to a Worksheet Table
---------------------------------------

As explained in :ref:`tables`, tables in Excel are a way of grouping a range
of cells into a single entity, like this:

.. image:: _images/pandas_table.png

The way to do this with a Pandas dataframe is to first write the data without
the index or header, and by starting 1 row forward to allow space for the
table header::

    df.to_excel(writer, sheet_name='Sheet1',
                startrow=1, header=False, index=False)

We then create a list of headers to use in ``add_table()``::

    column_settings = [{'header': column} for column in df.columns]

Finally we add the Excel table structure, based on the dataframe `shape` and
with the column headers we generated from the dataframe columns::

    (max_row, max_col) = df.shape

    worksheet.add_table(0, 0, max_row, max_col - 1, {'columns': column_settings})

See the full example at :ref:`ex_pandas_table`.


Adding an autofilter to a Dataframe output
------------------------------------------

As explained in :ref:`working_with_autofilters`, autofilters in Excel are a
way of filtering a 2d range of data to only display rows that match a user
defined criteria.

The way to do this with a Pandas dataframe is to first write the data without
the index (unless you want to include it in the filtered data)::

    df.to_excel(writer, sheet_name='Sheet1', index=False)

We then get the dataframe `shape` and add the autofilter::

    worksheet.autofilter(0, 0, max_row, max_col - 1)

.. image:: _images/autofilter1.png

We can also add an optional filter criteria. The placeholder "Region" in the
filter is ignored and can be any string that adds clarity to the expression::

    worksheet.filter_column(0, 'Region == East')

However, it isn't enough to just apply the criteria. The rows that don't match
must also be hidden. We use Pandas to figure our which rows to hide::

    for row_num in (df.index[(df['Region'] != 'East')].tolist()):
        worksheet.set_row(row_num + 1, options={'hidden': True})

This gives us a filtered worksheet like this:

.. image:: _images/pandas_autofilter.png

See the full example at :ref:`ex_pandas_autofilter`.


Handling multiple Pandas Dataframes
-----------------------------------

It is possible to write more than one dataframe to a worksheet or to several
worksheets. For example to write multiple dataframes to multiple worksheets::

    # Write each dataframe to a different worksheet.
    df1.to_excel(writer, sheet_name='Sheet1')
    df2.to_excel(writer, sheet_name='Sheet2')
    df3.to_excel(writer, sheet_name='Sheet3')

See the full example at :ref:`ex_pandas_multiple`.

It is also possible to position multiple dataframes within the same
worksheet::


    # Position the dataframes in the worksheet.
    df1.to_excel(writer, sheet_name='Sheet1')  # Default position, cell A1.
    df2.to_excel(writer, sheet_name='Sheet1', startcol=3)
    df3.to_excel(writer, sheet_name='Sheet1', startrow=6)

    # Write the dataframe without the header and index.
    df4.to_excel(writer, sheet_name='Sheet1',
                 startrow=7, startcol=4, header=False, index=False)

.. image:: _images/pandas_positioning.png

See the full example at :ref:`ex_pandas_positioning`.


Passing XlsxWriter constructor options to Pandas
------------------------------------------------

XlsxWriter supports several :func:`Workbook` constructor options such as
``strings_to_urls()``. These can also be applied to the ``Workbook`` object
created by Pandas using the ``engine_kwargs`` keyword::

    writer = pd.ExcelWriter('pandas_example.xlsx',
                            engine='xlsxwriter',
                            engine_kwargs={'options': {'strings_to_numbers': True}})

Note, versions of Pandas prior to 1.3.0 used this syntax::

    writer = pd.ExcelWriter('pandas_example.xlsx',
                            engine='xlsxwriter',
                            options={'strings_to_numbers': True})



Saving the Dataframe output to a string
---------------------------------------

It is also possible to write the Pandas XlsxWriter DataFrame output to a
byte array::

    import pandas as pd
    import io

    # Create a Pandas dataframe from the data.
    df = pd.DataFrame({'Data': [10, 20, 30, 20, 15, 30, 45]})

    output = io.BytesIO()

    # Use the BytesIO object as the filehandle.
    writer = pd.ExcelWriter(output, engine='xlsxwriter')

    # Write the data frame to the BytesIO object.
    df.to_excel(writer, sheet_name='Sheet1')

    writer.close()
    xlsx_data = output.getvalue()

    # Do something with the data...

Note: This feature requires Pandas >= 0.17.


Additional Pandas and Excel Information
---------------------------------------

Here are some additional resources in relation to Pandas, Excel and XlsxWriter.

* The XlsxWriter Pandas examples later in the document: :ref:`pandas_examples`.

* The Pandas documentation on the `pandas.DataFrame.to_excel() method
  <https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_excel.html>`_.

* A more detailed tutorial on `Using Pandas and XlsxWriter to create Excel
  charts
  <https://pandas-xlsxwriter-charts.readthedocs.io/>`_.

* The series of articles on the "Practical Business Python" website about
  `Using Pandas and Excel <https://pbpython.com/tag/excel.html>`_.

================
File: dev/docs/source/working_with_polars.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _ewx_polars:

Working with Polars and XlsxWriter
==================================

`Polars <https://pola.rs/>`_ is a fast dataframe library for Rust and Python.

Polars provides very tight integration of XlsxWriter and supports a lot of
features such as conditional formats, tables, autofilters, autofit and others
without having to use the external library directly. At the same time it allows
use of native XlsxWriter workbook and worksheets objects to take advantage of
any features that it doesn't support.

Creating an Excel file from a dataframe with Polars is straightforward and
doesn't require any direct invocation of XlsxWriter. All that is required is to
use the ``write_excel()`` method with a Polars dataframe::

    import polars as pl

    df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

    df.write_excel(workbook="polars_simple.xlsx")

This is a complete example and the output from this would look like the
following:

.. image:: _images/polars_simple.png

The `write_excel()`_ API is explained in detail in the Polars documentation.

.. _write_excel(): https://docs.pola.rs/py-polars/html/reference/api/polars.DataFrame.write_excel.html

One interesting aspect of the Polars output is that it writes the dataframe as
an :ref:`Excel Data Table <tables>`. We will discuss this and other XlsxWriter
features that are available from ``write_excel()`` in the sections below.


Sharing XlsxWriter workbooks with Polars
----------------------------------------

In a majority of use cases you will be able to control the output workbook and
worksheets via the `write_excel()`_ APIs but there may be some situations you
may wish to start a normal XlsxWriter workbook and then add Polars data to it.

To do this you can create a :ref:`workbook <Workbook>` object and pass it to the
``workbook`` parameter of Polars ``write_excel()``::

    import xlsxwriter
    import polars as pl

    df = pl.DataFrame({"Data": [10, 20, 30, 20, 15]})

    with xlsxwriter.Workbook("polars_xlsxwriter.xlsx") as workbook:
        df.write_excel(workbook=workbook)

Output:

.. image:: _images/polars_xlsxwriter1.png

As can be seen from the image, Polars creates a new worksheet and adds the data
to it. However, you can also add Polars data to a worksheet created from
XlsxWriter::

    import xlsxwriter
    import polars as pl

    df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

    with xlsxwriter.Workbook("polars_xlsxwriter.xlsx") as workbook:
        # Create a new worksheet.
        worksheet = workbook.add_worksheet()

        # Do something with the worksheet.
        worksheet.write("A1", "The data below is added by Polars")

        # Write the Polars data to the worksheet created above, at an offset to
        # avoid overwriting the previous text.
        df.write_excel(workbook=workbook, worksheet="Sheet1", position="A2")

Output:

.. image:: _images/polars_xlsxwriter2.png

(See the example at :ref:`ex_polars_xlsxwriter`.)


Adding Charts to Dataframe output
---------------------------------

With the techniques shown above we can get access to the Workbook and Worksheet
objects and then use them to apply other features such as adding a chart::

    import xlsxwriter
    import polars as pl

    df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

    with xlsxwriter.Workbook("polars_chart.xlsx") as workbook:
        # Create the worksheet so we can reuse it later.
        worksheet = workbook.add_worksheet()

        # Write the Polars data to the worksheet created above.
        df.write_excel(workbook=workbook, worksheet="Sheet1")

        # Create a chart object.
        chart = workbook.add_chart({"type": "column"})

        # Get the dimensions of the dataframe.
        (max_row, max_col) = df.shape

        # Configure the series of the chart from the dataframe data.
        chart.add_series({"values": ["Sheet1", 1, max_col - 1, max_row, max_col - 1]})

        # Insert the chart into the worksheet.
        worksheet.insert_chart(1, 3, chart)

The output would look like this:

.. image:: _images/polars_chart.png

(See the example at :ref:`ex_polars_chart`.)


Adding Conditional Formatting to Dataframe output
-------------------------------------------------

Following on from the technique shown in the previous sections we could also add
a conditional format to the dataframe data like this::

    import xlsxwriter
    import polars as pl

    with xlsxwriter.Workbook("polars_conditional.xlsx") as workbook:
        df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

        worksheet = workbook.add_worksheet()

        # Write the Polars data to the worksheet created above.
        df.write_excel(workbook=workbook, worksheet="Sheet1")

        # Get the dimensions of the dataframe.
        (max_row, max_col) = df.shape

        # Apply a conditional format to the required cell range.
        worksheet.conditional_format(1, max_col - 1, max_row, max_col - 1,
                                    {"type": "3_color_scale"})

However, this can also be done directly and more succinctly using the Polars
``write_excel()`` APIs::

    import polars as pl

    df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

    df.write_excel(
        workbook="pandas_conditional.xlsx",
        conditional_formats={"Data": {"type": "3_color_scale"}},
    )

Which would give:

.. image:: _images/polars_conditional.png

See the full example at :ref:`ex_polars_conditional` and the section of the docs
on :ref:`working_with_conditional_formats`.


Handling multiple Polars Dataframes
-----------------------------------

It is possible to write more than one dataframe to a worksheet or to several
worksheets. For example to write multiple dataframes to multiple worksheets::

    with xlsxwriter.Workbook("polars_multiple.xlsx") as workbook:
        df1.write_excel(workbook=workbook)
        df2.write_excel(workbook=workbook)
        df3.write_excel(workbook=workbook)

(See the full example at :ref:`ex_polars_multiple`.)

It is also possible to position multiple dataframes within the same
worksheet::

    with xlsxwriter.Workbook("polars_positioning.xlsx") as workbook:
        # Write the dataframe to the default worksheet and position: Sheet1!A1.
        df1.write_excel(workbook=workbook)

        # Write the dataframe using a cell string position.
        df2.write_excel(workbook=workbook, worksheet="Sheet1", position="C1")

        # Write the dataframe using a (row, col) tuple position.
        df3.write_excel(workbook=workbook, worksheet="Sheet1", position=(6, 0))

        # Write the dataframe without the header.
        df4.write_excel(
            workbook=workbook,
            worksheet="Sheet1",
            position="C8",
            include_header=False)

Output:

.. image:: _images/polars_positioning.png

(See the full example at :ref:`ex_polars_positioning`.)


Formatting the dataframe output
-------------------------------

Polars uses some sensible default formatting for different data types. For
example consider this dataframe comprised of dates, strings and positive and
negative numbers::

    from datetime import date
    import polars as pl

    df = pl.DataFrame(
        {
            "Dates": [date(2023, 1, 1), date(2023, 1, 2), date(2023, 1, 3)],
            "Strings": ["Alice", "Bob", "Carol"],
            "Numbers": [0.12345, 100, -99.523],
        }
    )

    df.write_excel(workbook="polars_format_default.xlsx", autofit=True)


.. image:: _images/polars_format_default.png

(See the full example at :ref:`ex_polars_format_default`).

As can be seen the dates are formatted with a ``"yyyy-mm-dd"`` style format and
the numbers are formatted to 3 decimal places with negative numbers shown in red
(using the number format ``"#,##0.000;[Red]-#,##0.000"``). We also used the
``autofit`` parameter in this example to autofit the column widths.

One thing to note from the previous examples is that the Polars dataframes are
added to the Excel worksheet as :ref:`Excel Data Tables <tables>`. This can be
seen from the green corner symbol in the bottom right of the dataframe values
and from the table view:

.. image:: _images/polars_table_range.png

Tables are a useful Excel data representation that is analogous to a Python
dataframe. We can also use the table properties as well as some of the Polars
``write_excel()`` options to add some more formatting to the previous example::

    from datetime import date
    import polars as pl

    # Create a Pandas dataframe with some sample data.
    df = pl.DataFrame(
        {
            "Dates": [date(2023, 1, 1), date(2023, 1, 2), date(2023, 1, 3)],
            "Strings": ["Alice", "Bob", "Carol"],
            "Numbers": [0.12345, 100, -99.523],
        }
    )

    # Write the dataframe to a new Excel file with formatting options.
    df.write_excel(
        workbook="polars_format_custom.xlsx",

        # Set an alternative table style.
        table_style="Table Style Medium 4",

        # See the floating point precision for reals.
        float_precision=6,

        # Set an alternative number/date format for Polar Date types.
        dtype_formats={pl.Date: "yyyy mm dd;@"},

        # Add totals to the numeric columns.
        column_totals=True,

        # Autofit the column widths.
        autofit=True,
    )

.. image:: _images/polars_format_custom.png

(See the full example at :ref:`ex_polars_format_custom`).


Adding Sparklines to the output dataframe
-----------------------------------------

We can also add :ref:`sparklines <sparklines>` to the dataframe output::

    import polars as pl

    df = pl.DataFrame(
        {
            "Zone": ["North", "South", "East", "West", "Central"],
            "Q1": [100, 55, -20, 0, 35],
            "Q2": [30, -10, 15, 60, 20],
            "Q3": [-50, 0, 40, 80, 80],
            "Q4": [75, 55, 25, -10, -55],
        }
    )

    # Write the dataframe with sparklines and some additional formatting.
    df.write_excel(
        workbook="polars_sparklines.xlsx",

        # Set an alternative table style.
        table_style="Table Style Light 2",

        # Specify an Excel number format for integer types.
        dtype_formats={pl.Int32: "#,##0_);(#,##0)"},

        # Configure sparklines to the dataframe.
        sparklines={
            # We use the default options with just  the source columns.
            "Trend": ["Q1", "Q2", "Q3", "Q4"],

            # We also add a customized sparkline type, with a positioning directive.
            "Change": {
                "columns": ["Q1", "Q2", "Q3", "Q4"],
                "insert_after": "Zone",
                "type": "win_loss",
            },
        },
        column_totals=["Q1", "Q2", "Q3", "Q4"],

        # Hide the default gridlines on the worksheet.
        hide_gridlines=True,
    )

Output:

.. image:: _images/polars_sparklines.png

(See the full example at :ref:`ex_polars_sparklines`).

See also  :ref:`sparklines`.

================
File: dev/docs/source/working_with_sparklines.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _sparklines:

Working with Sparklines
=======================

Sparklines are a feature of Excel 2010+ which allows you to add small charts to
worksheet cells. These are useful for showing visual trends in data in a
compact format.

.. image:: _images/sparklines1.png

Sparklines were invented by Edward Tufte:
https://en.wikipedia.org/wiki/Sparklines

The add_sparkline() method
--------------------------

The :func:`add_sparkline` worksheet method is used to add sparklines to a cell
or a range of cells::

    worksheet.add_sparkline(0, 5, {'range': 'Sheet1!A1:E1'})

Both row-column and A1 style notation are supported. See :ref:`cell_notation`
for more details.

The parameters to ``add_sparkline()`` must be passed in a dictionary. The main
sparkline parameters are:


+------------------+
| range (required) |
+------------------+
| type             |
+------------------+
| style            |
+------------------+
| markers          |
+------------------+
| negative_points  |
+------------------+
| axis             |
+------------------+
| reverse          |
+------------------+

Other, less commonly used parameters are:

+----------------+
| location       |
+----------------+
| high_point     |
+----------------+
| low_point      |
+----------------+
| first_point    |
+----------------+
| last_point     |
+----------------+
| max            |
+----------------+
| min            |
+----------------+
| empty_cells    |
+----------------+
| show_hidden    |
+----------------+
| date_axis      |
+----------------+
| weight         |
+----------------+
| series_color   |
+----------------+
| negative_color |
+----------------+
| markers_color  |
+----------------+
| first_color    |
+----------------+
| last_color     |
+----------------+
| high_color     |
+----------------+
| low_color      |
+----------------+

.. image:: _images/sparklines2.png


These parameters are explained in the sections below.

.. Note::
   Sparklines are a feature of Excel 2010+ only. You can write them to an
   XLSX file that can be read by Excel 2007 but they won't be displayed.


range
-----

The ``range`` specifier is the only non-optional parameter.

It specifies the cell data range that the sparkline will plot::

    worksheet.add_sparkline('F1', {'range': 'A1:E1'})

The ``range`` should be a 2D array. (For 3D arrays of cells see "Grouped
Sparklines" below).

If ``range`` is not on the same worksheet you can specify its location using
the usual Excel notation::

    worksheet.add_sparkline('F1', {'range': 'Sheet2!A1:E1'})

If the worksheet contains spaces or special characters you should quote the
worksheet name in the same way that Excel does::

    worksheet.add_sparkline('F1', {'range': "'Monthly Data'!A1:E1"})


type
----

Specifies the type of sparkline. There are 3 available sparkline types::

    line (default)
    column
    win_loss

For example::

    worksheet.add_sparkline('F2', {'range': 'A2:E2',
                                   'type': 'column'})


style
-----

Excel provides 36 built-in Sparkline styles in 6 groups of 6. The ``style``
parameter can be used to replicate these and should be a corresponding number
from 1 .. 36::

    worksheet.add_sparkline('F2', {'range': 'A2:E2',
                                   'type': 'column',
                                   'style': 12})

The style number starts in the top left of the style grid and runs left to
right. The default style is 1. It is possible to override color elements of
the sparklines using the ``_color`` parameters below.


markers
-------

Turn on the markers for ``line`` style sparklines::

    worksheet.add_sparkline('A6', {'range': 'Sheet2!A1:J1',
                                   'markers': True})

Markers aren't shown in Excel for ``column`` and ``win_loss`` sparklines.


negative_points
---------------

Highlight negative values in a sparkline range. This is usually required with
``win_loss`` sparklines::

    worksheet.add_sparkline('A9', {'range': 'Sheet2!A1:J1',
                                   'negative_points': True})


axis
----

Display a horizontal axis in the sparkline::

    worksheet.add_sparkline('A10', {'range': 'Sheet2!A1:J1',
                                    'axis': True})


reverse
-------

Plot the data from right-to-left instead of the default left-to-right::

    worksheet.add_sparkline('A24', {'range': 'Sheet2!A4:J4',
                                    'type': 'column',
                                    'style': 20,
                                    'reverse': True})


weight
------

Adjust the default line weight (thickness) for ``line`` style sparklines::

    worksheet.add_sparkline('F2', {'range': 'A2:E2',
                                   'weight': 0.25})

The weight value should be one of the following values allowed by Excel::

    0.25, 0.5, 0.75, 1, 1.25, 2.25, 3, 4.25, 6

high_point, low_point, first_point, last_point
----------------------------------------------

Highlight points in a sparkline range::

    worksheet.add_sparkline('A7', {'range': 'Sheet2!A1:J1',
                                   'high_point': True,
                                   'low_point': True,
                                   'first_point': True})


max, min
--------

Specify the maximum and minimum vertical axis values::

    worksheet.add_sparkline('F1', {'range': 'A1:E1',
                                   'max': 0.5,
                                   'min': -0.5})

As a special case you can set the maximum and minimum to be for a group of
sparklines rather than one::

        'max': 'group'

See "Grouped Sparklines" below.


empty_cells
-----------

Define how empty cells are handled in a sparkline::

    worksheet.add_sparkline('F1', {'range': 'A1:E1',
                                   'empty_cells': 'zero'})

The available options are:

* ``gaps``: show empty cells as gaps (the default).
* ``zero``: plot empty cells as 0.
* ``connect``: Connect points with a line ("line" type sparklines only).


show_hidden
-----------

Plot data in hidden rows and columns::

     worksheet.add_sparkline('F3', {'range': 'A3:E3',
                                    'show_hidden': True})

Note, this option is off by default.


date_axis
---------

Specify an alternative date axis for the sparkline. This is useful if the data
being plotted isn't at fixed width intervals::

     worksheet.add_sparkline('F3', {'range': 'A3:E3',
                                    'date_axis': 'A4:E4'})

The number of cells in the date range should correspond to the number of cells
in the data range.


series_color
------------

It is possible to override the color of a sparkline style using the following
parameters::

    series_color
    negative_color
    markers_color
    first_color
    last_color
    high_color
    low_color

The color should be specified as a HTML style ``#rrggbb`` hex value::

    worksheet.add_sparkline('A18', {'range': 'Sheet2!A2:J2',
                                    'type': 'column',
                                    'series_color': '#E965E0'})

location
--------

By default the sparkline location is specified by ``row`` and ``col`` in
:func:`add_sparkline`. However, for grouped sparklines it is necessary to
specify more than one cell location. The ``location`` parameter is used to
specify a list of cells. See "Grouped Sparklines" below.


Grouped Sparklines
------------------

The ``add_sparkline()`` worksheet method can be used multiple times to write as
many sparklines as are required in a worksheet.

However, it is sometimes necessary to group contiguous sparklines so that
changes that are applied to one are applied to all. In Excel this is achieved
by selecting a 3D range of cells for the data ``range`` and a 2D range of
cells for the ``location``.

In XlsxWriter, you can simulate this by passing an array refs of values to
``location`` and ``range``::

    worksheet.add_sparkline('A27', {'location': ['A27',   'A28',   'A29'],
                                    'range':    ['A5:J5', 'A6:J6', 'A7:J7']})


Sparkline examples
------------------

See :ref:`ex_sparklines1` and :ref:`ex_sparklines2`.

================
File: dev/docs/source/working_with_tables.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _tables:

Working with Worksheet Tables
=============================

Tables in Excel are a way of grouping a range of cells into a single entity
that has common formatting or that can be referenced from formulas. Tables can
have column headers, autofilters, total rows, column formulas and default
formatting.

.. image:: _images/tables12.png

For more information see
`An Overview of Excel Tables <https://support.microsoft.com/en-us/office/overview-of-excel-tables-7ab0bb7d-3a9e-4b56-a3c9-6c94334e492c>`_
in the Microsoft Office documentation.

.. Note::

   Tables aren't available in XlsxWriter when :func:`Workbook`
   ``'constant_memory'`` mode is enabled.


add_table()
-----------

Tables are added to a worksheet using the :func:`add_table()` method::

    worksheet.add_table('B3:F7', {options})

The data range can be specified in 'A1' or 'Row/Column' notation (see
:ref:`cell_notation`)::

    worksheet.add_table('B3:F7')
    # Same as:
    worksheet.add_table(2, 1, 6, 5)

.. image:: _images/tables1.png

The options parameter should be a dict containing the parameters that describe
the table options and data. The available options are:

+----------------+
| data           |
+----------------+
| autofilter     |
+----------------+
| header_row     |
+----------------+
| banded_columns |
+----------------+
| banded_rows    |
+----------------+
| first_column   |
+----------------+
| last_column    |
+----------------+
| style          |
+----------------+
| total_row      |
+----------------+
| columns        |
+----------------+
| name           |
+----------------+
| description    |
+----------------+
| title          |
+----------------+


These options are explained below. There are no required parameters and the
options parameter is itself optional if no options are specified (as shown
above).


data
----

The ``data`` parameter can be used to specify the data in the cells of the
table::

    data = [
        ['Apples', 10000, 5000, 8000, 6000],
        ['Pears',   2000, 3000, 4000, 5000],
        ['Bananas', 6000, 6000, 6500, 6000],
        ['Oranges',  500,  300,  200,  700],

    ]

    worksheet.add_table('B3:F7', {'data': data})

.. image:: _images/tables2.png

Table data can also be written separately, as an array or individual cells::

    # These statements are the same as the single statement above.
    worksheet.add_table('B3:F7')
    worksheet.write_row('B4', data[0])
    worksheet.write_row('B5', data[1])
    worksheet.write_row('B6', data[2])
    worksheet.write_row('B7', data[3])

Writing the cell data separately is occasionally required when you need to
control the ``write_()`` methods used to populate the cells or if you wish to
modify individual cell formatting.

The ``data`` structure should be an list of lists holding row data as shown
above.


header_row
----------

The ``header_row`` parameter can be used to turn on or off the header row in
the table. It is on by default::

    # Turn off the header row.
    worksheet.add_table('B4:F7', {'header_row': False})

.. image:: _images/tables4.png


The header row will contain default captions such as ``Column 1``,
``Column 2``, etc. These captions can be overridden using the ``columns``
parameter below.


autofilter
----------

The ``autofilter`` parameter can be used to turn on or off the autofilter in
the header row. It is on by default::

    # Turn off the default autofilter.
    worksheet.add_table('B3:F7', {'autofilter': False})

.. image:: _images/tables3.png

The ``autofilter`` is only shown if the ``header_row`` is on. Filter conditions
within the table are not supported.


banded_rows
-----------

The ``banded_rows`` parameter can be used to create rows of alternating color
in the table. It is on by default::

    # Turn off banded rows.
    worksheet.add_table('B3:F7', {'banded_rows': False})

.. image:: _images/tables6.png

banded_columns
--------------

The ``banded_columns`` parameter can be used to used to create columns of
alternating color in the table. It is off by default::

    # Turn on banded columns.
    worksheet.add_table('B3:F7', {'banded_columns': True})

See the above image.

first_column
------------

The ``first_column`` parameter can be used to highlight the first column of the
table. The type of highlighting will depend on the ``style`` of the table. It
may be bold text or a different color. It is off by default::

    # Turn on highlighting for the first column in the table.
    worksheet.add_table('B3:F7', {'first_column': True})

.. image:: _images/tables5.png

last_column
-----------

The ``last_column`` parameter can be used to highlight the last column of the
table. The type of highlighting will depend on the ``style`` of the table. It
may be bold text or a different color. It is off by default::

    # Turn on highlighting for the last column in the table.
    worksheet.add_table('B3:F7', {'last_column': True})

See the above image.


.. _tables_style:

style
-----

The ``style`` parameter can be used to set the style of the table. Standard
Excel table format names should be used (with matching capitalization)::

    worksheet.add_table('B3:F7', {'data': data,
                                  'style': 'Table Style Light 11'})

.. image:: _images/tables11.png

The default table style is 'Table Style Medium 9'.

You can also turn the table style off by setting it to None::

    worksheet.add_table('B3:F7', {'data': data, 'style': None})

.. image:: _images/tables13.png


name
----

By default tables are named ``Table1``, ``Table2``, etc. The ``name``
parameter can be used to set the name of the table::

    worksheet.add_table('B3:F7', {'name': 'SalesData'})

If you override the table name you must ensure that it doesn't clash with an
existing table name and that it follows Excel's requirements for table names,
see the `Microsoft Office documentation
<https://support.microsoft.com/en-us/office/rename-an-excel-table-fbf49a4f-82a3-43eb-8ba2-44d21233b114>`_.


total_row
---------

The ``total_row`` parameter can be used to turn on the total row in the last
row of a table. It is distinguished from the other rows by a different
formatting and also with dropdown ``SUBTOTAL`` functions::

    worksheet.add_table('B3:F7', {'total_row': True})

.. image:: _images/tables9.png

The default total row doesn't have any captions or functions. These must by
specified via the ``columns`` parameter below.

description
-----------

The ``description`` parameter can be used to set the alt text description for
the table. This is useful for accessibility purposes and for users of screen
readers::

    worksheet.add_table("B3:F7", {"description": "Table with the sales data for Spain"})


title
-----

The ``title`` parameter can be used to set the alt text title for the table.
This is useful for accessibility purposes and for users of screen readers. It
can be used in conjunction with the ``description`` parameter::

    worksheet.add_table("B3:F7", {"title": "Sales data table",
                                  "description": "Sales data for Spain"})


columns
-------

The ``columns`` parameter can be used to set properties for columns within the
table.

.. image:: _images/tables7.png

The sub-properties that can be set are:

+----------------+
| header         |
+----------------+
| header_format  |
+----------------+
| formula        |
+----------------+
| total_string   |
+----------------+
| total_function |
+----------------+
| total_value    |
+----------------+
| format         |
+----------------+

The column data must be specified as a list of dicts. For example to override
the default 'Column n' style table headers::

    worksheet.add_table('B3:F7', {'data': data,
                                  'columns': [{'header': 'Product'},
                                              {'header': 'Quarter 1'},
                                              {'header': 'Quarter 2'},
                                              {'header': 'Quarter 3'},
                                              {'header': 'Quarter 4'},
                                              ]})

See the resulting image above.

If you don't wish to specify properties for a specific column you pass an empty
hash ref and the defaults will be applied::

            ...
            columns, [
                {header, 'Product'},
                {header, 'Quarter 1'},
                {},                     # Defaults to 'Column 3'.
                {header, 'Quarter 3'},
                {header, 'Quarter 4'},
            ]
            ...

Column formulas can by applied using the column ``formula`` property::

    formula = '=SUM(Table8[@[Quarter 1]:[Quarter 4]])'

    worksheet.add_table('B3:G7', {'data': data,
                                  'columns': [{'header': 'Product'},
                                              {'header': 'Quarter 1'},
                                              {'header': 'Quarter 2'},
                                              {'header': 'Quarter 3'},
                                              {'header': 'Quarter 4'},
                                              {'header': 'Year',
                                               'formula': formula},
                                              ]})

.. image:: _images/tables8.png

The Excel 2007 style ``[#This Row]`` and Excel 2010 style ``@`` structural
references are supported within the formula. However, other Excel 2010
additions to structural references aren't supported and formulas should
conform to Excel 2007 style formulas. See the Microsoft documentation on
`Using structured references with Excel tables <https://support.microsoft.com/en-us/office/using-structured-references-with-excel-tables-f5ed2452-2337-4f71-bed3-c8ae6d2b276e>`_
for details.

As stated above the ``total_row`` table parameter turns on the "Total" row in
the table but it doesn't populate it with any defaults. Total captions and
functions must be specified via the ``columns`` property and the
``total_string`` and ``total_function`` sub properties::

    options = {'data': data,
               'total_row': 1,
               'columns': [{'header': 'Product', 'total_string': 'Totals'},
                           {'header': 'Quarter 1', 'total_function': 'sum'},
                           {'header': 'Quarter 2', 'total_function': 'sum'},
                           {'header': 'Quarter 3', 'total_function': 'sum'},
                           {'header': 'Quarter 4', 'total_function': 'sum'},
                           {'header': 'Year',
                            'formula': '=SUM(Table10[@[Quarter 1]:[Quarter 4]])',
                            'total_function': 'sum'
                            },
                           ]}

    # Add a table to the worksheet.
    worksheet.add_table('B3:G8', options)

The supported totals row ``SUBTOTAL`` functions are:

+------------+
| average    |
+------------+
| count_nums |
+------------+
| count      |
+------------+
| max        |
+------------+
| min        |
+------------+
| std_dev    |
+------------+
| sum        |
+------------+
| var        |
+------------+

User defined functions or formulas can also be added.

It is also possible to set a calculated value for the ``total_function`` using
the ``total_value`` sub property. This is only necessary when creating
workbooks for applications that cannot calculate the value of formulas
automatically. This is similar to setting the ``value`` optional property in
:func:`write_formula`::


    options = {'data': data,
               'total_row': 1,
               'columns': [{'total_string': 'Totals'},
                           {'total_function': 'sum', 'total_value': 150},
                           {'total_function': 'sum', 'total_value': 200},
                           {'total_function': 'sum', 'total_value': 333},
                           {'total_function': 'sum', 'total_value': 124},
                           {'formula': '=SUM(Table10[@[Quarter 1]:[Quarter 4]])',
                            'total_function': 'sum',
                            'total_value': 807}]}

Formatting can also be applied to columns, to the column data using ``format`` and to the header using ``header_format``::


    currency_format = workbook.add_format({'num_format': '$#,##0'})
    wrap_format     = workbook.add_format({'text_wrap': 1})

    worksheet.add_table('B3:D8', {'data': data,
                                  'total_row': 1,
                                  'columns': [{'header': 'Product'},
                                              {'header': 'Quarter 1',
                                               'total_function': 'sum',
                                               'format': currency_format},
                                              {'header': 'Quarter 2',
                                               'header_format': wrap_format,
                                               'total_function': 'sum',
                                               'format': currency_format}]})

.. image:: _images/tables12.png

Standard XlsxWriter :ref:`Format object <format>` objects are used for this
formatting. However, they should be limited to numerical formats for the
columns and simple formatting like text wrap for the headers. Overriding other
table formatting may produce inconsistent results.


Example
-------

All of the images shown above are taken from :ref:`ex_tables`.

================
File: dev/docs/source/working_with_textboxes.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _working_with_textboxes:

Working with Textboxes
======================

This section explains how to work with some of the options and features of
textboxes in XlsxWriter::

    import xlsxwriter

    workbook = xlsxwriter.Workbook('textbox.xlsx')
    worksheet = workbook.add_worksheet()

    text = 'Formatted textbox'

    options = {
        'width': 256,
        'height': 100,
        'x_offset': 10,
        'y_offset': 10,

        'font': {'color': 'red',
                 'size': 14},
        'align': {'vertical': 'middle',
                  'horizontal': 'center'
                  },
        'gradient': {'colors': ['#DDEBCF',
                                '#9CB86E',
                                '#156B13']},
    }

    worksheet.insert_textbox('B2', text, options)

    workbook.close()

.. image:: _images/textbox02.png

See also :ref:`ex_textbox`.

Textbox options
---------------

This Worksheet :func:`insert_textbox()` method is used to insert a textbox
into a worksheet::

    worksheet.insert_textbox('B2', 'A simple textbox with some text')

.. image:: _images/textbox31.png


The text can contain newlines to wrap the text::

    worksheet.insert_textbox('B2', 'Line 1\nLine 2\n\nMore text')

.. image:: _images/textbox32.png

This :func:`insert_textbox()` takes an optional ``dict`` parameter that can be
used to control the size, positioning and format of the textbox::

    worksheet.insert_textbox('B2', 'Some text', {'width': 256, 'height': 100})

The available options are::

    # Size and position
    width
    height
    x_scale
    y_scale
    x_offset
    y_offset
    object_position

    # Formatting
    line
    border
    fill
    gradient
    font
    align
    text_rotation

    # Links
    textlink
    url
    tip

    # Accessibility
    description
    decorative


These options are explained in the sections below. They are similar or
identical to position and formatting parameters used in charts.


Textbox size and positioning
----------------------------

The :func:`insert_textbox()` options to control the size and positioning of a
textbox are::

    width
    height
    x_scale
    y_scale
    x_offset
    y_offset
    object_position

The ``width`` and ``height`` are in pixels. The default textbox size is 192 x
120 pixels (or equivalent to 3 default columns x 6 default rows).

.. image:: _images/textbox35.png

The size of the textbox can be modified by setting the ``width`` and
``height`` or by setting the ``x_scale`` and ``y_scale``::

    worksheet.insert_textbox('B2', 'Size adjusted textbox',
                             {'width': 288, 'height': 30})

    # or ...
    worksheet.insert_textbox('B2', 'Size adjusted textbox',
                             {'x_scale': 1.5, 'y_scale': 0.25})

.. image:: _images/textbox33.png

The ``x_offset`` and ``y_offset`` position the top left corner of the textbox in
the cell that it is inserted into.

.. image:: _images/textbox34.png

The ``object_position`` parameter can be used to control the object
positioning of the image::

    worksheet.insert_textbox('B2', "Don't move or size with cells",
                             {'object_position': 3})

Where ``object_position`` has the following allowable values:

1. Move and size with cells (the default).
2. Move but don't size with cells.
3. Don't move or size with cells.

See :ref:`object_position` for more detailed information about the positioning
and scaling of images within a worksheet.


Textbox Formatting
------------------

The following formatting properties can be set for textbox objects::

    line
    border
    fill
    gradient
    font
    align
    text_rotation

Textbox formatting properties are set using the options dict::

    worksheet.insert_textbox('B2', 'A textbox with a color text',
                                    {'font': {'color': 'green'}})

.. image:: _images/textbox11.png

In some cases the format properties can be nested::

    worksheet.insert_textbox('B2', 'Some text in a textbox with formatting',
                             {'font': {'color': 'white'},
                              'align': {'vertical': 'middle',
                                        'horizontal': 'center'
                                        },
                              'gradient': {'colors': ['green', 'white']}})

.. image:: _images/textbox12.png


.. _textbox_formatting_line:

Textbox formatting: Line
------------------------

The line format is used to specify properties of the border in a textbox. The
following properties can be set for ``line`` formats in a textbox::

    none
    color
    width
    dash_type

The ``none`` property is used to turn the ``line`` off (it is always on by
default)::

    worksheet.insert_textbox('B2', 'A textbox with no border line',
                             {'line': {'none': True}})


The ``color`` property sets the color of the ``line``::

    worksheet.insert_textbox('B2', 'A textbox with a color border',
                             {'line': {'color': 'red'}})

.. image:: _images/textbox13.png


The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`::

    worksheet.insert_textbox('B2', 'A textbox with a color border',
                             {'line': {'color': '#FF9900'}})

.. image:: _images/textbox14.png


The ``width`` property sets the width of the ``line``. It should be specified
in increments of 0.25 of a point as in Excel::

    worksheet.insert_textbox('B2', 'A textbox with larger border',
                             {'line': {'width': 3.25}})

.. image:: _images/textbox15.png


The ``dash_type`` property sets the dash style of the line::

    worksheet.insert_textbox('B2', 'A textbox a dash border',
                             {'line': {'dash_type': 'dash_dot'}})

.. image:: _images/textbox16.png

The following ``dash_type`` values are available. They are shown in the order
that they appear in the Excel dialog::

    solid
    round_dot
    square_dot
    dash
    dash_dot
    long_dash
    long_dash_dot
    long_dash_dot_dot

The default line style is ``solid``.

More than one ``line`` property can be specified at a time::

    worksheet.insert_textbox('B2', 'A textbox with border formatting',
                             {'line': {'color': 'red',
                                       'width': 1.25,
                                       'dash_type': 'square_dot'}})

.. image:: _images/textbox17.png

.. _textbox_formatting_border:

Textbox formatting: Border
--------------------------

The ``border`` property is a synonym for ``line``.

Excel uses a common dialog for setting object formatting but depending on
context it may refer to a *line* or a *border*. For formatting these can be
used interchangeably.

.. _textbox_formatting_fill:

Textbox formatting: Solid Fill
------------------------------

The solid fill format is used to specify a fill for a textbox object.

The following properties can be set for ``fill`` formats in a textbox::

    none
    color

The ``none`` property is used to turn the ``fill`` property off (to make the
textbox transparent)::

    worksheet.insert_textbox('B2', 'A textbox with no fill',
                             {'fill': {'none': True}})

.. image:: _images/textbox21.png

The ``color`` property sets the color of the ``fill`` area::

    worksheet.insert_textbox('B2', 'A textbox with color fill',
                             {'fill': {'color': '#FF9900'}})

.. image:: _images/textbox22.png

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`::

    worksheet.insert_textbox('B2', 'A textbox with color fill',
                             {'fill': {'color': 'red'}})


.. _textbox_formatting_gradient:

Textbox formatting: Gradient Fill
---------------------------------

The gradient fill format is used to specify a gradient fill for a textbox. The
following properties can be set for ``gradient`` fill formats in a textbox::

    colors:    a list of colors
    positions: an optional list of positions for the colors
    type:      the optional type of gradient fill
    angle:     the optional angle of the linear fill

If gradient fill is used on a textbox object it overrides the solid fill
properties of the object.

The ``colors`` property sets a list of colors that define the ``gradient``::

    worksheet.insert_textbox('B2', 'A textbox with gradient fill',
                             {'gradient': {'colors': ['gray', 'white']}})

.. image:: _images/textbox23.png

Excel allows between 2 and 10 colors in a gradient but it is unlikely that
you will require more than 2 or 3.

As with solid fill it is also possible to set the colors of a gradient with a
Html style ``#RRGGBB`` string or a limited number of named colors, see
:ref:`colors`::

    worksheet.insert_textbox('B2', 'A textbox with gradient fill',
                             {'gradient': {'colors': ['#DDEBCF',
                                                      '#9CB86E',
                                                      '#156B13']}})

.. image:: _images/textbox24.png

The ``positions`` defines an optional list of positions, between 0 and 100, of
where the colors in the gradient are located. Default values are provided for
``colors`` lists of between 2 and 4 but they can be specified if required::

    worksheet.insert_textbox('B2', 'A textbox with gradient fill',
                             {'gradient': {'colors':    ['#DDEBCF', '#156B13'],
                                           'positions': [10,        90]}})

The ``type`` property can have one of the following values::

    linear        (the default)
    radial
    rectangular
    path

For example::

    worksheet.insert_textbox('B2', 'A textbox with gradient fill',
                             {'gradient': {'colors': ['#DDEBCF', '#9CB86E', '#156B13'],
                                           'type': 'radial'}})

.. image:: _images/textbox25.png

If ``type`` isn't specified it defaults to ``linear``.

For a ``linear`` fill the angle of the gradient can also be specified (the
default angle is 90 degrees)::

    worksheet.insert_textbox('B2', 'A textbox with angle gradient',
                             {'gradient': {'colors': ['#DDEBCF', '#9CB86E', '#156B13'],
                                           'angle': 45}})


.. _textbox_fonts:

Textbox formatting: Fonts
-------------------------

The following font properties can be set for the entire textbox::

    name
    size
    bold
    italic
    underline
    color

These properties correspond to the equivalent Worksheet cell Format object
properties. See the :ref:`format` section for more details about Format
properties and how to set them.

The font properties are:


* ``name``: Set the font name::

    {'font':  {'name': 'Arial'}}

  .. image:: _images/textbox46.png

* ``size``: Set the font size::

    {'font':  {'name': 'Arial', 'size': 7}}

  .. image:: _images/textbox47.png

* ``bold``: Set the font bold property::

    {'font':  {'bold': True}}

  .. image:: _images/textbox45.png

* ``italic``: Set the font italic property::

    {'font':  {'italic': True}}

  .. image:: _images/textbox48.png

* ``underline``: Set the font underline property::

    {'font':  {'underline': True}}

  .. image:: _images/textbox49.png

* ``color``: Set the font color property. Can be a color index, a color name
  or HTML style RGB color::

    {'font': {'color': 'red' }}
    {'font': {'color': '#92D050'}}


Here is an example of Font formatting in a textbox::

    worksheet.insert_textbox('B2', 'Some font formatting',
                             {'font': {'bold': True,
                                       'italic': True,
                                       'underline': True,
                                       'name': 'Arial',
                                       'color': 'red',
                                       'size': 14}})

.. image:: _images/textbox26.png


.. _textbox_align:

Textbox formatting: Align
-------------------------

The ``align`` property is used to set the text alignment for the entire textbox::

    worksheet.insert_textbox('B2', 'Alignment: middle - center',
                             {'align': {'vertical': 'middle',
                                        'horizontal': 'center'}})

.. image:: _images/textbox41.png

The alignment properties that can be set in Excel for a textbox are::

    {'align': {'vertical': 'top'}}      # Default
    {'align': {'vertical': 'middle'}}
    {'align': {'vertical': 'bottom'}}

    {'align': {'horizontal': 'left'}}   # Default
    {'align': {'horizontal': 'center'}}

    {'align': {'text': 'left'}}         # Default
    {'align': {'text': 'center'}}
    {'align': {'text': 'right'}}

The ``vertical`` and ``horizontal`` alignments set the layout for the text
area within the textbox. The ``text`` alignment sets the layout for the text
within that text area::

    worksheet.insert_textbox('H2',
                             'Long text line that wraps and is centered',
                             {'align': {'vertical': 'middle',
                                        'horizontal': 'center',
                                        'text': 'center'}})

.. image:: _images/textbox50.png

The default textbox alignment is::

    worksheet.insert_textbox('B2', 'Default alignment',
                             {'align': {'vertical': 'top',
                                        'horizontal': 'left',
                                        'text': 'left'}})

    # Same as this:
    worksheet.insert_textbox('B2', 'Default alignment')

.. image:: _images/textbox42.png

.. _textbox_formatting_rotation:

Textbox formatting: Text Rotation
---------------------------------

The ``text_rotation`` option can be used to set the text rotation for the
entire textbox::

    worksheet.insert_textbox('B2', 'Text rotated up',
                             {'text_rotation': 90})

.. image:: _images/textbox44.png

Textboxes in Excel only support a limited number of rotation options. These
are::

      90:     Rotate text up
     -90:     Rotate text down
     270:     Vertical text (stacked)
     271:     Vertical text (stacked) - for East Asian fonts

.. _textbox_textlink:

Textbox Textlink
----------------

The ``textlink`` property is used to link/get the text for a textbox from a
cell in the worksheet. When you use this option the actual text in the textbox
can be left blank or set to ``None``::

    worksheet.insert_textbox('A1', '', {'textlink': '=$A$1'})

The reference can also be to a cell in another worksheet::

    worksheet.insert_textbox('A2', None, {'textlink': '=Sheet2!A1'})

.. image:: _images/textbox43.png

.. _textbox_hyperlink:

Textbox Hyperlink
-----------------

The ``url`` parameter can used to add a hyperlink/url to a textbox::

    worksheet.insert_textbox('A1', 'This is some text',
                             {'url': 'https://github.com/jmcnamara'})

The ``tip`` parameter adds an optional mouseover tooltip::

    worksheet.insert_textbox('A1', 'This is some text',
                             {'url': 'https://github.com/jmcnamara',
                              'tip': 'GitHub'})

See also :func:`write_url` for details on supported URIs.



.. _textbox_description:

Textbox Description
-------------------

The ``description`` property can be used to specify a description or "alt
text" string for the textbox. In general this would be used to provide a text
description of the textbox to help accessibility. It is an optional parameter
and has no default. It can be used as follows::

 worksheet.insert_textbox('A1', 'This is some text',
                          {'description': 'Textbox showing data input instructions'})

.. image:: _images/alt_text3.png


.. _textbox_decorative:

Textbox Decorative
------------------

The optional ``decorative`` property is also used to help accessibility. It is
used to mark the object as decorative, and thus uninformative, for automated
screen readers. As in Excel, if this parameter is in use the ``description``
field isn't written. It is used as follows::

 worksheet.insert_textbox('A1', 'This is some text', {'decorative': True})

================
File: dev/docs/source/worksheet.rst
================
.. SPDX-License-Identifier: BSD-2-Clause
   Copyright (c) 2013-2025, John McNamara, jmcnamara@cpan.org

.. _worksheet:

The Worksheet Class
===================

The worksheet class represents an Excel worksheet. It handles operations such
as writing data to cells or formatting worksheet layout.

A worksheet object isn't instantiated directly. Instead a new worksheet is
created by calling the :func:`add_worksheet()` method from a :func:`Workbook`
object::

    workbook   = xlsxwriter.Workbook('filename.xlsx')

    worksheet1 = workbook.add_worksheet()
    worksheet2 = workbook.add_worksheet()

    worksheet1.write('A1', 123)

    workbook.close()


.. image:: _images/worksheet00.png

XlsxWriter supports Excels worksheet limits of 1,048,576 rows by 16,384
columns.


worksheet.write()
-----------------

.. py:function:: write(row, col, *args)

   Write generic data to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param \*args:      The additional args that are passed to the sub methods
                       such as number, string and cell_format.

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns:  Other values from the called write methods.

Excel makes a distinction between data types such as strings, numbers, blanks,
formulas and hyperlinks. To simplify the process of writing data to an
XlsxWriter file the ``write()`` method acts as a general alias for several
more specific methods:

* :func:`write_string()`
* :func:`write_number()`
* :func:`write_blank()`
* :func:`write_formula()`
* :func:`write_datetime()`
* :func:`write_boolean()`
* :func:`write_url()`

The rules for handling data in ``write()`` are as follows:

* Data types ``float``, ``int``, ``long``, :class:`decimal.Decimal` and
  :class:`fractions.Fraction`  are written using :func:`write_number()`.

* Data types :class:`datetime.datetime`, :class:`datetime.date`
  :class:`datetime.time` or :class:`datetime.timedelta` are written using
  :func:`write_datetime()` .

* ``None`` and empty strings ``""`` are written using :func:`write_blank()`.

* Data type ``bool`` is written using :func:`write_boolean()`.

Strings are then handled as follows:

* Strings that start with ``"="`` are assumed to match a formula and are written
  using :func:`write_formula()`. This can be overridden, see below.

* Strings that match supported URL types are written using
  :func:`write_url()`. This can be overridden, see below.

* When the :func:`Workbook` constructor ``strings_to_numbers`` option is
  ``True`` strings that convert to numbers using :func:`float()` are written
  using :func:`write_number()` in order to avoid Excel warnings about "Numbers
  Stored as Text". See the note below.

* Strings that don't match any of the above criteria are written using
  :func:`write_string()`.

If none of the above types are matched the value is evaluated with ``float()``
to see if it corresponds to a user defined float type. If it does then it is
written using :func:`write_number()`.

Finally, if none of these rules are matched then a ``TypeError`` exception is
raised. However, it is also possible to handle additional, user defined, data
types using the :func:`add_write_handler` method explained below and in
:ref:`writing_user_types`.

Here are some examples::

    worksheet.write(0, 0, 'Hello')          # write_string()
    worksheet.write(1, 0, 'World')          # write_string()
    worksheet.write(2, 0, 2)                # write_number()
    worksheet.write(3, 0, 3.00001)          # write_number()
    worksheet.write(4, 0, '=SIN(PI()/4)')   # write_formula()
    worksheet.write(5, 0, '')               # write_blank()
    worksheet.write(6, 0, None)             # write_blank()

This creates a worksheet like the following:

.. image:: _images/worksheet01.png

.. note::

   The :func:`Workbook` constructor option takes three optional arguments
   that can be used to override string handling in the ``write()`` function.
   These options are shown below with their default values::

       xlsxwriter.Workbook(filename, {'strings_to_numbers':  False,
                                      'strings_to_formulas': True,
                                      'strings_to_urls':     True})

The ``write()`` method supports two forms of notation to designate the position
of cells: **Row-column** notation and **A1** notation::

    # These are equivalent.
    worksheet.write(0, 0, 'Hello')
    worksheet.write('A1', 'Hello')

See :ref:`cell_notation` for more details.

The ``cell_format`` parameter in the sub ``write`` methods is used to apply
formatting to the cell. This parameter is optional but when present it should
be a valid :ref:`Format <format>` object::

    cell_format = workbook.add_format({'bold': True, 'italic': True})

    worksheet.write(0, 0, 'Hello', cell_format)  # Cell is bold and italic.



worksheet.add_write_handler()
-----------------------------

.. py:function:: add_write_handler(user_type, user_function)

   Add a callback function to the ``write()`` method to handle user define
   types.

   :param user_type:     The user ``type()`` to match on.
   :param user_function: The user defined function to write the type data.

   :type user_type:     type
   :type user_function: types.FunctionType


As explained above, the :func:`write` method maps basic Python types to
corresponding Excel types. If you want to write an unsupported type then you
can either avoid ``write()`` and map the user type in your code to one of the
more specific write methods or you can extend it using the
``add_write_handler()`` method.

For example, say you wanted to automatically write :mod:`uuid` values as
strings using ``write()`` you would start by creating a function that takes the
uuid, converts it to a string and then writes it using :func:`write_string`::

    def write_uuid(worksheet, row, col, uuid, cell_format=None):
        string_uuid = str(uuid)
        return worksheet.write_string(row, col, string_uuid, cell_format)

You could then add a handler that matches the ``uuid`` type and calls your
user defined function::

    #                           match,     action()
    worksheet.add_write_handler(uuid.UUID, write_uuid)

Then you can use ``write()`` without further modification::

    my_uuid = uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')

    # Write the UUID. This would raise a TypeError without the handler.
    worksheet.write('A1', my_uuid)

.. image:: _images/user_types4.png

Multiple callback functions can be added using ``add_write_handler()`` but
only one callback action is allowed per type. However, it is valid to use the
same callback function for different types::

    worksheet.add_write_handler(int,   test_number_range)
    worksheet.add_write_handler(float, test_number_range)

See :ref:`writing_user_types` for more details on how this feature works and
how to write callback functions, and also the following examples:

* :ref:`ex_user_type1`
* :ref:`ex_user_type2`
* :ref:`ex_user_type3`


worksheet.write_string()
------------------------

.. py:function:: write_string(row, col, string[, cell_format])

   Write a string to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param string:      String to write to cell.
   :param cell_format: Optional Format object.
   :type  row:         int
   :type  col:         int
   :type  string:      string
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: -2: String truncated to 32k characters.

The ``write_string()`` method writes a string to the cell specified by ``row``
and ``column``::

    worksheet.write_string(0, 0, 'Your text here')
    worksheet.write_string('A2', 'or here')

Both row-column and A1 style notation are supported, as shown above. See
:ref:`cell_notation` for more details.

The ``cell_format`` parameter is used to apply formatting to the cell. This
parameter is optional but when present is should be a valid
:ref:`Format <format>` object.

Unicode strings are supported in UTF-8 encoding. This generally requires that
your source file is UTF-8 encoded::

  worksheet.write('A1', 'Some UTF-8 text')

.. image:: _images/worksheet02.png

See :ref:`ex_unicode` for a more complete example.

Alternatively, you can read data from an encoded file, convert it to UTF-8
during reading and then write the data to an Excel file. See
:ref:`ex_unicode_polish_utf8` and :ref:`ex_unicode_shift_jis`.

The maximum string size supported by Excel is 32,767 characters. Strings longer
than this will be truncated by ``write_string()``.

.. note::

   Even though Excel allows strings of 32,767 characters it can only
   **display** 1000 in a cell. However, all 32,767 characters are displayed in the
   formula bar.


worksheet.write_number()
------------------------

.. py:function:: write_number(row, col, number[, cell_format])

   Write a number to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param number:      Number to write to cell.
   :param cell_format: Optional Format object.
   :type  row:         int
   :type  col:         int
   :type  number:      int or float
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

The ``write_number()`` method writes numeric types to the cell specified by
``row`` and ``column``::

    worksheet.write_number(0, 0, 123456)
    worksheet.write_number('A2', 2.3451)

Both row-column and A1 style notation are supported, as shown above. See
:ref:`cell_notation` for more details.

The numeric types supported are ``float``, ``int``, ``long``,
:class:`decimal.Decimal` and :class:`fractions.Fraction` or anything that can
be converted via ``float()``.

When written to an Excel file numbers are converted to IEEE-754 64-bit
double-precision floating point. This means that, in most cases, the maximum
number of digits that can be stored in Excel without losing precision is 15.

.. note::
   NAN and INF are not supported and will raise a TypeError exception unless
   the ``nan_inf_to_errors`` Workbook() option is used.

The ``cell_format`` parameter is used to apply formatting to the cell. This
parameter is optional but when present is should be a valid
:ref:`Format <format>` object.


worksheet.write_formula()
-------------------------

.. py:function:: write_formula(row, col, formula[, cell_format[, value]])

   Write a formula to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param formula:     Formula to write to cell.
   :param cell_format: Optional Format object.
   :param value:       Optional result. The value if the formula was calculated.
   :type  row:         int
   :type  col:         int
   :type  formula:     string
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

The ``write_formula()`` method writes a formula or function to the cell
specified by ``row`` and ``column``::

    worksheet.write_formula(0, 0, '=B3 + B4')
    worksheet.write_formula(1, 0, '=SIN(PI()/4)')
    worksheet.write_formula(2, 0, '=SUM(B1:B5)')
    worksheet.write_formula('A4', '=IF(A3>1,"Yes", "No")')
    worksheet.write_formula('A5', '=AVERAGE(1, 2, 3, 4)')
    worksheet.write_formula('A6', '=DATEVALUE("1-Jan-2013")')

Both row-column and A1 style notation are supported, as shown above. See
:ref:`cell_notation` for more details.

Array formulas are also supported::

    worksheet.write_formula('A7', '{=SUM(A1:B1*A2:B2)}')

See also the ``write_array_formula()`` method below.

The ``cell_format`` parameter is used to apply formatting to the cell. This
parameter is optional but when present is should be a valid
:ref:`Format <format>` object.

If required, it is also possible to specify the calculated result of the
formula using the optional ``value`` parameter. This is occasionally
necessary when working with non-Excel applications that don't calculate the
result of the formula::

    worksheet.write('A1', '=2+2', num_format, 4)

See :ref:`formula_result` for more details.

Excel stores formulas in US style formatting regardless of the Locale or
Language of the Excel version::

    worksheet.write_formula('A1', '=SUM(1, 2, 3)')    # OK
    worksheet.write_formula('A2', '=SOMME(1, 2, 3)')  # French. Error on load.

See :ref:`formula_syntax` for a full explanation.

Excel 2010 and 2013 added functions which weren't defined in the original file
specification. These functions are referred to as *future* functions. Examples
of these functions are ``ACOT``, ``CHISQ.DIST.RT`` , ``CONFIDENCE.NORM``,
``STDEV.P``, ``STDEV.S`` and ``WORKDAY.INTL``. In XlsxWriter these require a
prefix::

    worksheet.write_formula('A1', '=_xlfn.STDEV.S(B1:B10)')

See :ref:`formula_future` for a detailed explanation and full list of
functions that are affected.


worksheet.write_array_formula()
-------------------------------

.. py:function:: write_array_formula(first_row, first_col, last_row, \
                                    last_col, formula[, cell_format[, value]])

   Write an array formula to a worksheet cell.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :param formula:     Array formula to write to cell.
   :param cell_format: Optional Format object.
   :param value:       Optional result. The value if the formula was calculated.
   :type  first_row:   int
   :type  first_col:   int
   :type  last_row:    int
   :type  last_col:    int
   :type  formula:     string
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

The ``write_array_formula()`` method writes an array formula to a cell range. In
Excel an array formula is a formula that performs a calculation on a set of
values. It can return a single value or a range of values.

An array formula is indicated by a pair of braces around the formula:
``{=SUM(A1:B1*A2:B2)}``.

For array formulas that return a range of values you must specify the range
that the return values will be written to::

    worksheet.write_array_formula(0, 0, 2, 0, '{=TREND(C1:C3,B1:B3)}')
    worksheet.write_array_formula('A1:A3',    '{=TREND(C1:C3,B1:B3)}')

Both row-column and A1 style notation are supported, as shown above. See
:ref:`cell_notation` for more details.

If the array formula returns a single value then the ``first_`` and ``last_``
parameters should be the same::

    worksheet.write_array_formula('A1:A1', '{=SUM(B1:C1*B2:C2)}')

It this case however it is easier to just use the ``write_formula()`` or
``write()`` methods::

    # Same as above but more concise.
    worksheet.write('A1', '{=SUM(B1:C1*B2:C2)}')
    worksheet.write_formula('A1', '{=SUM(B1:C1*B2:C2)}')

The ``cell_format`` parameter is used to apply formatting to the cell. This
parameter is optional but when present is should be a valid
:ref:`Format <format>` object.

If required, it is also possible to specify the calculated result of the
formula (see discussion of formulas and the ``value`` parameter for the
``write_formula()`` method above). However, using this parameter only writes a
single value to the upper left cell in the result array. See
:ref:`formula_result` for more details.

 See also :ref:`ex_array_formula`.


worksheet.write_dynamic_array_formula()
---------------------------------------

.. py:function:: write_dynamic_array_formula(first_row, first_col, last_row, \
                                             last_col, formula[, cell_format[, value]])

   Write an array formula to a worksheet cell.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :param formula:     Array formula to write to cell.
   :param cell_format: Optional Format object.
   :param value:       Optional result. The value if the formula was calculated.
   :type  first_row:   int
   :type  first_col:   int
   :type  last_row:    int
   :type  last_col:    int
   :type  formula:     string
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

The ``write_dynamic_array_formula()`` method writes an dynamic array formula to a cell
range. Dynamic array formulas are explained in detail in :ref:`formula_dynamic_arrays`.

The syntax of ``write_dynamic_array_formula()`` is the same as
:func:`write_array_formula`, shown above, except that you don't need to add
``{}`` braces::

    worksheet.write_dynamic_array_formula('B1:B3', '=LEN(A1:A3)')

Which gives the following result:

.. image:: _images/intersection03.png

It is also possible to specify the first cell of the range to get the same
results::

    worksheet.write_dynamic_array_formula('B1:B1', '=LEN(A1:A3)')

See also :ref:`ex_dynamic_arrays`.


worksheet.write_blank()
-----------------------

.. py:function:: write_blank(row, col, blank[, cell_format])

   Write a blank worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param blank:       None or empty string. The value is ignored.
   :param cell_format: Optional Format object.
   :type  row:         int
   :type  col:         int
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

Write a blank cell specified by ``row`` and ``column``::

    worksheet.write_blank(0, 0, None, cell_format)
    worksheet.write_blank('A2', None, cell_format)

Both row-column and A1 style notation are supported, as shown above. See
:ref:`cell_notation` for more details.

This method is used to add formatting to a cell which doesn't contain a string
or number value.

Excel differentiates between an "Empty" cell and a "Blank" cell. An "Empty"
cell is a cell which doesn't contain data or formatting whilst a "Blank" cell
doesn't contain data but does contain formatting. Excel stores "Blank" cells
but ignores "Empty" cells.

As such, if you write an empty cell without formatting it is ignored::

    worksheet.write('A1', None, cell_format)  # write_blank()
    worksheet.write('A2', None)               # Ignored

This seemingly uninteresting fact means that you can write arrays of data
without special treatment for ``None`` or empty string values.


worksheet.write_boolean()
-------------------------

.. py:function:: write_boolean(row, col, boolean[, cell_format])

   Write a boolean value to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param boolean:     Boolean value to write to cell.
   :param cell_format: Optional Format object.
   :type  row:         int
   :type  col:         int
   :type  boolean:     bool
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

The ``write_boolean()`` method writes a boolean value to the cell specified by
``row`` and ``column``::

    worksheet.write_boolean(0, 0, True)
    worksheet.write_boolean('A2', False)

Both row-column and A1 style notation are supported, as shown above. See
:ref:`cell_notation` for more details.

The ``cell_format`` parameter is used to apply formatting to the cell. This
parameter is optional but when present is should be a valid
:ref:`Format <format>` object.


worksheet.write_datetime()
--------------------------

.. py:function:: write_datetime(row, col, datetime [, cell_format])

   Write a date or time to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param datetime:    A datetime.datetime, .date, .time or .delta object.
   :param cell_format: Optional Format object.
   :type  row:         int
   :type  col:         int
   :type  formula:     string
   :type  datetime:    :mod:`datetime`
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

The ``write_datetime()`` method can be used to write a date or time to the cell
specified by ``row`` and ``column``::

    worksheet.write_datetime(0, 0, datetime, date_format)
    worksheet.write_datetime('A2', datetime, date_format)

Both row-column and A1 style notation are supported, as shown above. See
:ref:`cell_notation` for more details.

The datetime should be a :class:`datetime.datetime`, :class:`datetime.date`
:class:`datetime.time` or :class:`datetime.timedelta` object. The
:mod:`datetime` class is part of the standard Python libraries.

There are many ways to create datetime objects, for example the
:meth:`datetime.datetime.strptime` method::

    date_time = datetime.datetime.strptime('2013-01-23', '%Y-%m-%d')

See the :mod:`datetime` documentation for other date/time creation methods.

A date/time should have a ``cell_format`` of type :ref:`Format <format>`,
otherwise it will appear as a number::

    date_format = workbook.add_format({'num_format': 'd mmmm yyyy'})

    worksheet.write_datetime('A1', date_time, date_format)

If required, a default date format string can be set using the :func:`Workbook`
constructor ``default_date_format`` option.

See :ref:`working_with_dates_and_time` for more details and also
:ref:`Timezone Handling in XlsxWriter <timezone_handling>`.


worksheet.write_url()
---------------------

.. py:function:: write_url(row, col, url[, cell_format[, string[, tip]]])

   Write a hyperlink to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param url:         Hyperlink url.
   :param cell_format: Optional Format object. Defaults to the Excel hyperlink style.
   :param string:      An optional display string for the hyperlink.
   :param tip:         An optional tooltip.
   :type  row:         int
   :type  col:         int
   :type  url:         string
   :type  string:      string
   :type  tip:         string
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: -2: String longer than 32k characters.
   :returns: -3: Url longer than Excel limit of 2079 characters.
   :returns: -4: Exceeds Excel limit of 65,530 urls per worksheet.

The ``write_url()`` method is used to write a hyperlink in a worksheet cell.
The url is comprised of two elements: the displayed string and the
non-displayed link. The displayed string is the same as the link unless an
alternative string is specified::

    worksheet.write_url(0, 0, 'https://www.python.org/')
    worksheet.write_url('A2', 'https://www.python.org/')

Both row-column and A1 style notation are supported, as shown above. See
:ref:`cell_notation` for more details.

The ``cell_format`` parameter is used to apply formatting to the cell. This
parameter is optional and the default Excel hyperlink style will be used if it
isn't specified. If required you can access the default url format using the
Workbook :func:`get_default_url_format` method::

    url_format = workbook.get_default_url_format()

Four web style URI's are supported: ``http://``, ``https://``, ``ftp://`` and
``mailto:``::

    worksheet.write_url('A1', 'ftp://www.python.org/')
    worksheet.write_url('A2', 'https://www.python.org/')
    worksheet.write_url('A3', 'mailto:jmcnamara@cpan.org')

All of the these URI types are recognized by the :func:`write()` method, so the
following are equivalent::

    worksheet.write_url('A2', 'https://www.python.org/')
    worksheet.write    ('A2', 'https://www.python.org/')  # Same.

You can display an alternative string using the ``string`` parameter::

    worksheet.write_url('A1', 'https://www.python.org', string='Python home')

.. Note::

  If you wish to have some other cell data such as a number or a formula you
  can overwrite the cell using another call to ``write_*()``::

    worksheet.write_url('A1', 'https://www.python.org/')

    # Overwrite the URL string with a formula. The cell will still be a link.
    # Note the use of the default url format for consistency with other links.
    url_format = workbook.get_default_url_format()
    worksheet.write_formula('A1', '=1+1', url_format)

There are two local URIs supported: ``internal:`` and ``external:``. These are
used for hyperlinks to internal worksheet references or external workbook and
worksheet references::

    # Link to a cell on the current worksheet.
    worksheet.write_url('A1',  'internal:Sheet2!A1')

    # Link to a cell on another worksheet.
    worksheet.write_url('A2',  'internal:Sheet2!A1:B2')

    # Worksheet names with spaces should be single quoted like in Excel.
    worksheet.write_url('A3',  "internal:'Sales Data'!A1")

    # Link to another Excel workbook.
    worksheet.write_url('A4', r'external:c:\temp\foo.xlsx')

    # Link to a worksheet cell in another workbook.
    worksheet.write_url('A5', r'external:c:\foo.xlsx#Sheet2!A1')

    # Link to a worksheet in another workbook with a relative link.
    worksheet.write_url('A7', r'external:..\foo.xlsx#Sheet2!A1')

    # Link to a worksheet in another workbook with a network link.
    worksheet.write_url('A8', r'external:\\NET\share\foo.xlsx')

Worksheet references are typically of the form ``Sheet1!A1``. You can also link
to a worksheet range using the standard Excel notation: ``Sheet1!A1:B2``.

In external links the workbook and worksheet name must be separated by the
``#`` character: ``external:Workbook.xlsx#Sheet1!A1'``.

You can also link to a named range in the target worksheet. For example say you
have a named range called ``my_name`` in the workbook ``c:\temp\foo.xlsx`` you
could link to it as follows::

    worksheet.write_url('A14', r'external:c:\temp\foo.xlsx#my_name')

Excel requires that worksheet names containing spaces or non alphanumeric
characters are single quoted as follows ``'Sales Data'!A1``.

Links to network files are also supported. Network files normally begin with
two back slashes as follows ``\\NETWORK\etc``. In order to generate this in a
single or double quoted string you will have to escape the backslashes,
``'\\\\NETWORK\\etc'`` or use a raw string ``r'\\NETWORK\etc'``.

Alternatively, you can avoid most of these quoting problems by using forward
slashes. These are translated internally to backslashes::

    worksheet.write_url('A14', "external:c:/temp/foo.xlsx")
    worksheet.write_url('A15', 'external://NETWORK/share/foo.xlsx')

See also :ref:`ex_hyperlink`.

.. note::
   XlsxWriter will escape the following characters in URLs as required
   by Excel: ``\s " < > \ [ ] ` ^ { }`` unless the URL already contains ``%xx``
   style escapes. In which case it is assumed that the URL was escaped
   correctly by the user and will by passed directly to Excel.

.. note::
   Versions of Excel prior to Excel 2015 limited hyperlink links and
   anchor/locations to 255 characters each. Versions after that support urls
   up to 2079 characters. XlsxWriter versions >= 1.2.3 support this longer
   limit by default. However, a lower or user defined limit can be set via
   the ``max_url_length`` property in the :func:`Workbook` constructor.


worksheet.write_rich_string()
-----------------------------

.. py:function:: write_rich_string(row, col, *string_parts[, cell_format])

   Write a "rich" string with multiple formats to a worksheet cell.

   :param row:          The cell row (zero indexed).
   :param col:          The cell column (zero indexed).
   :param string_parts: String and format pairs.
   :param cell_format:  Optional Format object.
   :type  row:          int
   :type  col:          int
   :type  string_parts: list
   :type  cell_format:  :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: -2: String longer than 32k characters.
   :returns: -3: 2 consecutive formats used.
   :returns: -4: Empty string used.
   :returns: -5: Insufficient parameters.

The ``write_rich_string()`` method is used to write strings with multiple
formats. For example to write the string "This is **bold** and this is
*italic*" you would use the following::

    bold   = workbook.add_format({'bold': True})
    italic = workbook.add_format({'italic': True})

    worksheet.write_rich_string('A1',
                                'This is ',
                                bold, 'bold',
                                ' and this is ',
                                italic, 'italic')

.. image:: _images/rich_strings_small.png

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.write_rich_string(0, 0, 'This is ', bold, 'bold')
    worksheet.write_rich_string('A1', 'This is ', bold, 'bold')

See :ref:`cell_notation` for more details.

The basic rule is to break the string into fragments and put a
:func:`Format <format>` object before the fragment that you want to format.
For example::

    # Unformatted string.
    'This is an example string'

    # Break it into fragments.
    'This is an ', 'example', ' string'

    # Add formatting before the fragments you want formatted.
    'This is an ', format, 'example', ' string'

    # In XlsxWriter.
    worksheet.write_rich_string('A1',
                                'This is an ', format, 'example', ' string')

String fragments that don't have a format are given a default format. So for
example when writing the string "Some **bold** text" you would use the first
example below but it would be equivalent to the second::

    # Some bold format and a default format.
    bold    = workbook.add_format({'bold': True})
    default = workbook.add_format()

    # With default formatting:
    worksheet.write_rich_string('A1',
                                'Some ',
                                bold, 'bold',
                                ' text')

    # Or more explicitly:
    worksheet.write_rich_string('A1',
                                 default, 'Some ',
                                 bold,    'bold',
                                 default, ' text')

If you have formats and segments in a list you can add them like this, using
the standard Python list unpacking syntax::

    segments = ['This is ', bold, 'bold', ' and this is ', blue, 'blue']
    worksheet.write_rich_string('A9', *segments)

In Excel only the font properties of the format such as font name, style, size,
underline, color and effects are applied to the string fragments in a rich
string. Other features such as border, background, text wrap and alignment
must be applied to the cell.

The ``write_rich_string()`` method allows you to do this by using the last
argument as a cell format (if it is a format object). The following example
centers a rich string in the cell::

    bold   = workbook.add_format({'bold': True})
    center = workbook.add_format({'align': 'center'})

    worksheet.write_rich_string('A5',
                                'Some ',
                                bold, 'bold text',
                                ' centered',
                                center)

.. note::

   Excel doesn't allow the use of two consecutive formats in a rich string or
   an empty string fragment. For either of these conditions a warning is
   raised and the input to ``write_rich_string()`` is ignored.

   Also, the maximum string size supported by Excel is 32,767 characters. If
   the rich string exceeds this limit a warning is raised and the input to
   ``write_rich_string()`` is ignored.

See also :ref:`ex_rich_strings` and :ref:`ex_merge_rich`.


worksheet.write_row()
---------------------

.. py:function:: write_row(row, col, data[, cell_format])

   Write a row of data starting from (row, col).

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param data:        Cell data to write. Variable types.
   :param cell_format: Optional Format object.
   :type  row:         int
   :type  col:         int
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: Other: Error return value of the ``write()`` method.

The ``write_row()`` method can be used to write a list of data in one go. This
is useful for converting the results of a database query into an Excel
worksheet. The :func:`write()` method is  called for each element of the data.
For example::

    # Some sample data.
    data = ('Foo', 'Bar', 'Baz')

    # Write the data to a sequence of cells.
    worksheet.write_row('A1', data)

    # The above example is equivalent to:
    worksheet.write('A1', data[0])
    worksheet.write('B1', data[1])
    worksheet.write('C1', data[2])

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.write_row(0, 0, data)
    worksheet.write_row('A1', data)

See :ref:`cell_notation` for more details.


worksheet.write_column()
------------------------

.. py:function:: write_column(row, col, data[, cell_format])

   Write a column of data starting from (row, col).

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param data:        Cell data to write. Variable types.
   :param cell_format: Optional Format object.
   :type  row:         int
   :type  col:         int
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: Other: Error return value of the ``write()`` method.

The ``write_column()`` method can be used to write a list of data in one go.
This is useful for converting the results of a database query into an Excel
worksheet. The :func:`write()` method is  called for each element of the data.
For example::

    # Some sample data.
    data = ('Foo', 'Bar', 'Baz')

    # Write the data to a sequence of cells.
    worksheet.write_column('A1', data)

    # The above example is equivalent to:
    worksheet.write('A1', data[0])
    worksheet.write('A2', data[1])
    worksheet.write('A3', data[2])

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.write_column(0, 0, data)
    worksheet.write_column('A1', data)

See :ref:`cell_notation` for more details.


worksheet.set_row()
-------------------

.. py:function:: set_row(row, height, cell_format, options)

   Set properties for a row of cells.

   :param int row:      The worksheet row (zero indexed).
   :param float height: The row height, in character units.
   :param cell_format:  Optional Format object.
   :type  cell_format:  :ref:`Format <format>`
   :param dict options: Optional row parameters: hidden, level, collapsed.

   :returns:  0: Success.
   :returns: -1: Row is out of worksheet bounds.

The ``set_row()`` method is used to change the default properties of a row. The
most common use for this method is to change the height of a row::

    worksheet.set_row(0, 20)  # Set the height of Row 1 to 20.

The height is specified in character units. To specify the height in pixels
use the :func:`set_row_pixels` method.

The other common use for ``set_row()`` is to set the :ref:`Format <format>` for
all cells in the row::

    cell_format = workbook.add_format({'bold': True})

    worksheet.set_row(0, 20, cell_format)

If you wish to set the format of a row without changing the default row height
you can pass ``None`` as the height parameter or use the default row height of
15::

    worksheet.set_row(1, None, cell_format)
    worksheet.set_row(1, 15,   cell_format)  # Same as above.

The ``cell_format`` parameter will be applied to any cells in the row that
don't have a format. As with Excel it is overridden by an explicit cell
format. For example::

    worksheet.set_row(0, None, format1)      # Row 1 has format1.

    worksheet.write('A1', 'Hello')           # Cell A1 defaults to format1.
    worksheet.write('B1', 'Hello', format2)  # Cell B1 keeps format2.

The ``options`` parameter is a dictionary with the following possible keys:

* ``'hidden'``
* ``'level'``
* ``'collapsed'``

Options can be set as follows::

    worksheet.set_row(0, 20, cell_format, {'hidden': True})

    # Or use defaults for other properties and set the options only.
    worksheet.set_row(0, None, None, {'hidden': True})

The ``'hidden'`` option is used to hide a row. This can be used, for example,
to hide intermediary steps in a complicated calculation::

    worksheet.set_row(0, 20, cell_format, {'hidden': True})

The ``'level'`` parameter is used to set the outline level of the row. Outlines
are described in :ref:`outlines`. Adjacent rows with the same outline level
are grouped together into a single outline.

The following example sets an outline level of 1 for some rows::

    worksheet.set_row(0, None, None, {'level': 1})
    worksheet.set_row(1, None, None, {'level': 1})
    worksheet.set_row(2, None, None, {'level': 1})

Excel allows up to 7 outline levels. The ``'level'`` parameter should be in the
range ``0 <= level <= 7``.

The ``'hidden'`` parameter can also be used to hide collapsed outlined rows
when used in conjunction with the ``'level'`` parameter::

    worksheet.set_row(1, None, None, {'hidden': 1, 'level': 1})
    worksheet.set_row(2, None, None, {'hidden': 1, 'level': 1})

The ``'collapsed'`` parameter is used in collapsed outlines to indicate which
row has the collapsed ``'+'`` symbol::

    worksheet.set_row(3, None, None, {'collapsed': 1})


worksheet.set_row_pixels()
--------------------------

.. py:function:: set_row_pixels(row, height, cell_format, options)

   Set properties for a row of cells, with the row height in pixels.

   :param int row:      The worksheet row (zero indexed).
   :param float height: The row height, in pixels.
   :param cell_format:  Optional Format object.
   :type  cell_format:  :ref:`Format <format>`
   :param dict options: Optional row parameters: hidden, level, collapsed.

   :returns:  0: Success.
   :returns: -1: Row is out of worksheet bounds.

The ``set_row_pixels()`` method is identical to :func:`set_row` except that
the height can be set in pixels instead of Excel character units::

    worksheet.set_row_pixels(0, 18)  # Same as 24 in character units.

All other parameters and options are the same as ``set_row()``. See the
documentation on :func:`set_row` for more details.


worksheet.set_column()
----------------------

.. py:function:: set_column(first_col, last_col, width, cell_format, options)

   Set properties for one or more columns of cells.

   :param int first_col: First column (zero-indexed).
   :param int last_col:  Last column (zero-indexed). Can be same as first_col.
   :param float width:   The width of the column(s), in character units.
   :param cell_format:   Optional Format object.
   :type  cell_format:   :ref:`Format <format>`
   :param dict options:  Optional parameters: hidden, level, collapsed.

   :returns:  0: Success.
   :returns: -1: Column is out of worksheet bounds.

The ``set_column()``  method can be used to change the default properties of a
single column or a range of columns::

    worksheet.set_column(1, 3, 30)  # Width of columns B:D set to 30.

If ``set_column()`` is applied to a single column the value of ``first_col``
and ``last_col`` should be the same::

    worksheet.set_column(1, 1, 30)  # Width of column B set to 30.

It is also possible, and generally clearer, to specify a column range using the
form of A1 notation used for columns. See :ref:`cell_notation` for more
details.

Examples::

    worksheet.set_column(0, 0, 20)   # Column  A   width set to 20.
    worksheet.set_column(1, 3, 30)   # Columns B-D width set to 30.
    worksheet.set_column('E:E', 20)  # Column  E   width set to 20.
    worksheet.set_column('F:H', 30)  # Columns F-H width set to 30.

The ``width`` parameter sets the column width in the same units used by Excel
which is: the number of characters in the default font. The default width is
8.43 in the default font of Calibri 11. The actual relationship between a
string width and a column width in Excel is complex. See the `following
explanation of column widths <https://learn.microsoft.com/en-US/office/troubleshoot/excel/determine-column-widths>`_
from the Microsoft support documentation for more details. To set the width in
pixels use the :func:`set_column_pixels` method.

See also the  :func:`autofit` method for simulated autofitting of column widths.

As usual the ``cell_format`` :ref:`Format <format>` parameter is optional. If
you wish to set the format without changing the default column width you can
pass ``None`` as the width parameter::

    cell_format = workbook.add_format({'bold': True})

    worksheet.set_column(0, 0, None, cell_format)

The ``cell_format`` parameter will be applied to any cells in the column that
don't have a format. For example::

    worksheet.set_column('A:A', None, format1)  # Col 1 has format1.

    worksheet.write('A1', 'Hello')              # Cell A1 defaults to format1.
    worksheet.write('A2', 'Hello', format2)     # Cell A2 keeps format2.

A  row format takes precedence over a default column format::

    worksheet.set_row(0, None, format1)         # Set format for row 1.
    worksheet.set_column('A:A', None, format2)  # Set format for col 1.

    worksheet.write('A1', 'Hello')              # Defaults to format1
    worksheet.write('A2', 'Hello')              # Defaults to format2

The ``options`` parameter is a dictionary with the following possible keys:

* ``'hidden'``
* ``'level'``
* ``'collapsed'``

Options can be set as follows::

    worksheet.set_column('D:D', 20, cell_format, {'hidden': 1})

    # Or use defaults for other properties and set the options only.
    worksheet.set_column('E:E', None, None, {'hidden': 1})

The ``'hidden'`` option is used to hide a column. This can be used, for
example, to hide intermediary steps in a complicated calculation::

    worksheet.set_column('D:D', 20,  cell_format, {'hidden': 1})

The ``'level'`` parameter is used to set the outline level of the column.
Outlines are described in :ref:`outlines`. Adjacent columns with the same
outline level are grouped together into a single outline.

The following example sets an outline level of 1 for columns B to G::

    worksheet.set_column('B:G', None, None, {'level': 1})

Excel allows up to 7 outline levels. The ``'level'`` parameter should be in the
range ``0 <= level <= 7``.

The ``'hidden'`` parameter can also be used to hide collapsed outlined columns
when used in conjunction with the ``'level'`` parameter::

    worksheet.set_column('B:G', None, None, {'hidden': 1, 'level': 1})

The ``'collapsed'`` parameter is used in collapsed outlines to indicate which
column has the collapsed ``'+'`` symbol::

    worksheet.set_column('H:H', None, None, {'collapsed': 1})


worksheet.set_column_pixels()
-----------------------------

.. py:function:: set_column_pixels(first_col, last_col, width, cell_format, options)

   Set properties for one or more columns of cells, with the width in pixels.

   :param int first_col: First column (zero-indexed).
   :param int last_col:  Last column (zero-indexed). Can be same as first_col.
   :param float width:   The width of the column(s), in pixels.
   :param cell_format:   Optional Format object.
   :type  cell_format:   :ref:`Format <format>`
   :param dict options:  Optional parameters: hidden, level, collapsed.

   :returns:  0: Success.
   :returns: -1: Column is out of worksheet bounds.

The ``set_column_pixels()`` method is identical to :func:`set_column` except
that the width can be set in pixels instead of Excel character units::

    worksheet.set_column_pixels(5, 5, 75)  # Same as 10 character units.

.. image:: _images/set_column_pixels.png

All other parameters and options are the same as ``set_column()``. See the
documentation on :func:`set_column` for more details.


worksheet.autofit()
-------------------

.. py:function:: autofit([max_width])

   Autofit the worksheet column widths to the widest data in the column,
   approximately.

   :param int max_width: Optional maximum column width, in pixels, to use for
    autofitting. The default is 1790 pixels/255 characters.
   :returns:  Nothing.

The ``autofit()`` method can be used to simulate autofitting column widths based
on the largest string/number in the column::

    # Write some worksheet data to demonstrate autofitting.
    worksheet.write(0, 0, "Foo")
    worksheet.write(1, 0, "Food")
    worksheet.write(2, 0, "Foody")
    worksheet.write(3, 0, "Froody")

    worksheet.write(0, 1, 12345)
    worksheet.write(1, 1, 12345678)
    worksheet.write(2, 1, 12345)

    worksheet.write(0, 2, "Some longer text")

    worksheet.write(0, 3, "http://ww.google.com")
    worksheet.write(1, 3, "https://github.com")

    # Autofit the worksheet.
    worksheet.autofit()

.. image:: _images/autofit.png

See :ref:`ex_autofit`.

Excel autofits columns at runtime when it has access to all of the required
worksheet information as well as the Windows functions for calculating display
areas based on fonts and formatting. XlsxWriter doesn't have access to these
Windows functions so it simulates autofit by calculating string widths based on
metrics taken from Excel. This isn't perfect but for most cases it should be
sufficient and indistinguishable from the output of Excel. However there are
some limitations to be aware of when using this method:

- It is based on the default Excel font type and size of Calibri 11. It will not
  give accurate results for other fonts or font sizes.
- It doesn't take formatting of numbers or dates account, although this may be
  addressed in a later version.
- Autofit is a relatively expensive operation since it performs a calculation
  for all the populated cells in a worksheet. See the note on performance below.

For cases that don't match your desired output you can set explicit column
widths via :func:`set_column` or :func:`set_column_pixels` method ignores
columns that have already been explicitly set if the width is greater than the
calculated autofit width. Alternatively, setting the column width explicitly
after calling ``autofit()`` will override the autofit value. You can also set an
upper limit using the ``max_width`` parameter as explained below.

Excel autofits very long strings up to limit of 1790 pixels/255 characters. This
is often too wide to display on a single screen at normal zoom. As such the
``max_width`` parameter is provided to enable a smaller upper pixel limit for
autofitting long strings. A value of 300 pixels is recommended as a good
compromise between column width and readability::

    worksheet.autofit(300)

If you need more control over the autofit effect you can use the
:func:`cell_autofit_width` utility function to calculate the autofit width for a
cell value. This is the same calculation used internally by ``autofit()``. See
also See :ref:`ex_autofit_manually`.

**Performance**: By default ``autofit()`` performs a length calculation for each
populated cell in a worksheet. For very large worksheets this could be slow.
However, it is possible to mitigate this by calling ``autofit()`` after writing
the first 100 or 200 rows. This will produce a reasonably accurate autofit for
the first visible page of data without incurring the performance penalty of
autofitting thousands of non-visible rows.


worksheet.insert_image()
------------------------

.. py:function:: insert_image(row, col, filename[, options])

   Insert an image in a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param filename:    Image filename (with path if required).
   :param options:     Optional parameters for image position, scale and url.
   :type  row:         int
   :type  col:         int
   :type  image:       string
   :type  options:     dict

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

This method can be used to insert a image into a worksheet.

This is the equivalent of Excel's menu option to insert an image using the
option to "Place over Cells". See :func:`embed_image` for the equivalent method
to "Place in Cell".

The image can be in PNG, JPEG, GIF, BMP, WMF or EMF format (see the notes about
BMP and EMF below)::

    worksheet.insert_image('B2', 'python.png')

.. image:: _images/insert_image.png

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.insert_image(1, 1, 'python.png')
    worksheet.insert_image('B2', 'python.png')

See :ref:`cell_notation` for more details.


A file path can be specified with the image name::

    worksheet1.insert_image('B10', '../images/python.png')
    worksheet2.insert_image('B20', r'c:\images\python.png')

The ``insert_image()`` method takes optional parameters in a dictionary to
position and scale the image. The available parameters with their default
values are::

    {
        'x_offset':        0,
        'y_offset':        0,
        'x_scale':         1,
        'y_scale':         1,
        'object_position': 2,
        'image_data':      None,
        'url':             None,
        'description':     None,
        'decorative':      False,
    }

The offset values are in pixels::

    worksheet1.insert_image('B2', 'python.png', {'x_offset': 15, 'y_offset': 10})

The offsets can be greater than the width or height of the underlying cell.
This can be occasionally useful if you wish to align two or more images
relative to the same cell.

The ``x_scale`` and ``y_scale`` parameters can be used to scale the image
horizontally and vertically::

    worksheet.insert_image('B3', 'python.png', {'x_scale': 0.5, 'y_scale': 0.5})

The ``url`` parameter can used to add a hyperlink/url to the image. The ``tip``
parameter gives an optional mouseover tooltip for images with hyperlinks::

    worksheet.insert_image('B4', 'python.png', {'url': 'https://python.org'})

See also :func:`write_url` for details on supported URIs.

The ``image_data`` parameter is used to add an in-memory byte stream in
:class:`io.BytesIO` format::

    worksheet.insert_image('B5', 'python.png', {'image_data': image_data})

This is generally used for inserting images from URLs::

    url = 'https://python.org/logo.png'
    image_data = io.BytesIO(urllib2.urlopen(url).read())

    worksheet.insert_image('B5', url, {'image_data': image_data})

When using the ``image_data`` parameter a filename must still be passed to
``insert_image()`` since it is used by Excel as a default description field
(see below). However, it can be a blank string if the description isn't
required. In the previous example the filename/description is extracted from
the URL string. See also :ref:`ex_images_bytesio`.

The ``description`` field can be used to specify a description or "alt text"
string for the image. In general this would be used to provide a text
description of the image to help accessibility. It is an optional parameter
and defaults to the filename of the image. It can be used as follows::

    worksheet.insert_image('B3', 'python.png',
                           {'description': 'The logo of the Python programming language.'})

.. image:: _images/alt_text1.png

The optional ``decorative`` parameter is also used to help accessibility. It
is used to mark the image as decorative, and thus uninformative, for automated
screen readers. As in Excel, if this parameter is in use the ``description``
field isn't written. It is used as follows::

    worksheet.insert_image('B3', 'python.png', {'decorative': True})

The ``object_position`` parameter can be used to control the object
positioning of the image::

    worksheet.insert_image('B3', 'python.png', {'object_position': 1})

Where ``object_position`` has the following allowable values:

1. Move and size with cells.
2. Move but don't size with cells (the default).
3. Don't move or size with cells.
4. Same as Option 1 to "move and size with cells" except XlsxWriter applies
   hidden cells after the image is inserted.

See :ref:`object_position` for more detailed information about the positioning
and scaling of images within a worksheet.

.. Note::
   * BMP images are only supported for backward compatibility. In general it
     is best to avoid BMP images since they aren't compressed. If used, BMP
     images must be 24 bit, true color, bitmaps.

   * EMF images can have very small differences in width and height when
     compared to Excel files. Despite a lot of effort and testing it wasn't
     possible to exactly match Excel's calculations for handling the
     dimensions of EMF files. However, the differences are small (< 1%) and in
     general aren't visible.

See also :ref:`ex_insert_image`.


worksheet.embed_image()
-----------------------

.. py:function:: embed_image(row, col, filename[, options])

   Embed an image in a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param filename:    Image filename (with path if required).
   :param options:     Optional parameters for formatting and url.
   :type  row:         int
   :type  col:         int
   :type  image:       string
   :type  options:     dict

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

This method can be used to embed a image into a worksheet cell and have the
image automatically scale to the width and height of the cell. The X/Y scaling
of the image is preserved but the size of the image is adjusted to fit the
largest possible width or height depending on the cell dimensions.

This is the equivalent of Excel's menu option to insert an image using the
option to "Place in Cell" which is only available in Excel 365 versions from
2023 onwards. For older versions of Excel a ``#VALUE!`` error is displayed. See
:func:`insert_image` for the equivalent method to "Place over Cells".

Here is an example::

    # Widen the first column to make the caption clearer.
    worksheet.set_column(0, 0, 30)
    worksheet.write(0, 0, "Embed images that scale to cell size")

    # Embed an images in cells of different widths/heights.
    worksheet.set_column(1, 1, 14)

    worksheet.set_row(1, 60)
    worksheet.embed_image(1, 1, "python.png")

    worksheet.set_row(3, 120)
    worksheet.embed_image(3, 1, "python.png")

.. image:: _images/embedded_images.png

The image can be in PNG, JPEG, GIF, BMP, WMF or EMF format (see
:func:`insert_image` above for more details).

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.embed_image(1, 1, 'python.png')
    worksheet.embed_image('B2', 'python.png')

See :ref:`cell_notation` for more details.


A file path can be specified with the image name::

    worksheet1.embed_image('B10', '../images/python.png')
    worksheet2.embed_image('B20', r'c:\images\python.png')

The ``embed_image()`` method takes optional parameters in a dictionary to
position and scale the image. The available parameters with their default
values are::

    {
        'cell_format':     None,
        'url':             None,
        'image_data':      None,
        'description':     None,
        'decorative':      False,
    }

The ``cell_format`` parameters can be an standard :ref:`Format <format>` to set
the formatting of the cell behind the image.

The ``url`` parameter can used to add a hyperlink/url to the image. The ``tip``
parameter gives an optional mouseover tooltip for images with hyperlinks.

See also :func:`write_url` for details on supported URIs.

The ``image_data`` parameter is used to add an in-memory byte stream in
:class:`io.BytesIO` format::

    worksheet.embed_image('B5', 'python.png', {'image_data': image_data})

This is generally used for inserting images from URLs::

    url = 'https://python.org/logo.png'
    image_data = io.BytesIO(urllib2.urlopen(url).read())

    worksheet.embed_image('B5', url, {'image_data': image_data})

The ``description`` field can be used to specify a description or "alt text"
string for the image. In general this would be used to provide a text
description of the image to help accessibility.

The optional ``decorative`` parameter is also used to help accessibility. It is
used to mark the image as decorative, and thus uninformative, for automated
screen readers. As in Excel, if this parameter is in use the ``description``
field isn't written.

See also :ref:`ex_embedded_images`.


worksheet.insert_chart()
------------------------

.. py:function:: insert_chart(row, col, chart[, options])

   Write a string to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param chart:       A chart object.
   :param options:     Optional parameters to position and scale the chart.
   :type  row:         int
   :type  col:         int
   :type  options:     dict

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

This method can be used to insert a chart into a worksheet. A chart object is
created via the Workbook :func:`add_chart()` method where the chart type is
specified::

    chart = workbook.add_chart({type, 'column'})

It is then inserted into a worksheet as an embedded chart::

    worksheet.insert_chart('B5', chart)

.. image:: _images/chart_simple.png
   :scale: 75 %

.. Note::

   A chart can only be inserted into a worksheet once. If several similar
   charts are required then each one must be created separately with
   :func:`add_chart()`.

See :ref:`chart_class`, :ref:`working_with_charts` and :ref:`chart_examples`.

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.insert_chart(4, 1, chart)
    worksheet.insert_chart('B5', chart)

See :ref:`cell_notation` for more details.


The ``insert_chart()`` method takes optional parameters in a dictionary to
position and scale the chart. The available parameters with their default
values are::

    {
        'x_offset':        0,
        'y_offset':        0,
        'x_scale':         1,
        'y_scale':         1,
        'object_position': 1,
        'description':     None,
        'decorative':      False,
    }

The offset values are in pixels::

    worksheet.insert_chart('B5', chart, {'x_offset': 25, 'y_offset': 10})

The ``x_scale`` and ``y_scale`` parameters can be used to scale the chart
horizontally and vertically::

    worksheet.insert_chart('B5', chart, {'x_scale': 0.5, 'y_scale': 0.5})

These properties can also be set via the Chart :func:`set_size` method.

The ``description`` field can be used to specify a description or "alt text"
string for the chart. In general this would be used to provide a text
description of the chart to help accessibility. It is an optional parameter
and has no default. It can be used as follows::

    worksheet.insert_chart('B5', chart,
                           {'description': 'Chart showing sales for the current year'})

.. image:: _images/alt_text2.png

The optional ``decorative`` parameter is also used to help accessibility. It
is used to mark the chart as decorative, and thus uninformative, for automated
screen readers. As in Excel, if this parameter is in use the ``description``
field isn't written. It is used as follows::

    worksheet.insert_chart('B5', chart, {'decorative': True})

The ``object_position`` parameter can be used to control the object
positioning of the chart::

    worksheet.insert_chart('B5', chart, {'object_position': 2})

Where ``object_position`` has the following allowable values:

1. Move and size with cells (the default).
2. Move but don't size with cells.
3. Don't move or size with cells.

See :ref:`object_position` for more detailed information about the positioning
and scaling of charts within a worksheet.


worksheet.insert_textbox()
--------------------------

.. py:function:: insert_textbox(row, col, textbox[, options])

   Write a string to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param text:        The text in the textbox.
   :param options:     Optional parameters to position and scale the textbox.
   :type  row:         int
   :type  col:         int
   :type  text:        string
   :type  options:     dict

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

This method can be used to insert a textbox into a worksheet::

    worksheet.insert_textbox('B2', 'A simple textbox with some text')

.. image:: _images/textbox03.png

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.insert_textbox(1, 1, 'Some text')
    worksheet.insert_textbox('B2', 'Some text')

See :ref:`cell_notation` for more details.

The size and formatting of the textbox can be controlled via the ``options`` dict::

    # Size and position
    width
    height
    x_scale
    y_scale
    x_offset
    y_offset
    object_position

    # Formatting
    line
    border
    fill
    gradient
    font
    align
    text_rotation

    # Links
    textlink
    url
    tip

    # Accessibility
    description
    decorative

These options are explained in more detail in the
:ref:`working_with_textboxes` section.

See also :ref:`ex_textbox`.

See :ref:`object_position` for more detailed information about the positioning
and scaling of images within a worksheet.


worksheet.insert_checkbox()
---------------------------

.. py:function:: insert_checkbox(row, col, boolean[, cell_format])

   Insert a boolean checkbox in a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param boolean:     The boolean value to display as a checkbox.
   :param cell_format: Optional Format object.
   :type  row:         int
   :type  col:         int
   :type  boolean:     bool
   :type  cell_format: :ref:`Format <format>`

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

Checkboxes are a new feature added to `Excel in 2024`_. They are a way of
displaying a boolean value as a checkbox in a cell. The underlying value is
still an Excel ``TRUE/FALSE`` boolean value and can be used in formulas and in
references.

.. image:: _images/excel_checkbox.png

.. _Excel in 2024: https://techcommunity.microsoft.com/blog/excelblog/introducing-checkboxes-in-excel/4173561

The ``insert_checkbox()`` method can be used to replicate this behavior:

.. literalinclude:: ../../../examples/checkbox.py
   :lines: 18-36

.. image:: _images/checkbox.png

See :ref:`ex_checkbox` for the complete example.

The checkbox feature is only available in Excel versions from 2024 and later. In
older versions the value will be displayed as a standard Excel ``TRUE`` or
``FALSE`` boolean. In fact Excel stores a checkbox as a normal boolean but with
a special format. If required you can make use of this property to create a
checkbox with :func:`write_boolean` and a cell format that has the
:func:`set_checkbox` property set::

    cell_format = workbook.add_format({"checkbox": True})

    worksheet.write(2, 2, False, cell_format)
    worksheet.write(3, 2, True, cell_format)

.. image:: _images/checkbox_boolean.png

This latter method isn't required very often but it can be occasionally useful
if you are dealing with boolean values in a dataframe:

.. literalinclude:: ../../../examples/polars_checkbox.py
   :lines: 11-

.. image:: _images/polars_checkbox.png

Note, this feature is currently possible with Pandas dataframes but it will be
in a future release.

worksheet.insert_button()
-------------------------

.. py:function:: insert_button(row, col, [options])

   Insert a VBA button control on a worksheet.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param options:     Optional parameters to position and scale the button.
   :type  row:         int
   :type  col:         int
   :type  options:     dict

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.

The ``insert_button()`` method can be used to insert an Excel form button into a worksheet.

This method is generally only useful when used in conjunction with the
Workbook :func:`add_vba_project` method to tie the button to a macro from an
embedded VBA project::

    # Add the VBA project binary.
    workbook.add_vba_project('./vbaProject.bin')

    # Add a button tied to a macro in the VBA project.
    worksheet.insert_button('B3', {'macro':   'say_hello',
                                   'caption': 'Press Me'})

.. image:: _images/macros.png

See :ref:`macros` and :ref:`ex_macros` for more details.

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.insert_button(2, 1, {'macro':   'say_hello',
                                   'caption': 'Press Me'})

    worksheet.insert_button('B3', {'macro':   'say_hello',
                                   'caption': 'Press Me'})

See :ref:`cell_notation` for more details.

The ``insert_button()`` method takes optional parameters in a dictionary to
position and scale the chart. The available parameters with their default
values are::

    {
        'macro':       None,
        'caption':     'Button 1',
        'width':       64,
        'height':      20.
        'x_offset':    0,
        'y_offset':    0,
        'x_scale':     1,
        'y_scale':     1,
        'description': None,
    }

The ``macro`` option is used to set the macro that the button will invoke when
the user clicks on it. The macro should be included using the Workbook
``add_vba_project()`` method shown above.

The ``caption`` is used to set the caption on the button. The default is
``Button n`` where ``n`` is the button number.

The default button ``width`` is 64 pixels which is the width of a default cell
and the default button ``height`` is 20 pixels which is the height of a
default cell.

The offset, scale and description options are the same as for
``insert_chart()``, see above.


worksheet.data_validation()
---------------------------

.. py:function:: data_validation(first_row, first_col, last_row, \
                                 last_col, options)

   Write a conditional format to range of cells.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :param options:     Data validation options.
   :type  first_row:   int
   :type  first_col:   int
   :type  last_row:    int
   :type  last_col:    int
   :type  options:     dict

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: -2: Incorrect parameter or option.

The ``data_validation()`` method is used to construct an Excel data validation
or to limit the user input to a dropdown list of values::

    worksheet.data_validation('B3', {'validate': 'integer',
                                     'criteria': 'between',
                                     'minimum': 1,
                                     'maximum': 10})


    worksheet.data_validation('B13', {'validate': 'list',
                                      'source': ['open', 'high', 'close']})

.. image:: _images/data_validate1.png

The data validation can be applied to a single cell or a range of cells. As
usual you can use A1 or Row/Column notation, see :ref:`cell_notation`::

    worksheet.data_validation(1, 1, {'validate': 'list',
                                     'source': ['open', 'high', 'close']})

    worksheet.data_validation('B2', {'validate': 'list',
                                     'source': ['open', 'high', 'close']})

With Row/Column notation you must specify all four cells in the range:
``(first_row, first_col, last_row, last_col)``. If you need to refer to a
single cell set the `last_` values equal to the `first_` values. With A1
notation you can refer to a single cell or a range of cells::

    worksheet.data_validation(0, 0, 4, 1, {...})
    worksheet.data_validation('B1',       {...})
    worksheet.data_validation('C1:E5',    {...})

The options parameter in ``data_validation()`` must be a dictionary containing
the parameters that describe the type and style of the data validation. There
are a lot of available options which are described in detail in a separate
section: :ref:`working_with_data_validation`. See also :ref:`ex_data_valid`.


worksheet.conditional_format()
------------------------------

.. py:function:: conditional_format(first_row, first_col, last_row, \
                                    last_col, options)

   Write a conditional format to range of cells.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :param options:     Conditional formatting options.
   :type  first_row:   int
   :type  first_col:   int
   :type  last_row:    int
   :type  last_col:    int
   :type  options:     dict

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: -2: Incorrect parameter or option.

The ``conditional_format()`` method is used to add formatting to a cell or
range of cells based on user defined criteria::

    worksheet.conditional_format('B3:K12', {'type':     'cell',
                                            'criteria': '>=',
                                            'value':    50,
                                            'format':   format1})

.. image:: _images/conditional_format1.png

The conditional format can be applied to a single cell or a range of cells. As
usual you can use A1 or Row/Column notation, see :ref:`cell_notation`::

    worksheet.conditional_format(0, 0, 2, 1, {'type':     'cell',
                                              'criteria': '>=',
                                              'value':    50,
                                              'format':   format1})

    # This is equivalent to the following:
    worksheet.conditional_format('A1:B3', {'type':     'cell',
                                            'criteria': '>=',
                                            'value':    50,
                                            'format':   format1})

With Row/Column notation you must specify all four cells in the range:
``(first_row, first_col, last_row, last_col)``. If you need to refer to a
single cell set the `last_` values equal to the `first_` values. With A1
notation you can refer to a single cell or a range of cells::

    worksheet.conditional_format(0, 0, 4, 1, {...})
    worksheet.conditional_format('B1',       {...})
    worksheet.conditional_format('C1:E5',    {...})


The options parameter in ``conditional_format()`` must be a dictionary
containing the parameters that describe the type and style of the conditional
format. There are a lot of available options which are described in detail in
a separate section: :ref:`working_with_conditional_formats`. See also
:ref:`ex_cond_format`.


worksheet.add_table()
---------------------

.. py:function:: add_table(first_row, first_col, last_row, last_col, options)

   Add an Excel table to a worksheet.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :param options:     Table formatting options. (Optional)
   :type  first_row:   int
   :type  first_col:   int
   :type  last_row:    int
   :type  last_col:    int
   :type  options:     dict

   :raises OverlappingRange: if the range overlaps a previous merge or table range.

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: -2: Incorrect parameter or option.
   :returns: -3: Not supported in ``constant_memory`` mode.

The ``add_table()`` method is used to group a range of cells into an Excel
Table::

    worksheet.add_table('B3:F7', { ... })

This method contains a lot of parameters and is described in :ref:`tables`.

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.add_table(2, 1, 6, 5, { ... })
    worksheet.add_table('B3:F7',    { ... })

See :ref:`cell_notation` for more details.

See also the examples in :ref:`ex_tables`.

.. Note::

   Tables aren't available in XlsxWriter when :func:`Workbook`
   ``'constant_memory'`` mode is enabled.


worksheet.add_sparkline()
-------------------------

.. py:function:: add_sparkline(row, col, options)

    Add sparklines to a worksheet.

   :param int row:      The cell row (zero indexed).
   :param int col:      The cell column (zero indexed).
   :param dict options: Sparkline formatting options.

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: -2: Incorrect parameter or option.

Sparklines are small charts that fit in a single cell and are used to show
trends in data.

.. image:: _images/sparklines1.png

The ``add_sparkline()`` worksheet method is used to add sparklines to a cell or
a range of cells::

    worksheet.add_sparkline('F1', {'range': 'A1:E1'})

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.add_sparkline(0, 5, {'range': 'A1:E1'})
    worksheet.add_sparkline('F1', {'range': 'A1:E1'})

See :ref:`cell_notation` for more details.

This method contains a lot of parameters and is described in detail in
:ref:`sparklines`.



See also :ref:`ex_sparklines1` and :ref:`ex_sparklines2`.

.. Note::
   Sparklines are a feature of Excel 2010+ only. You can write them to
   an XLSX file that can be read by Excel 2007 but they won't be displayed.


worksheet.write_comment()
-------------------------

.. py:function:: write_comment(row, col, comment[, options])

   Write a comment to a worksheet cell.

   :param row:         The cell row (zero indexed).
   :param col:         The cell column (zero indexed).
   :param comment:     String to write to cell.
   :param options:     Comment formatting options.
   :type  row:         int
   :type  col:         int
   :type  comment:     string
   :type  options:     dict

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: -2: String longer than 32k characters.

The ``write_comment()`` method is used to add a comment to a cell. A comment is
indicated in Excel by a small red triangle in the upper right-hand corner of
the cell. Moving the cursor over the red triangle will reveal the comment.

The following example shows how to add a comment to a cell::

    worksheet.write('A1', 'Hello')
    worksheet.write_comment('A1', 'This is a comment')

.. image:: _images/comments1.png

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.write_comment(0, 0, 'This is a comment')
    worksheet.write_comment('A1', 'This is a comment')

See :ref:`cell_notation` for more details.

The properties of the cell comment can be modified by passing an optional
dictionary of key/value pairs to control the format of the comment. For
example::

    worksheet.write_comment('C3', 'Hello', {'x_scale': 1.2, 'y_scale': 0.8})

Most of these options are quite specific and in general the default comment
behavior will be all that you need. However, should you need greater control
over the format of the cell comment the following options are available::

    author
    visible
    x_scale
    width
    y_scale
    height
    color
    font_name
    font_size
    start_cell
    start_row
    start_col
    x_offset
    y_offset

For more details see :ref:`cell_comments` and :ref:`ex_comments2` .


worksheet.show_comments()
-------------------------

.. py:function:: show_comments()

   Make any comments in the worksheet visible.

This method is used to make all cell comments visible when a worksheet is
opened::

    worksheet.show_comments()

Individual comments can be made visible using the ``visible`` parameter of the
``write_comment`` method (see above)::

    worksheet.write_comment('C3', 'Hello', {'visible': True})

If all of the cell comments have been made visible you can hide individual
comments as follows::

    worksheet.show_comments()
    worksheet.write_comment('C3', 'Hello', {'visible': False})

For more details see :ref:`cell_comments` and :ref:`ex_comments2` .


worksheet.set_comments_author()
-------------------------------

.. py:function:: set_comments_author(author)

   Set the default author of the cell comments.

   :param string author: Comment author.

This method is used to set the default author of all cell comments::

    worksheet.set_comments_author('John Smith')

Individual comment authors can be set using the ``author`` parameter of the
``write_comment`` method (see above).

If no author is specified the default comment author name is an empty string.

For more details see :ref:`cell_comments` and :ref:`ex_comments2` .


worksheet.get_name()
--------------------

.. py:function:: get_name()

   Retrieve the worksheet name.

The ``get_name()`` method is used to retrieve the name of a worksheet. This is
something useful for debugging or logging::

    for worksheet in workbook.worksheets():
        print worksheet.get_name()

There is no ``set_name()`` method. The only safe way to set the worksheet name
is via the ``add_worksheet()`` method.


worksheet.activate()
--------------------

.. py:function:: activate()

   Make a worksheet the active, i.e., visible worksheet.

The ``activate()`` method is used to specify which worksheet is initially
visible in a multi-sheet workbook::

    worksheet1 = workbook.add_worksheet()
    worksheet2 = workbook.add_worksheet()
    worksheet3 = workbook.add_worksheet()

    worksheet3.activate()

.. image:: _images/worksheet_activate.png

More than one worksheet can be selected via the ``select()`` method, see below,
however only one worksheet can be active.

The default active worksheet is the first worksheet.


worksheet.select()
------------------

.. py:function:: select()

   Set a worksheet tab as selected.

The ``select()`` method is used to indicate that a worksheet is selected in a
multi-sheet workbook::

    worksheet1.activate()
    worksheet2.select()
    worksheet3.select()

A selected worksheet has its tab highlighted. Selecting worksheets is a way of
grouping them together so that, for example, several worksheets could be
printed in one go. A worksheet that has been activated via the ``activate()``
method will also appear as selected.


worksheet.hide()
----------------

.. py:function:: hide()

   Hide the current worksheet.

The ``hide()`` method is used to hide a worksheet::

    worksheet2.hide()

You may wish to hide a worksheet in order to avoid confusing a user with
intermediate data or calculations.

.. image:: _images/hide_sheet.png

A hidden worksheet can not be activated or selected so this method is mutually
exclusive with the :func:`activate()` and :func:`select()` methods. In
addition, since the first worksheet will default to being the active
worksheet, you cannot hide the first worksheet without activating another
sheet::

    worksheet2.activate()
    worksheet1.hide()

See :ref:`ex_hide_sheet` for more details.


worksheet.very_hidden()
-----------------------

.. py:function:: very_hidden()

   Hide the current worksheet. Can only be unhidden by VBA.

The ``very_hidden()`` method can be used to hide a worksheet similar to the
``hide()`` method. The difference is that the worksheet cannot be unhidden in
the the Excel user interface. The Excel worksheet "xlSheetVeryHidden" option can
only be unset programmatically by VBA.


worksheet.set_first_sheet()
---------------------------

.. py:function:: set_first_sheet()

   Set current worksheet as the first visible sheet tab.

The :func:`activate()` method determines which worksheet is initially selected.
However, if there are a large number of worksheets the selected worksheet may
not appear on the screen. To avoid this you can select which is the leftmost
visible worksheet tab using ``set_first_sheet()``::

    for in range(1, 21):
        workbook.add_worksheet

    worksheet19.set_first_sheet()  # First visible worksheet tab.
    worksheet20.activate()         # First visible worksheet.

This method is not required very often. The default value is the first
worksheet.


worksheet.merge_range()
-----------------------

.. py:function:: merge_range(first_row, first_col, \
                             last_row, last_col, data[, cell_format])

   Merge a range of cells.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :param data:        Cell data to write. Variable types.
   :param cell_format: Optional Format object.
   :type  first_row:   int
   :type  first_col:   int
   :type  last_row:    int
   :type  last_col:    int
   :type  cell_format: :ref:`Format <format>`

   :raises OverlappingRange: if the range overlaps a previous merge or table range.

   :returns:  0: Success.
   :returns: -1: Row or column is out of worksheet bounds.
   :returns: Other: Error return value of the called ``write()`` method.

The ``merge_range()`` method allows cells to be merged together so that they
act as a single area.

Excel generally merges and centers cells at same time. To get similar behavior
with XlsxWriter you need to apply a :ref:`Format <format>`::

    merge_format = workbook.add_format({'align': 'center'})

    worksheet.merge_range('B3:D4', 'Merged Cells', merge_format)

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.merge_range(2, 1, 3, 3, 'Merged Cells', merge_format)
    worksheet.merge_range('B3:D4',    'Merged Cells', merge_format)

See :ref:`cell_notation` for more details.

It is possible to apply other formatting to the merged cells as well::

    merge_format = workbook.add_format({
        'bold':     True,
        'border':   6,
        'align':    'center',
        'valign':   'vcenter',
        'fg_color': '#D7E4BC',
    })

    worksheet.merge_range('B3:D4', 'Merged Cells', merge_format)

.. image:: _images/merge_range.png

See :ref:`ex_merge1` for more details.

The ``merge_range()`` method writes its ``data`` argument using
:func:`write()`. Therefore it will handle numbers, strings and formulas as
usual. If this doesn't handle your data correctly then you can overwrite the
first cell with a call to one of the other
``write_*()`` methods using the same :ref:`Format
<format>` as in the merged cells. See :ref:`ex_merge_rich`.

.. image:: _images/merge_rich.png

.. Note::

   Merged ranges generally don't work in XlsxWriter when :func:`Workbook`
   ``'constant_memory'`` mode is enabled.


worksheet.autofilter()
----------------------

.. py:function:: autofilter(first_row, first_col, last_row, last_col)

   Set the autofilter area in the worksheet.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :type  first_row:   int
   :type  first_col:   int
   :type  last_row:    int
   :type  last_col:    int

The ``autofilter()`` method allows an autofilter to be added to a worksheet. An
autofilter is a way of adding drop down lists to the headers of a 2D range of
worksheet data. This allows users to filter the data based on simple criteria
so that some data is shown and some is hidden.

.. image:: _images/autofilter3.png

To add an autofilter to a worksheet::

    worksheet.autofilter('A1:D11')

Both row-column and A1 style notation are supported. The following are
equivalent::

    worksheet.autofilter(0, 0, 10, 3)
    worksheet.autofilter('A1:D11')

See :ref:`cell_notation` for more details.

Filter conditions can be applied using the :func:`filter_column()` or
:func:`filter_column_list()` methods.

See :ref:`working_with_autofilters` for more details.


worksheet.filter_column()
-------------------------

.. py:function:: filter_column(col, criteria)

   Set the column filter criteria.

   :param int col:          Filter column (zero-indexed).
   :param string criteria:  Filter criteria.


The ``filter_column`` method can be used to filter columns in a autofilter
range based on simple conditions.


The conditions for the filter are specified using simple expressions::

    worksheet.filter_column('A', 'x > 2000')
    worksheet.filter_column('B', 'x > 2000 and x < 5000')

The ``col`` parameter can either be a zero indexed column number or a string
column name::

    worksheet.filter_column(2,   'x > 2000')
    worksheet.filter_column('C', 'x > 2000')

See :ref:`cell_notation` for more details.

It isn't sufficient to just specify the filter condition. You must also hide
any rows that don't match the filter condition. See
:ref:`working_with_autofilters` for more details.


worksheet.filter_column_list()
------------------------------

.. py:function:: filter_column_list(col, filters)

   Set the column filter criteria in Excel 2007 list style.

   :param int col:       Filter column (zero-indexed).
   :param list filters:  List of filter criteria to match.

The ``filter_column_list()`` method can be used to represent filters with
multiple selected criteria::

    worksheet.filter_column_list('A', ['March', 'April', 'May'])

The ``col`` parameter can either be a zero indexed column number or a string
column name::

    worksheet.filter_column_list(2,   ['March', 'April', 'May'])
    worksheet.filter_column_list('C', ['March', 'April', 'May'])

See :ref:`cell_notation` for more details.

One or more criteria can be selected::

    worksheet.filter_column_list('A', ['March'])
    worksheet.filter_column_list('C', [100, 110, 120, 130])

To filter blanks as part of the list use `Blanks` as a list item::

    worksheet.filter_column_list('A', ['March', 'April', 'May', 'Blanks'])

It isn't sufficient to just specify filters. You must also hide any rows that
don't match the filter condition. See :ref:`working_with_autofilters` for more
details.


worksheet.set_selection()
-------------------------
.. py:function:: set_selection(first_row, first_col, last_row, last_col)

   Set the selected cell or cells in a worksheet.

   :param first_row:   The first row of the range. (All zero indexed.)
   :param first_col:   The first column of the range.
   :param last_row:    The last row of the range.
   :param last_col:    The last col of the range.
   :type  first_row:   int
   :type  first_col:   int
   :type  last_row:    int
   :type  last_col:    int


The ``set_selection()`` method can be used to specify which cell or range of
cells is selected in a worksheet. The most common requirement is to select a
single cell, in which case the ``first_`` and ``last_`` parameters should be
the same.

The active cell within a selected range is determined by the order in which
``first_`` and ``last_`` are specified.

Examples::

    worksheet1.set_selection(3, 3, 3, 3)  # 1. Cell D4.
    worksheet2.set_selection(3, 3, 6, 6)  # 2. Cells D4 to G7.
    worksheet3.set_selection(6, 6, 3, 3)  # 3. Cells G7 to D4.
    worksheet4.set_selection('D4')        # Same as 1.
    worksheet5.set_selection('D4:G7')     # Same as 2.
    worksheet6.set_selection('G7:D4')     # Same as 3.

As shown above, both row-column and A1 style notation are supported. See
:ref:`cell_notation` for more details. The default cell selection is
``(0, 0)``, ``'A1'``.


worksheet.set_top_left_cell()
-----------------------------

.. py:function:: set_top_left_cell(row, col)

   Set the first visible cell at the top left of a worksheet.

   :param int row:      The cell row (zero indexed).
   :param int col:      The cell column (zero indexed).


This ``set_top_left_cell`` method can be used to set the top leftmost visible
cell in the worksheet::

    worksheet.set_top_left_cell(31, 26)

    # Same as:
    worksheet.set_top_left_cell('AA32')


.. image:: _images/top_left_cell.png

As shown above, both row-column and A1 style notation are supported. See
:ref:`cell_notation` for more details.


worksheet.freeze_panes()
------------------------

.. py:function:: freeze_panes(row, col [, top_row, left_col])

   Create worksheet panes and mark them as frozen.

   :param int row:      The cell row (zero indexed).
   :param int col:      The cell column (zero indexed).
   :param int top_row:  Topmost visible row in scrolling region of pane.
   :param int left_col: Leftmost visible row in scrolling region of pane.

The ``freeze_panes()`` method can be used to divide a worksheet into horizontal
or vertical regions known as panes and to "freeze" these panes so that the
splitter bars are not visible.

The parameters ``row`` and ``col`` are used to specify the location of the
split. It should be noted that the split is specified at the top or left of a
cell and that the method uses zero based indexing. Therefore to freeze the
first row of a worksheet it is necessary to specify the split at row 2 (which
is 1 as the zero-based index).

You can set one of the ``row`` and ``col`` parameters as zero if you do not
want either a vertical or horizontal split.

Examples::

    worksheet.freeze_panes(1, 0)  # Freeze the first row.
    worksheet.freeze_panes('A2')  # Same using A1 notation.
    worksheet.freeze_panes(0, 1)  # Freeze the first column.
    worksheet.freeze_panes('B1')  # Same using A1 notation.
    worksheet.freeze_panes(1, 2)  # Freeze first row and first 2 columns.
    worksheet.freeze_panes('C2')  # Same using A1 notation.

As shown above, both row-column and A1 style notation are supported. See
:ref:`cell_notation` for more details.

The parameters ``top_row`` and ``left_col`` are optional. They are used to
specify the top-most or left-most visible row or column in the scrolling
region of the panes. For example to freeze the first row and to have the
scrolling region begin at row twenty::

    worksheet.freeze_panes(1, 0, 20, 0)

You cannot use A1 notation for the ``top_row`` and ``left_col`` parameters.

See :ref:`ex_panes` for more details.


worksheet.split_panes()
-----------------------

.. py:function:: split_panes(x, y [, top_row, left_col])

   Create worksheet panes and mark them as split.

   :param float x:      The position for the vertical split.
   :param float y:      The position for the horizontal split.
   :param int top_row:  Topmost visible row in scrolling region of pane.
   :param int left_col: Leftmost visible row in scrolling region of pane.

The ``split_panes``  method can be used to divide a worksheet into horizontal
or vertical regions known as panes. This method is different from the
``freeze_panes()`` method in that the splits between the panes will be visible
to the user and each pane will have its own scroll bars.

The parameters ``y`` and ``x`` are used to specify the vertical and horizontal
position of the split. The units for ``y`` and ``x`` are the same as those
used by Excel to specify row height and column width. However, the vertical
and horizontal units are different from each other. Therefore you must specify
the ``y`` and ``x`` parameters in terms of the row heights and column widths
that you have set or the default values which are ``15`` for a row and
``8.43`` for a column.

You can set one of the ``y`` and ``x`` parameters as zero if you do not want
either a vertical or horizontal split. The parameters ``top_row`` and
``left_col`` are optional. They are used to specify the top-most or left-most
visible row or column in the bottom-right pane.

Example::

    worksheet.split_panes(15, 0)     # First row.
    worksheet.split_panes(0, 8.43)   # First column.
    worksheet.split_panes(15, 8.43)  # First row and column.

You cannot use A1 notation with this method.

See :ref:`ex_panes` for more details.


worksheet.set_zoom()
--------------------

.. py:function:: set_zoom(zoom)

   Set the worksheet zoom factor.

   :param int zoom: Worksheet zoom factor.

Set the worksheet zoom factor in the range ``10 <= zoom <= 400``::

    worksheet1.set_zoom(50)
    worksheet2.set_zoom(75)
    worksheet3.set_zoom(300)
    worksheet4.set_zoom(400)

The default zoom factor is 100. It isn't possible to set the zoom to
"Selection" because it is calculated by Excel at run-time.

Note, ``set_zoom()`` does not affect the scale of the printed page. For that
you should use :func:`set_print_scale()`.

worksheet.set_zoom_to_fit()
---------------------------

.. py:function:: set_zoom_to_fit()

   Set the chartsheet to zoom to fit the screen.

This method is used to ensure that a chartsheet is zoomed automatically by Excel
to fit the screen even when the window is resized.

It only has an effect for chartsheets.


worksheet.right_to_left()
-------------------------

.. py:function:: right_to_left()

   Display the worksheet cells from right to left for some versions of Excel.

The ``right_to_left()`` method is used to change the default direction of the
worksheet from left-to-right, with the A1 cell in the top left, to
right-to-left, with the A1 cell in the top right::

    worksheet.right_to_left()

This is useful when creating Arabic, Hebrew or other near or far eastern
worksheets that use right-to-left as the default direction.

.. image:: _images/right_to_left.png

See also the Format :func:`set_reading_order` property to set the direction of the
text within cells and the :ref:`ex_right_to_left` example program.


worksheet.hide_zero()
---------------------

.. py:function:: hide_zero()

   Hide zero values in worksheet cells.

The ``hide_zero()`` method is used to hide any zero values that appear in
cells::

    worksheet.hide_zero()


worksheet.set_background()
--------------------------

.. py:function:: set_background(filename [, is_byte_stream])

   Set the background image for a worksheet.

   :param str filename:        The image file (or byte stream).
   :param bool is_byte_stream: The file is a stream of bytes.

The ``set_background()`` method can be used to set the background image for the
worksheet::

    worksheet.set_background('logo.png')

.. image:: _images/background01.png

The ``set_background()`` method supports all the image formats supported by
:func:`insert_image`.

Some people use this method to add a watermark background to their
document. However, Microsoft recommends using a header image `to set a
watermark
<https://support.microsoft.com/en-us/office/add-a-watermark-in-excel-a372182a-d733-484e-825c-18ddf3edf009>`_.
The choice of method depends on whether you want the watermark to be visible
in normal viewing mode or just when the file is printed. In XlsxWriter you can
get the header watermark effect using :func:`set_header`::

    worksheet.set_header('&C&G', {'image_center': 'watermark.png'})

It is also possible to pass an in-memory byte stream to ``set_background()``
if the ``is_byte_stream`` parameter is set to True. The stream should be
:class:`io.BytesIO`::

    worksheet.set_background(io_bytes, is_byte_stream=True)

See :ref:`ex_background` for an example.


worksheet.set_tab_color()
-------------------------

.. py:function:: set_tab_color(color)

   Set the color of the worksheet tab.

   :param color: The tab color.
   :type color: string|Color

The ``set_tab_color()`` method is used to change the color of the worksheet
tab::

    worksheet1.set_tab_color('red')
    worksheet2.set_tab_color('#FF9900')  # Orange

The color can be a :ref:`Color() <Color>` instance, a HTML style ``#RRGGBB``
string or a limited number of named colors, see :ref:`colors`.

See :ref:`ex_tab_colors` for more details.


worksheet.protect()
-------------------

.. py:function:: protect()

   Protect elements of a worksheet from modification.

   :param string password: A worksheet password.
   :param dict   options:  A dictionary of worksheet options to protect.


The ``protect()`` method is used to protect a worksheet from modification::

    worksheet.protect()

The ``protect()`` method also has the effect of enabling a cell's ``locked``
and ``hidden`` properties if they have been set. A *locked* cell cannot be
edited and this property is on by default for all cells. A *hidden* cell will
display the results of a formula but not the formula itself. These properties
can be set using the :func:`set_locked` and :func:`set_hidden` format methods.

You can optionally add a password to the worksheet protection::

    worksheet.protect('abc123')

The password should be an ASCII string. Passing the empty string ``''`` is the
same as turning on protection without a password. See the note below on the
"password" strength.

You can specify which worksheet elements you wish to protect by passing a
dictionary in the ``options`` argument with any or all of the following keys::

    # Default values shown.
    options = {
        'objects':               False,
        'scenarios':             False,
        'format_cells':          False,
        'format_columns':        False,
        'format_rows':           False,
        'insert_columns':        False,
        'insert_rows':           False,
        'insert_hyperlinks':     False,
        'delete_columns':        False,
        'delete_rows':           False,
        'select_locked_cells':   True,
        'sort':                  False,
        'autofilter':            False,
        'pivot_tables':          False,
        'select_unlocked_cells': True,
    }

The default boolean values are shown above. Individual elements can be
protected as follows::

    worksheet.protect('abc123', {'insert_rows': True})

For chartsheets the allowable options and default values are::

    options = {
        'objects':               True,
        'content':               True,
    }

See also the :func:`set_locked` and :func:`set_hidden` format methods and
:ref:`ex_protection`.

.. Note::

   Worksheet level passwords in Excel offer very weak protection. They do not
   encrypt your data and are very easy to deactivate. Full workbook encryption
   is not supported by XlsxWriter. However, it is possible to encrypt an
   XlsxWriter file using a third party open source tool called `msoffice-crypt
   <https://github.com/herumi/msoffice>`_. This works for macOS, Linux and
   Windows::

       msoffice-crypt.exe -e -p password clear.xlsx encrypted.xlsx


worksheet.unprotect_range()
---------------------------

.. py:function:: unprotect_range(cell_range, range_name)

   Unprotect ranges within a protected worksheet.

   :param string cell_range: The cell or cell range to unprotect.
   :param string range_name: An name for the range.

The ``unprotect_range()`` method is used to unprotect ranges in a protected
worksheet. It can be used to set a single range or multiple ranges::

    worksheet.unprotect_range('A1')
    worksheet.unprotect_range('C1')
    worksheet.unprotect_range('E1:E3')
    worksheet.unprotect_range('G1:K100')

As in Excel the ranges are given sequential names like ``Range1`` and
``Range2`` but a user defined name can also be specified::

    worksheet.unprotect_range('G4:I6', 'MyRange')


worksheet.set_default_row()
---------------------------

.. py:function:: set_default_row(height, hide_unused_rows)

   Set the default row properties.

   :param float height:          Default height. Optional, defaults to 15.
   :param bool hide_unused_rows: Hide unused rows. Optional, defaults to False.


The ``set_default_row()`` method is used to set the limited number of default
row properties allowed by Excel which are the default height and the option to
hide unused rows. These parameters are an optimization used by Excel to set
row properties without generating a very large file with an entry for each row.

To set the default row height::

    worksheet.set_default_row(24)

To hide unused rows::

    worksheet.set_default_row(hide_unused_rows=True)

See :ref:`ex_hide_row_col` for more details.

worksheet.outline_settings()
----------------------------

.. py:function:: outline_settings(visible, symbols_below, symbols_right, \
                                  auto_style)

   Control outline settings.

   :param bool visible:       Outlines are visible. Optional, defaults to True.
   :param bool symbols_below: Show row outline symbols below the outline bar.
                              Optional, defaults to True.
   :param bool symbols_right: Show column outline symbols to the right of the
                              outline bar. Optional, defaults to True.
   :param bool auto_style:    Use Automatic style. Optional, defaults to False.


The ``outline_settings()`` method is used to control the appearance of outlines
in Excel. Outlines are described in :ref:`outlines`::

        worksheet1.outline_settings(False, False, False, True)

The ``'visible'`` parameter is used to control whether or not outlines are
visible. Setting this parameter to ``False`` will cause all outlines on the
worksheet to be hidden. They can be un-hidden in Excel by means of the "Show
Outline Symbols" command button. The default setting is ``True`` for visible
outlines.

The ``'symbols_below'`` parameter is used to control whether the row outline
symbol will appear above or below the outline level bar. The default setting
is ``True`` for symbols to appear below the outline level bar.

The ``'symbols_right'`` parameter is used to control whether the column outline
symbol will appear to the left or the right of the outline level bar. The
default setting is ``True`` for symbols to appear to the right of the outline
level bar.

The ``'auto_style'`` parameter is used to control whether the automatic outline
generator in Excel uses automatic styles when creating an outline. This has no
effect on a file generated by ``XlsxWriter`` but it does have an effect on how
the worksheet behaves after it is created. The default setting is ``False``
for "Automatic Styles" to be turned off.

The default settings for all of these parameters correspond to Excel's default
parameters.

The worksheet parameters controlled by ``outline_settings()`` are rarely used.


worksheet.set_vba_name()
------------------------

.. py:function:: set_vba_name(name)
   :noindex:

   Set the VBA name for the worksheet.

   :param string name: The VBA name for the worksheet.

The ``set_vba_name()`` method can be used to set the VBA codename for the
worksheet (there is a similar method for the workbook VBA name). This is
sometimes required when a vbaProject macro included via ``add_vba_project()``
refers to the worksheet. The default Excel VBA name of ``Sheet1``, etc., is
used if a user defined name isn't specified.

See :ref:`macros` for more details.


worksheet.ignore_errors()
-------------------------

.. py:function:: ignore_errors(options)

   Ignore various Excel errors/warnings in a worksheet for user defined
   ranges.

   :returns:  0: Success.
   :returns: -1: Incorrect parameter or option.

The ``ignore_errors()`` method can be used to ignore various worksheet cell
errors/warnings. For example the following code writes a string that looks
like a number::

    worksheet.write_string('D2', '123')

This causes Excel to display a small green triangle in the top left hand
corner of the cell to indicate an error/warning:

.. image:: _images/ignore_errors1.png

Sometimes these warnings are useful indicators that there is an issue in the
spreadsheet but sometimes it is preferable to turn them off. Warnings can be
turned off at the Excel level for all workbooks and worksheets by using the
using "Excel options -> Formulas -> Error checking rules". Alternatively you
can turn them off for individual cells in a worksheet, or ranges of cells,
using the ``ignore_errors()`` method.

The worksheet errors/warnings that can be ignored are:

* ``number_stored_as_text``: Turn off errors/warnings for numbers stores as
  text.

* ``eval_error``: Turn off errors/warnings for formula errors (such as divide
  by zero).

* ``formula_differs``: Turn off errors/warnings for formulas that differ from
  surrounding formulas.

* ``formula_range``: Turn off errors/warnings for formulas that omit cells in
  a range.

* ``formula_unlocked``: Turn off errors/warnings for unlocked cells that
  contain formulas.

* ``empty_cell_reference``: Turn off errors/warnings for formulas that refer
  to empty cells.

* ``list_data_validation``: Turn off errors/warnings for cells in a table that
  do not comply with applicable data validation rules.

* ``calculated_column``: Turn off errors/warnings for cell formulas that
  differ from the column formula.

* ``two_digit_text_year``: Turn off errors/warnings for formulas that contain
  a two digit text representation of a year.

The ``ignore_errors()`` range can be a single cell, a range of cells, or
multiple cells and ranges separated by spaces::

    # Single cell.
    worksheet.ignore_errors({'eval_error': 'C6'})

    # Or a single range:
    worksheet.ignore_errors({'eval_error': 'C6:G8'})

    # Or multiple cells and ranges:
    worksheet.ignore_errors({'eval_error': 'C6 E6 G1:G20 J2:J6'})

Calling ``ignore_errors()`` multiple times will overwrite the previous values
but it is possible to ignore several types of errors/warnings at the same time
by adding them in a dict::

    # Or for more than one option:
    worksheet.ignore_errors({'number_stored_as_text': 'A1:A50',
                             'eval_error':            'B1:B50'})

It is important to note that Excel only supports one type of error/warning per
cell or range so the cells/ranges must be unique and must not overlap::

    # Error, overlapping cells!
    worksheet.ignore_errors({'number_stored_as_text': 'A1:A50',
                             'eval_error':            'A1'})

This error isn't currently caught by XlsxWriter so some care is needed when
handling multiple warning types.

You can turn off warnings for an entire column by specifying the range from
the first cell in the column to the last cell in the column::

    worksheet.ignore_errors({'number_stored_as_text': 'A1:A1048576'})

Or for the entire worksheet by specifying the range from the first cell in the
worksheet to the last cell in the worksheet::

    worksheet.ignore_errors({'number_stored_as_text': 'A1:XFD1048576'})


See also :ref:`ex_ignore_errors`.





================================================================
End of Codebase
================================================================
